<!doctype HTML public "-//W3O//DTD W3 HTML 3.2//EN">
<HTML>
<HEAD>

<!-- 
  Document                : examples.htm
  representing node       : Examples of using the Pretty Printer  [ID:NO-1285]
                 of class : SubSection  [ID:SC-4]
  Generated by SchemaText : 1.52
  From HSDL source        : ansi cl
  At                      : 09:52:01 23.07.98

  About SchemaText        : http://www.schema.de
-->

<META NAME="GENERATOR" CONTENT="SchemaText 1.40f">
<META NAME="AUTHOR" CONTENT="Franz Inc.">
<META NAME="DATE" CONTENT="23.07.98">
<META NAME="TIME" CONTENT="09:51:09">
<META NAME="VERSION" CONTENT="520">

<TITLE>Examples of using the Pretty Printer</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF">

<table border="0" width="100%" cellpadding="1" cellspacing="0">
  <tr>
    <td bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3">
      <tr>
        <td align="left" bgcolor="#00FFFF"><a href="../../doc/contents.htm"><b>ToC</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../../doc/introduction.htm"><b>DocOverview</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../../doc/cgide.htm"><b>CGDoc</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../../doc/release-notes.htm"><b>RelNotes</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../../doc/index.htm"><b>Index</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../../doc/permuted-index.htm"><b>PermutedIndex</b></a></td>
      </tr>
    </table>
    </td>
    <td align="right"><b>Allegro CL</b>
    </td>
  </tr>
</table>

<A NAME="SubSection_Examples_of__1285"></A>
<FONT FACE="ARIAL,GENEVA,HELVETICA">
<A HREF="../ansicl.htm" TARGET="_self"><IMG SRC="../images/a-top12b.gif" BORDER=0 WIDTH=12 HEIGHT=12 ALT="Home"></A><IMG SRC="../images/void16.gif" BORDER=0 WIDTH=16 HEIGHT=16>

<A HREF="../subsubse/prettyp0.htm"><IMG SRC="../images/a-lft12b.gif" BORDER=0 WIDTH=12 HEIGHT=12 ALT="Previous"></A> 
<A HREF="../section/thelispp.htm" TARGET="_self"><IMG SRC="../images/a-up12b.gif" BORDER=0 WIDTH=12 HEIGHT=12 ALT="Up"></A> 
<A HREF="notesab0.htm"><IMG SRC="../images/a-rgh12b.gif" BORDER=0 WIDTH=12 HEIGHT=12 ALT="Next"></A><IMG SRC="../images/void16.gif" BORDER=0 WIDTH=16 HEIGHT=16>
<A HREF="../meta/tableofc.htm" TARGET="_self"><IMG SRC="../images/toc.gif" BORDER=0 WIDTH=16 HEIGHT=16 ALT="Table of Contents"></A><IMG SRC="../images/void16.gif" BORDER=0 WIDTH=16 HEIGHT=16>
<A HREF="../meta/index.htm" TARGET="_self"><IMG SRC="../images/i16.gif" BORDER=0 WIDTH=16 HEIGHT=16 ALT="Index"></A>
<HR NOSHADE>
<TABLE WIDTH="90%"><TR>
<TD WIDTH=5%>&nbsp;</TD>
<TD WIDTH=95%>
<FONT SIZE=-2>
<A HREF="../ansicl.htm"> ANSI Common Lisp</A>&nbsp;&nbsp;<IMG SRC="../images/a-rgh6b.gif" BORDER=0 WIDTH=6 HEIGHT=6>&nbsp;<A HREF="../chapter/printer.htm">22 Printer</A>&nbsp;&nbsp;<IMG SRC="../images/a-rgh6b.gif" BORDER=0 WIDTH=6 HEIGHT=6>&nbsp;<A HREF="../section/thelispp.htm">22.2 The Lisp Pretty Printer</A>

</FONT>
<H3 ID="2">22.2.2   Examples of using the Pretty Printer</H3>

As an example of the interaction of logical blocks, conditional newlines,
and indentation, consider the function <TT>simple-pprint-defun</TT> below.  This
function prints out lists whose <I><A HREF="../glossary/c.htm#car">cars</A></I> are <A HREF="../dictentr/defun.htm"><B>defun</B></A> in the 
standard way assuming that the list has exactly length <TT>4</TT>.

<P ID="3">
<PRE ID="4">
(defun simple-pprint-defun (*standard-output* list)
  (pprint-logical-block (*standard-output* list :prefix "(" :suffix ")")
    (write (first list))
    (write-char #\Space)
    (pprint-newline :miser)
    (pprint-indent :current 0)
    (write (second list))
    (write-char #\Space)
    (pprint-newline :fill)
    (write (third list))
    (pprint-indent :block 1)
    (write-char #\Space)
    (pprint-newline :linear)
    (write (fourth list))))
</PRE>

<P ID="5">
Suppose that one evaluates the following:

<P ID="6">
<PRE ID="7">
(simple-pprint-defun *standard-output* '(defun prod (x y) (* x y)))
</PRE>

<P ID="8">















If the line width available is greater than or equal to <TT>26</TT>, then all of the
output appears on one line.  If the line width available is reduced to <TT>25</TT>,
a line break is inserted at the 
linear-style conditional newline
before the
<I><A HREF="../glossary/e.htm#expression">expression</A></I> <TT>(* x y)</TT>, producing the output shown.  The
<TT>(pprint-indent :block 1)</TT> causes <TT>(* x y)</TT> to be printed at a relative
indentation of <TT>1</TT> in the logical block.

<P ID="9">
<PRE ID="10">
 (DEFUN PROD (X Y) 
   (* X Y))
</PRE> 

<P ID="11">
If the line width available is <TT>15</TT>, a line break is also inserted at the
fill style conditional newline before the argument list.  The call on
<TT>(pprint-indent :current 0)</TT> causes the argument list to line up under the
function name.

<P ID="12">
<PRE ID="13">
(DEFUN PROD
       (X Y)
  (* X Y))
</PRE>

<P ID="14">
If <A HREF="../dictentr/print-mi.htm"><B>*print-miser-width*</B></A> were greater than or equal to 14, the example 
output above would have been as follows, because all indentation changes 
are ignored in miser mode and line breaks are inserted at 
miser-style conditional newlines.

<P ID="15">
<PRE ID="16">
 (DEFUN
  PROD
  (X Y)
  (* X Y))
</PRE> 

<P ID="17">
As an example of a per-line prefix, consider that evaluating the following
produces the output shown with a line width of <TT>20</TT> and
<A HREF="../dictentr/print-mi.htm"><B>*print-miser-width*</B></A> of <A HREF="../dictentr/nil.htm"><B>nil</B></A>.

<P ID="18">
<PRE ID="19">
 (pprint-logical-block (*standard-output* nil :per-line-prefix ";;; ")
   (simple-pprint-defun *standard-output* '(defun prod (x y) (* x y))))
 
 ;;; (DEFUN PROD
 ;;;        (X Y)
 ;;;   (* X Y))
</PRE>

<P ID="20">
As a more complex (and realistic) example, consider the function <TT>pprint-let</TT>
below.  This specifies how to print a <A HREF="../dictentr/letlet.htm"><B>let</B></A> <I><A HREF="../glossary/f.htm#form">form</A></I> in the traditional
style.  It is more complex than the example above, because it has to deal with
nested structure.  Also, unlike the example above it contains complete code to 
readably print any possible list that begins with the <I><A HREF="../glossary/s.htm#symbol">symbol</A></I> <A HREF="../dictentr/letlet.htm"><B>let</B></A>.
The outermost <A HREF="../dictentr/pprint-l.htm"><B>pprint-logical-block</B></A> <I><A HREF="../glossary/f.htm#form">form</A></I> handles the printing of
the input list as a whole and specifies that parentheses should be printed in the
output.  The second <A HREF="../dictentr/pprint-l.htm"><B>pprint-logical-block</B></A> <I><A HREF="../glossary/f.htm#form">form</A></I> handles the list 
of binding pairs.  Each pair in the list is itself printed by the innermost
<A HREF="../dictentr/pprint-l.htm"><B>pprint-logical-block</B></A>.  (A <A HREF="../dictentr/loop.htm"><B>loop</B></A> <I><A HREF="../glossary/f.htm#form">form</A></I> is used instead of
merely decomposing the pair into two <I><A HREF="../glossary/o.htm#object">objects</A></I> so that readable output will
be produced no matter whether the list corresponding to the pair has one element,
two elements, or (being malformed) has more than two elements.)   
A space and a 
fill-style conditional newline
are placed after
each pair except the last.  The loop at the end of the topmost
<A HREF="../dictentr/pprint-l.htm"><B>pprint-logical-block</B></A> <I><A HREF="../glossary/f.htm#form">form</A></I> prints out the forms in the body
of the <A HREF="../dictentr/letlet.htm"><B>let</B></A> <I><A HREF="../glossary/f.htm#form">form</A></I> separated by spaces and 
linear-style conditional newlines.

<P ID="21">
<PRE ID="22">
 (defun pprint-let (*standard-output* list)
   (pprint-logical-block (nil list :prefix "(" :suffix ")")
     (write (pprint-pop))
     (pprint-exit-if-list-exhausted)
     (write-char #\Space)
     (pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")
       (pprint-exit-if-list-exhausted)
       (loop (pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")
               (pprint-exit-if-list-exhausted)
               (loop (write (pprint-pop))
                     (pprint-exit-if-list-exhausted)
                     (write-char #\Space)
                     (pprint-newline :linear)))
             (pprint-exit-if-list-exhausted)
             (write-char #\Space)
             (pprint-newline :fill)))
     (pprint-indent :block 1)
     (loop (pprint-exit-if-list-exhausted)
           (write-char #\Space)
           (pprint-newline :linear)
           (write (pprint-pop)))))
</PRE>

<P ID="23">
Suppose that one evaluates the following with <A HREF="../dictentr/print-le.htm"><B>*print-level*</B></A> being 4, 
and <A HREF="../dictentr/print-ci.htm"><B>*print-circle*</B></A> being <I><A HREF="../glossary/t.htm#true">true</A></I>.

<P ID="24">
<PRE ID="25">
 (pprint-let *standard-output*
             '#1=(let (x (*print-length* (f (g 3))) 
                       (z . 2) (k (car y)))
                   (setq x (sqrt z)) #1#))
</PRE>

<P ID="26">
If the line length is greater than or equal to <TT>77</TT>, the output produced
appears on one line.  However, if the line length is <TT>76</TT>, line breaks are
inserted at the linear-style conditional newlines separating the forms in
the body and the output below is produced.  Note that, the degenerate
binding pair <TT>x</TT> is printed readably even though it fails to be a list; a
depth abbreviation marker is printed in place of <TT>(g 3)</TT>; the binding pair
<TT>(z . 2)</TT> is printed readably even though it is not a proper list; and
appropriate circularity markers are printed.

<P ID="27">
<PRE ID="28">
 #1=(LET (X (*PRINT-LENGTH* (F #)) (Z . 2) (K (CAR Y))) 
      (SETQ X (SQRT Z))
      #1#)
</PRE>

<P ID="29">
If the line length is reduced to <TT>35</TT>, a line break is inserted at one of the
fill-style conditional newlines separating the binding pairs.

<P ID="30">
<PRE ID="31">
 #1=(LET (X (*PRINT-PRETTY* (F #))
          (Z . 2) (K (CAR Y)))
      (SETQ X (SQRT Z))
      #1#)
</PRE>

<P ID="32">
Suppose that the line length is further reduced to <TT>22</TT> and <A HREF="../dictentr/print-le.htm"><B>*print-length*</B></A> is
set to <TT>3</TT>. In this situation, line breaks are inserted after both the first
and second binding pairs.  In addition, the second binding pair is itself
broken across two lines.  Clause (b) of the description of fill-style
conditional newlines (see the <I><A HREF="../glossary/f.htm#function">function</A></I> <A HREF="../dictentr/pprint-n.htm"><B>pprint-newline</B></A>) 
prevents the binding pair <TT>(z . 2)</TT> from being printed
at the end of the third line.  Note that the length abbreviation hides the
circularity from view and therefore the printing of circularity markers
disappears.

<P ID="33">
<PRE ID="34">
 (LET (X
       (*PRINT-LENGTH*
        (F #))
       (Z . 2) ...)
   (SETQ X (SQRT Z))
   ...)
</PRE>

<P ID="35">
The next function prints a vector using "<TT>#(...)</TT>" notation.

<P ID="36">
<PRE ID="37">
(defun pprint-vector (*standard-output* v)
  (pprint-logical-block (nil nil :prefix "#(" :suffix ")")
    (let ((end (length v)) (i 0))
      (when (plusp end)
        (loop (pprint-pop)
              (write (aref v i))
              (if (= (incf i) end) (return nil))
              (write-char #\Space)
              (pprint-newline :fill))))))
</PRE>

<P ID="38">
Evaluating the following with a line length of 15 produces the output shown.

<P ID="39">
<PRE ID="40">
 (pprint-vector *standard-output* '#(12 34 567 8 9012 34 567 89 0 1 23))
 
 #(12 34 567 8 
   9012 34 567 
   89 0 1 23)
</PRE>

<P ID="41">
As examples of the convenience of specifying pretty printing with 
<I><A HREF="../glossary/f.htm#formatstring">format strings</A></I>, consider that the functions <TT>simple-pprint-defun</TT>
and <TT>pprint-let</TT> used as examples above can be compactly defined as follows.
(The function <TT>pprint-vector</TT> cannot be defined using <A HREF="../dictentr/format.htm"><B>format</B></A>
because the data structure it traverses is not a list.)

<P ID="42">
<PRE ID="43">
(defun simple-pprint-defun (*standard-output* list)
  (format T "~:&lt;~W ~@_~:I~W ~:_~W~1I ~_~W~:&gt;" list))

(defun pprint-let (*standard-output* list)
  (format T "~:&lt;~W~^~:&lt;~@{~:&lt;~@{~W~^~_~}~:&gt;~^~:_~}~:&gt;~1I~@{~^~_~W~}~:&gt;" list)) 
</PRE>

<P ID="44">
In the following example, the first <I><A HREF="../glossary/f.htm#form">form</A></I> restores
<A HREF="../dictentr/print-pp.htm"><B>*print-pprint-dispatch*</B></A> to the equivalent of its initial value.
The next two forms then set up a special way to pretty print ratios.
Note that the more specific <I><A HREF="../glossary/t.htm#typespecifier">type specifier</A></I> has to be associated
with a higher priority.

<P ID="45">
<PRE ID="46">
 (setq *print-pprint-dispatch* (copy-pprint-dispatch nil))

 (set-pprint-dispatch 'ratio
   #'(lambda (s obj)
       (format s "#.(/ ~W ~W)" 
                 (numerator obj) (denominator obj))))

 (set-pprint-dispatch '(and ratio (satisfies minusp))
   #'(lambda (s obj)
       (format s "#.(- (/ ~W ~W))" 
               (- (numerator obj)) (denominator obj)))
   5)

 (pprint '(1/3 -2/3))
 (#.(/ 1 3) #.(- (/ 2 3)))
</PRE>

<P ID="47">
The following two <I><A HREF="../glossary/f.htm#form">forms</A></I> illustrate the definition of 
pretty printing functions for types of <I><A HREF="../glossary/c.htm#code">code</A></I>.  The first
<I><A HREF="../glossary/f.htm#form">form</A></I> illustrates how to specify the traditional method 
for printing quoted objects using <I><A HREF="../glossary/s.htm#singlequote">single-quote</A></I>.  Note
the care taken to ensure that data lists that happen to begin
with <A HREF="../dictentr/quote.htm"><B>quote</B></A> will be printed readably.  The second form 
specifies that lists beginning with the symbol <TT>my-let</TT>
should print the same way that lists beginning with <A HREF="../dictentr/letlet.htm"><B>let</B></A>
print when the initial <I><A HREF="../glossary/p.htm#pprintdispatchtable">pprint dispatch table</A></I> is in effect.

<P ID="48">
<PRE ID="49">
 (set-pprint-dispatch '(cons (member quote)) () 
   #'(lambda (s list)
       (if (and (consp (cdr list)) (null (cddr list)))
          (funcall (formatter "'~W") s (cadr list))
          (pprint-fill s list))))
 
 (set-pprint-dispatch '(cons (member my-let)) 
                      (pprint-dispatch '(let) nil))
</PRE>

<P ID="50">
The next example specifies a default method for printing lists that do not
correspond to function calls.  Note that the functions <A HREF="../dictentr/pprint-f.htm"><B>pprint-linear</B></A>,
<A HREF="../dictentr/pprint-f.htm"><B>pprint-fill</B></A>, and <A HREF="../dictentr/pprint-f.htm"><B>pprint-tabular</B></A> are all defined with
optional <I>colon-p</I> and <I>at-sign-p</I> arguments so that they can 
be used as <B>pprint dispatch functions</B> as well as <NOBR><TT>~/.../</TT></NOBR> 
functions.

<P ID="51">
<PRE ID="52">
 (set-pprint-dispatch '(cons (not (and symbol (satisfies fboundp))))
                      #'pprint-fill -5)
 
 ;; Assume a line length of 9
 (pprint '(0 b c d e f g h i j k))
 (0 b c d
  e f g h
  i j k)
</PRE> 

<P ID="53">
This final example shows how to define a pretty printing function for a
user defined data structure.

<P ID="54">
<PRE ID="55">
 (defstruct family mom kids)
 
 (set-pprint-dispatch 'family
   #'(lambda (s f)
       (funcall (formatter "~@&lt;#&lt;~;~W and ~2I~_~/pprint-fill/~;&gt;~:&gt;")
               s (family-mom f) (family-kids f))))
</PRE>

<P ID="56">
The pretty printing function for the structure <TT>family</TT> specifies how to
adjust the layout of the output so that it can fit aesthetically into
a variety of line widths.  In addition, it obeys 
the printer control variables <A HREF="../dictentr/print-le.htm"><B>*print-level*</B></A>,


<A HREF="../dictentr/print-le.htm"><B>*print-length*</B></A>, <A HREF="../dictentr/print-li.htm"><B>*print-lines*</B></A>,
<A HREF="../dictentr/print-ci.htm"><B>*print-circle*</B></A>


and <A HREF="../dictentr/print-es.htm"><B>*print-escape*</B></A>,
and can tolerate several different kinds of malformity in the data structure.
The output below shows what is printed out with a right margin of <TT>25</TT>,
<A HREF="../dictentr/print-pr.htm"><B>*print-pretty*</B></A> being <I><A HREF="../glossary/t.htm#true">true</A></I>, <A HREF="../dictentr/print-es.htm"><B>*print-escape*</B></A> being <I><A HREF="../glossary/f.htm#false">false</A></I>,
and a malformed <TT>kids</TT> list.

<P ID="57">
<PRE ID="58">
 (write (list 'principal-family
              (make-family :mom "Lucy"
                           :kids '("Mark" "Bob" . "Dan")))
        :right-margin 25 :pretty T :escape nil :miser-width nil)
 (PRINCIPAL-FAMILY
  #&lt;Lucy and
      Mark Bob . Dan&gt;)
</PRE>

<P ID="59">

Note that a pretty printing function for a structure is different from

the structure's <A HREF="../dictentr/print-ob.htm"><B>print-object</B></A> <I><A HREF="../glossary/m.htm#method">method</A></I>.
While

<A HREF="../dictentr/print-ob.htm"><B>print-object</B></A> <I><A HREF="../glossary/m.htm#method">methods</A></I>
are permanently associated with a structure,
pretty printing functions are stored in 
<I><A HREF="../glossary/p.htm#pprintdispatchtable">pprint dispatch tables</A></I> and can be rapidly changed to reflect 
different printing needs.  If there is no pretty printing function for 
a structure in the current <I><A HREF="../glossary/p.htm#pprintdispatchtable">pprint dispatch table</A></I>,

its <A HREF="../dictentr/print-ob.htm"><B>print-object</B></A> <I><A HREF="../glossary/m.htm#method">method</A></I>
is used instead.



</TD></TR></TABLE>
<HR NOSHADE>
<A HREF="../ansicl.htm" TARGET="_self"><IMG SRC="../images/a-top12b.gif" BORDER=0 WIDTH=12 HEIGHT=12 ALT="Home"></A><IMG SRC="../images/void16.gif" BORDER=0 WIDTH=16 HEIGHT=16>

<A HREF="../subsubse/prettyp0.htm"><IMG SRC="../images/a-lft12b.gif" BORDER=0 WIDTH=12 HEIGHT=12 ALT="Previous"></A> 
<A HREF="../section/thelispp.htm" TARGET="_self"><IMG SRC="../images/a-up12b.gif" BORDER=0 WIDTH=12 HEIGHT=12 ALT="Up"></A> 
<A HREF="notesab0.htm"><IMG SRC="../images/a-rgh12b.gif" BORDER=0 WIDTH=12 HEIGHT=12 ALT="Next"></A><IMG SRC="../images/void16.gif" BORDER=0 WIDTH=16 HEIGHT=16>
<A HREF="../meta/tableofc.htm" TARGET="_self"><IMG SRC="../images/toc.gif" BORDER=0 WIDTH=16 HEIGHT=16 ALT="Table of Contents"></A><IMG SRC="../images/void16.gif" BORDER=0 WIDTH=16 HEIGHT=16>
<A HREF="../meta/index.htm" TARGET="_self"><IMG SRC="../images/i16.gif" BORDER=0 WIDTH=16 HEIGHT=16 ALT="Index"></A>
<HR NOSHADE>

<SMALL><I><B>&#169; Franz Inc. 1998-2009</b> - File last updated 7-21-2009</I></SMALL>
</FONT>

</BODY>
</HTML>
