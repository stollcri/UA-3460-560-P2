module CORBA{

  typedef string Identifier;
  typedef string ScopedName;
  typedef string RepositoryId;
  enum DefinitionKind {
    dk_none, dk_all,
    dk_Attribute, dk_Constant, dk_Exception, dk_Interface,
    dk_Module, dk_Operation, dk_Typedef,
    dk_Alias, dk_Struct, dk_Union, dk_Enum,
    dk_Primitive, dk_String, dk_Sequence, dk_Array,
    dk_Repository,
    dk_Wstring, dk_Fixed
  };

  interface pseudo_typecode {};
  interface pseudo_object {
    //    boolean is_nil(); This is implemented in "hardware" so to speak.
    InterfaceDef _interface();
    boolean _not_existent();
    boolean _non_existent();
    boolean _is_a (in string logical_type_id);
    //    boolean is_equivalent(in Object other_object); // This is not implemented
    unsigned long hash (in unsigned long maximum); 
  };


  typedef pseudo_typecode TypeCode;

  typedef any pseudo_any;
  typedef boolean pseudo_boolean;
  typedef char pseudo_char;
  typedef double pseudo_double;
  typedef string pseudo_string;
  typedef float pseudo_float;
  typedef long pseudo_long;
  typedef octet pseudo_octet;
  typedef short pseudo_short;
  typedef unsigned long pseudo_ulong;
  typedef unsigned short pseudo_ushort;
  

  interface IRObject {
    readonly attribute DefinitionKind def_kind;
    void destroy ();
  };
  typedef string VersionSpec;
  interface Contained;
  interface Repository;
  interface Container;
  interface Contained : IRObject {
    attribute RepositoryId id;
    attribute Identifier name;
    attribute VersionSpec version;
    readonly attribute Container defined_in;
    readonly attribute ScopedName absolute_name;
    readonly attribute Repository containing_repository;
    struct Description {
      DefinitionKind kind;
      any value; 
    }; 
    Description describe ();
    void move (
	       in Container new_container,
	       in Identifier new_name,
	       in VersionSpec new_version
	       );
  };
  interface ModuleDef;
  interface ConstantDef;
  interface IDLType;
  interface StructDef;
  interface UnionDef;
  interface EnumDef;
  interface AliasDef;
  interface InterfaceDef;
  typedef sequence <InterfaceDef> InterfaceDefSeq;
  typedef sequence <Contained> ContainedSeq;
  struct StructMember {
    Identifier name;
    TypeCode type;
    IDLType type_def;
  };
  typedef sequence <StructMember> StructMemberSeq;
  struct UnionMember {
    Identifier name;
    any label;
    TypeCode type;
    IDLType type_def;
  };
  typedef sequence <UnionMember> UnionMemberSeq;
  typedef sequence <Identifier> EnumMemberSeq;
  interface Container : IRObject {
    Contained lookup ( in ScopedName search_name);
    ContainedSeq contents (
			   in DefinitionKind limit_type,
			   in boolean exclude_inherited
			   );
    ContainedSeq lookup_name (
			      in Identifier search_name, 
			      in long levels_to_search, 
			      in DefinitionKind limit_type,
			      in boolean exclude_inherited
			      );
    struct Description {
      Contained contained_object; 
      DefinitionKind kind;
      any value; 
    };
    typedef sequence<Description> DescriptionSeq;
    DescriptionSeq describe_contents (
				      in DefinitionKind limit_type,
				      in boolean exclude_inherited,
				      in long max_returned_objs
				      );
    ModuleDef create_module (
			     in RepositoryId id,
			     in Identifier name,
			     in VersionSpec version
			     );
    ConstantDef create_constant (
				 in RepositoryId id,
				 in Identifier name,
				 in VersionSpec version,
				 in IDLType type,
				 in any value
				 );
    StructDef create_struct (
			     in RepositoryId id,
			     in Identifier name,
			     in VersionSpec version,
			     in StructMemberSeq members
			     );
    UnionDef create_union (
			   in RepositoryId id,
			   in Identifier name,
			   in VersionSpec version,
			   in IDLType discriminator_type,
			   in UnionMemberSeq members
			   );
    EnumDef create_enum (
			 in RepositoryId id,
			 in Identifier name,
			 in VersionSpec version,
			 in EnumMemberSeq members
			 );
    AliasDef create_alias (
			   in RepositoryId id,
			   in Identifier name,
			   in VersionSpec version,
			   in IDLType original_type
			   );
    InterfaceDef create_interface (
				   in RepositoryId id,
				   in Identifier name,
				   in VersionSpec version,
				   in InterfaceDefSeq base_interfaces
				   );
    ExceptionDef create_exception(
				  in RepositoryId id,
				  in Identifier name,
				  in VersionSpec version,
				  in StructMemberSeq members
				  );
  };

  interface IDLType : IRObject {
    readonly attribute TypeCode type;
  };
  interface PrimitiveDef;
  interface StringDef;
  interface SequenceDef;
  interface ArrayDef;
  enum PrimitiveKind {
    pk_null, pk_void, pk_short, pk_long, pk_ushort, pk_ulong,
    pk_float, pk_double, pk_boolean, pk_char, pk_octet,
    pk_any, pk_TypeCode, pk_Principal, pk_string, pk_objref,
    pk_longlong, pk_ulonglong, pk_longdouble, pk_wchar, pk_wstring
  };
  interface Repository : Container {
    Contained lookup_id (in RepositoryId search_id);
    PrimitiveDef get_primitive (in PrimitiveKind kind);
    StringDef create_string (in unsigned long bound);
    WstringDef create_wstring (in unsigned long bound);
    SequenceDef create_sequence (
				 in unsigned long bound,
				 in IDLType element_type
				 );
    ArrayDef create_array (
			   in unsigned long length,
			   in IDLType element_type
			   );
    FixedDef create_fixed (
			   in unsigned short digits,
			   in short scale
			   );
  };
  interface ModuleDef : Container, Contained {
  };
  struct ModuleDescription {
    Identifier name; 
    RepositoryId id; 
    RepositoryId defined_in;
    VersionSpec version;
  };
  interface ConstantDef : Contained {
    readonly attribute TypeCode type;
    attribute IDLType type_def;
    attribute any value;
  };
  struct ConstantDescription {
    Identifier name; 
    RepositoryId id; 
    RepositoryId defined_in; 
    VersionSpec version;
    TypeCode type; 
    any value; 
  };
  interface TypedefDef : Contained, IDLType {
  };
  struct TypeDescription {
    Identifier name; 
    RepositoryId id; 
    RepositoryId defined_in; 
    VersionSpec version;
    TypeCode type; 
  };
  interface StructDef : TypedefDef, Container {
    attribute StructMemberSeq members;
  };
  interface UnionDef : TypedefDef, Container {
    readonly attribute TypeCode discriminator_type;
    attribute IDLType discriminator_type_def;
    attribute UnionMemberSeq members;
  };
  interface EnumDef : TypedefDef {
    attribute EnumMemberSeq members;
  };
  interface AliasDef : TypedefDef {
    attribute IDLType original_type_def;
  };
  interface PrimitiveDef: IDLType {
    readonly attribute PrimitiveKind kind;
  };
  interface StringDef : IDLType {
    attribute unsigned long bound;
  };
  interface WstringDef : IDLType {
    attribute unsigned long bound;
  };
  interface FixedDef : IDLType {
    attribute unsigned short digits;
    attribute short scale;
  };
  interface SequenceDef : IDLType {
    attribute unsigned long bound;
    readonly attribute TypeCode element_type;
    attribute IDLType element_type_def;
  };
  interface ArrayDef : IDLType {
    attribute unsigned long length;
    readonly attribute TypeCode element_type;
    attribute IDLType element_type_def;
  };
  interface ExceptionDef : Contained, Container {
    readonly attribute TypeCode type;
    attribute StructMemberSeq members;
  };
  struct ExceptionDescription {
    Identifier name; 
    RepositoryId id; 
    RepositoryId defined_in; 
    VersionSpec version;
    TypeCode type; 
  };
  enum AttributeMode {ATTR_NORMAL, ATTR_READONLY};
  interface AttributeDef : Contained {
    readonly attribute TypeCode type;
    attribute IDLType type_def;
    attribute AttributeMode mode;
  };
  struct AttributeDescription {
    Identifier name; 
    RepositoryId id; 
    RepositoryId defined_in; 
    VersionSpec version;
    TypeCode type;
    AttributeMode mode; 
  };
  enum OperationMode {OP_NORMAL, OP_ONEWAY};
  enum ParameterMode {PARAM_IN, PARAM_OUT, PARAM_INOUT};
  struct ParameterDescription {
    Identifier name; 
    TypeCode type; 
    IDLType type_def;
    ParameterMode mode;
  };
  typedef sequence <ParameterDescription> ParDescriptionSeq;
  typedef Identifier ContextIdentifier;
  typedef sequence <ContextIdentifier> ContextIdSeq;
  typedef sequence <ExceptionDef> ExceptionDefSeq;
  typedef sequence <ExceptionDescription> ExcDescriptionSeq;
  interface OperationDef : Contained { 
    readonly attribute TypeCode result;
    attribute IDLType result_def;
    attribute ParDescriptionSeq params;
    attribute OperationMode mode; 
    attribute ContextIdSeq contexts;
    attribute ExceptionDefSeq exceptions;
  };
  struct OperationDescription {
    Identifier name; 
    RepositoryId id; 
    RepositoryId defined_in; 
    VersionSpec version;
    TypeCode result; 
    OperationMode mode; 
    ContextIdSeq contexts; 
    ParDescriptionSeq parameters;
    ExcDescriptionSeq exceptions;
  };
  typedef sequence <RepositoryId> RepositoryIdSeq;
  typedef sequence <OperationDescription> OpDescriptionSeq;
  typedef sequence <AttributeDescription> AttrDescriptionSeq;
  interface InterfaceDef : Container, Contained, IDLType {
    attribute InterfaceDefSeq base_interfaces;
    boolean is_a (in RepositoryId interface_id);
    struct FullInterfaceDescription {
      Identifier name;
      RepositoryId id;
      RepositoryId defined_in;
      VersionSpec version;
      OpDescriptionSeq operations;
      AttrDescriptionSeq attributes;
      RepositoryIdSeq base_interfaces;
      TypeCode type;
    };
    FullInterfaceDescription describe_interface();
    AttributeDef create_attribute (
				   in RepositoryId id,
				   in Identifier name,
				   in VersionSpec version,
				   in IDLType type,
				   in AttributeMode mode
				   );
    OperationDef create_operation (
				   in RepositoryId id,
				   in Identifier name,
				   in VersionSpec version,
				   in IDLType result,
				   in OperationMode mode, 
				   in ParDescriptionSeq params,
				   in ExceptionDefSeq exceptions,
				   in ContextIdSeq contexts
				   );
  };
  struct InterfaceDescription {
    Identifier name; 
    RepositoryId id; 
    RepositoryId defined_in; 
    VersionSpec version;
    RepositoryIdSeq base_interfaces;
  };
  enum TCKind { 
    tk_null, 
    tk_void, 
    tk_short, 
    tk_long, 
    tk_ushort, 
    tk_ulong, 
    tk_float, 
    tk_double, 
    tk_boolean, 
    tk_char, 
    tk_octet, 
    tk_any, 
    tk_TypeCode, 
    tk_Principal, 
    tk_objref, 
    tk_struct, 
    tk_union, 
    tk_enum, 
    tk_string, 
    tk_sequence, 
    tk_array, 
    tk_alias, 
    tk_except,
    tk_longlong, 
    tk_ulonglong, 
    tk_longdouble,
    tk_wchar, 
    tk_wstring, 
    tk_fixed
  };

  //DII stuff:

  typedef unsigned long Flags;
  const Flags ARG_IN = 1;
  const Flags ARG_OUT = 2;
  const Flags ARG_INOUT = 3;
  const Flags CTX_RESTRICT_SCOPE = 15;
  


  // Standard system exceptions:
	#define ex_body {unsigned long minor; completion_status completed;}
	
	enum completion_status {COMPLETED_YES, COMPLETED_NO, COMPLETED_MAYBE};
	enum exception_type {NO_EXCEPTION, USER_EXCEPTION, SYSTEM_EXCEPTION};

	exception UNKNOWN 		ex_body;	// the unknown exception
	exception BAD_PARAM		ex_body; 	// an invalid parameter was
				// passed
	exception NO_MEMORY		ex_body; 	// dynamic memory allocation
				// failure	
	exception IMP_LIMIT		ex_body; 	// violated implementation limit
	exception COMM_FAILURE	ex_body; 	// communication failure
	exception INV_OBJREF		ex_body; 	// invalid object reference
	exception NO_PERMISSION	ex_body; 	// no permission for attempted op.
	exception INTERNAL		ex_body; 	// ORB internal error
	exception MARSHAL		ex_body; 	// error marshalling param/result
	exception INITIALIZE		ex_body; 	// ORB initialization failure
	exception NO_IMPLEMENT	ex_body; 	// operation implementation
  				// unavailable
	exception BAD_TYPECODE	ex_body; 	// bad typecode
	exception BAD_OPERATION	ex_body; 	// invalid operation
	exception NO_RESOURCES	ex_body; 	// insufficient resources for req.
	exception NO_RESPONSE	ex_body; 	// response to req. not yet
				// available
	exception PERSIST_STORE	ex_body; 	// persistent storage failure
	exception BAD_INV_ORDER	ex_body; 	// routine invocations out of order
	exception TRANSIENT		ex_body; 	// transient failure - reissue
				// request
	exception FREE_MEM		ex_body; 	// cannot free memory
	exception INV_IDENT		ex_body; 	// invalid identifier syntax
	exception INV_FLAG		ex_body; 	// invalid flag was specified
	exception INTF_REPOS		ex_body; 	// error accessing interface
				// repository
	exception BAD_CONTEXT	ex_body; 	// error processing context object
	exception OBJ_ADAPTER	ex_body; 	// failure detected by object
				// adapter
	exception DATA_CONVERSION	ex_body; 		// data conversion error
	exception OBJECT_NOT_EXIST	ex_body;	 	// non-existent object, delete
				// reference
	exception TRANSACTION_REQUIRED	   ex_body; // transaction required
	exception TRANSACTION_ROLLEDBACK  ex_body; // transaction rolled back
	exception INVALID_TRANSACTION	   ex_body; // invalid transaction
	exception ORBLINK_EXCEPTION ex_body;

};

