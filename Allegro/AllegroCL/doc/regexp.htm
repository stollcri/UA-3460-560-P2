<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"> <title>Regular Expression API</title></head><link rel="stylesheet" href="acldoc-styles.css" type="text/css"><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faqs/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 8.2</b><br><small><a href="introduction.htm#updates-s">Unrevised from 8.1 to 8.2.</a></small><br><a href="http://www.franz.com/support/documentation/8.1/doc/regexp.htm">8.1 version</a></td></tr></table><h1 id="2">Regular Expression API</h1><p id="3">This document contains the following sections:</p><a href="#regexp-intro-1">1.0 Regular Expression handling in Allegro CL: two implementations</a><br><a href="#regexp-new-1">2.0 The new regexp2 module</a><br>&nbsp;&nbsp;&nbsp;<a href="#regexp-new-matching-2">2.1 Matching mode in the regexp2 module</a><br>&nbsp;&nbsp;&nbsp;<a href="#regexp-new-summary-2">2.2 Regular expression syntax summary</a><br>&nbsp;&nbsp;&nbsp;<a href="#regexp-new-capturing-2">2.3 Capturing and back reference</a><br>&nbsp;&nbsp;&nbsp;<a href="#regexp-tree-2">2.4 Regexp trees</a><br>&nbsp;&nbsp;&nbsp;<a href="#regexp-new-api-2">2.5 User-level API in the regexp2 module</a><br>&nbsp;&nbsp;&nbsp;<a href="#regexp-new-compatibility-2">2.6 Compatibility issues in the regexp2 module</a><br>&nbsp;&nbsp;&nbsp;<a href="#regexp-new-performace-2">2.7 Performance notes in the regexp2 module</a><br><a href="#regexp-old-1">3.0 The older regexp API</a><br><hr><hr><h2 id="4"><a name="regexp-intro-1">1.0 Regular Expression handling in Allegro CL: two implementations</a></h2>

<p id="5">
A new regular expression handler in Allegro CL 6.2 was made available
with a patch released around June 7, 2004. Use <a href="operators/system/update-allegro.htm"><b>sys:update-allegro</b></a> to download the
patch. The new module is named <b>:regexp2</b> (you have the patch if
there is a <i>regexp2.fasl</i> in the
<i>code/</i> subdirectory of the Allegro directory).
</p>
<p id="6">
The new <b>regexp2</b> module has roughly the same API as the older
<b>regexp</b> module (which came with the original Allegro CL 6.2
release), except the functions have slightly different names, to avoid
name conflicts.  The functions are named by symbols in the
<code>excl</code> package, and are named <a href="operators/excl/compile-re.htm"><b>compile-re</b></a>, <a href="operators/excl/match-re.htm"><b>match-re</b></a>,
<a href="operators/excl/split-re.htm"><b>split-re</b></a>, and <a href="operators/excl/replace-re.htm"><b>replace-re</b></a>. (The older
module has functions <a href="operators/excl/compile-regexp.htm"><b>compile-regexp</b></a>, <a href="operators/excl/match-regexp.htm"><b>match-regexp</b></a>, <a href="operators/excl/split-regexp.htm"><b>split-regexp</b></a>, and <a href="operators/excl/replace-regexp.htm"><b>replace-regexp</b></a>.) Both modules can be loaded
and used at the same time in a running Lisp. 
</p>

<p id="7">
The new <b>regexp2</b> module is described in section
<a href="#regexp-new-1">Section 2.0 The new regexp2 module</a>. The older <b>regexp</b>
module is described in
<a href="#regexp-old-1">Section 3.0 The older regexp API</a>. Much information is
common to both, but we have not integrated the two descriptions
because we wished to release the new module as quickly as possible.
</p>

<hr><hr><h2 id="8"><a name="regexp-new-1">2.0 The new regexp2 module</a></h2>

<p id="9">
The new <b>regexp2</b> module provides a fast, mostly-Perl-compatible
regular expression matcher. It handles Unicode character set
(UCS-2). The module was made available by a patch on approximately
June 7, 2004. Download this patch (along with other patches) in the
usual fashion with <a href="operators/system/update-allegro.htm"><b>sys:update-allegro</b></a>. Symbols in the regexp2
module are in the excl package. 
</p>
<p id="10">
You load the regexp2 module with the form
</p>
<pre id="11">
(require :regexp2)
</pre>
<p id="12">
All the functionality of the regexp2 module is described in this
document. There are no separate documentation pages for operators
etc. in the module at this time. Note that there are documentation
pages for operators etc. in the older regexp module (described in
section <a href="#regexp-old-1">Section 3.0 The older regexp API</a> below in this
document). 
</p>

<hr><h2 id="13"><a name="regexp-new-matching-2">2.1 Matching mode in the regexp2 module</a></h2>

<p id="14">
Like Perl, there are four types of 'mode switches' that affect the 
meaning of regular expressions. The switch can be specified by the
keyword arguments passed to regexp APIs, or by embedding 'flags' in
the regular expression itself.   The following table lists the valid
mode switches.
</p>
<table BORDER="1" CELLSPACING="1" CELLPADDING="2" WIDTH="90%">
<tr>
<td WIDTH="15%" VALIGN="TOP"><strong>Flag</strong></td>
<td WIDTH="25%" VALIGN="TOP"><strong>Keyword argument</strong></td>
<td WIDTH="60%" VALIGN="TOP"><strong>Descrption (when 'on')</strong></td>
</tr>
<tr>
<td WIDTH="15%" VALIGN="TOP">
<b>i</b>
</td>
<td WIDTH="25%" VALIGN="TOP">
<code>:case-fold</code>
</td>
<td WIDTH="40%" VALIGN="TOP">
Case-insensitive match. Currently, case folding is only effective for
ASCII characters.
</td>
</tr>
<tr>
<td WIDTH="15%" VALIGN="TOP">
<b>m</b>
</td>
<td WIDTH="25%" VALIGN="TOP">
<code>:multiple-lines</code>
</td>
<td WIDTH="40%" VALIGN="TOP">
Treats the input string as multiple lines. If turned on, "^" and "$"
matches the start and end of any line instead of the beginning and end
of the whole string.
</td>
</tr>
<tr>
<td WIDTH="15%" VALIGN="TOP">
<b>s</b>
</td>
<td WIDTH="25%" VALIGN="TOP">
<code>:single-line</code>
</td>
<td WIDTH="40%" VALIGN="TOP">
Treats the input string as a single line. If turned on, "." matches
any character, even a newline.  Normally "." matches any character
<b><i>except</i></b> a newline.
</td>
</tr>
<tr>
<td WIDTH="15%" VALIGN="TOP">
<b>x</b>
</td> 
<td WIDTH="25%" VALIGN="TOP">
<code>:ignore-whitespace</code>
</td>
<td WIDTH="40%" VALIGN="TOP">
Extend syntax.  Whitespace in the regular expression is ignored, and
comments can be inserted, to increase legibility of the regular
expression.
</td>
</tr>
</table>

<p id="15">
Within a regular expression, a mode switch can be turned on/off
locally by <code>(?:...)</code> construct.  For example,
<code>(?i:foo)</code> makes <code>foo</code> match case
insensitively.  <code>(?-i:foo)</code> makes
<code>foo</code> match case sensitively.  You can combine
multiple flags, like <code>(?im-sx:foo)</code>.  A construct
like <code>(?i)</code> changes the mode switch until the end of
the current grouping.
</p>



<hr><h2 id="16"><a name="regexp-new-summary-2">2.2 Regular expression syntax summary</a></h2>

<h3 id="17">
Characters
</h3>

<table border="1" width="95%">
<tr>
<td width="26%">
<b>Construct</b>
</td>
<td width="74%">
<b>Matches</b>
</td>
</tr>
<tr>
<td width="26%">
x
</td>
<td width="74%">
The character x
</td>
</tr>
<tr>
<td width="26%">
\\
</td>
<td width="74%">
A backslash character
</td>
</tr>
<tr>
<td width="26%">
\0
</td>
<td width="74%">
#\null
</td>
</tr>
<tr>
<td width="26%">
\0n
</td>
<td width="74%">
(&lt;= 0 n 7)  A character x where (= (char-code x) #on)
</td>
</tr>
<tr>
<td width="26%">
\0nn
</td>
<td width="74%">
(&lt;= 0 n 7)  A character x where (= (char-code x) #onn)
</td>
</tr>
<tr>
<td width="26%">
\nn
</td>
<td width="74%">
(&lt;= 0 n 7) A character x where (= (char-code x) #onn), if this
cannot be a back-reference
</td>
</tr>
<tr>
<td width="26%">
\mnn
</td>
<td width="74%">
(&lt;= 0 m 3) (&lt;= 0 n 7) A character x where (= (char-code x) #omnn)
</td>
</tr>
<tr>
<td width="26%">
\xhh
</td>
<td width="74%">
A character x where (= (char-code x) #xhh)
</td>
</tr>
<tr>
<td width="26%">
\xh
</td>
<td width="74%">
A character x where (= (char-code x) #xh) if at the end of regexp or
followed by non-hexdigit char.
</td>
</tr>
<tr>
<td width="26%">
\x{h...}
</td>
<td width="74%">
A character x where (= (char-code x) #xh...).
</td>
</tr>
<tr>
<td width="26%">
\a
</td>
<td width="74%">
#\bell
</td>
</tr>
<tr>
<td width="26%">
\e
</td>
<td width="74%">
#\esc
</td>
</tr>
<tr>
<td width="26%">
\f
</td>
<td width="74%">
#\form
</td>
</tr>
<tr>
<td width="26%">
\t
</td>
<td width="74%">
#\tab
</td>
</tr>
<tr>
<td width="26%">
\n
</td>
<td width="74%">
#\linefeed
</td>
</tr>
<tr>
<td width="26%">
\r
</td>
<td width="74%">
#\return
</td>
</tr>
<tr>
<td width="26%">
\cx
</td>
<td width="74%">
control character corresponding to x (e.g. \cG for #\bell).
</td>
</tr>
</table>

<h3 id="18">
Predefined character classes
</h3>

<table border="1" width="95%">
<tr>
<td width="26%">
<b>Construct</b>
</td>
<td width="74%">
<b>Matches</b>
</td>
</tr>
<tr>
<td width="26%">
.
</td>
<td width="74%">
any character except newline (if 's' flag is on, matches any character
including newline).
</td>
</tr>
<tr>
<td width="26%">
\d
</td>
<td width="74%">
A digit character [0-9]
</td>
</tr>
<tr>
<td width="26%">
\D
</td>
<td width="74%">
A non-digit character [^0-9]
</td>
</tr>
<tr>
<td width="26%">
\s
</td>
<td width="74%">
A whitespace character [&nbsp;\n\r\t\f] (that is, #\space, #\newline,
#\return, #\tab, and #\formfeed).
</td>
</tr>
<tr>
<td width="26%">
\S
</td>
<td width="74%">
A non-whitespace character [^&nbsp;\n\r\t\f] 
</td>
</tr>
<tr>
<td width="26%">
\w
</td>
<td width="74%">
A word-constituent character. Currently, alphanumeric characters, #\_,
and any character whose code is larger than 128 is considered as a
word constituent character.  The treatment of large character set may
be improved in the later versions.
</td>
</tr>
<tr>
<td width="26%">
\W
</td>
<td width="74%">
A non-word-constituent character
</td>
</tr>
</table>

<h3 id="19">
Character classes
</h3>

<table border="1" width="95%">
<tr>
<td width="26%">
<b>Construct</b>
</td>
<td width="74%">
<b>Matches</b>
</td>
</tr>
<tr>
<td width="26%">
[abc]
</td>
<td width="74%">
a, b, or c
</td>
</tr>
<tr>
<td width="26%">
[^abc]
</td>
<td width="74%">
any character except a, b, or c
</td>
</tr>
<tr>
<td width="26%">
[a-zA-Z]
</td>
<td width="74%">
character range (a through z or A through Z)
</td>
</tr>
<tr>
<td width="26%">
\n, \nn, \mnn, \x, \xh, \xhh, \x{h..} \\, \a, \e, \f, \t, \n, \r, \cx
</td>
<td width="74%">
Octal and hexadecimal character notation, and the above single
character escape, are valid in character class as well.
</td>
</tr>
<tr>
<td width="26%">
other
</td>
<td width="74%">
\d, \D, \s, \S, \w, and \W can also be used within character class
notation, e.g.  [abc\d] == [abc0-9].
</td>
</tr>
</table>

<h3 id="20">
Assertions
</h3>

<table border="1" width="95%">
<tr>
<td width="26%">
<b>Construct</b>
</td>
<td width="74%">
<b>Matches</b>
</td>
</tr>
<tr>
<td width="26%">
 ^
</td>
<td width="74%">
Beginning of a string.  (if 'm' flag is on, matches at the beginning
of a string or just after a linefeed).
</td>
</tr>
<tr>
<td width="26%">
$
</td>
<td width="74%">
End of a string.  (if 'm' flag is on, matches at the end of a string
or just before a linefeed).
</td>
</tr>
<tr>
<td width="26%">
\b
</td>
<td width="74%">
A word boundary.
</td>
</tr>
<tr>
<td width="26%">
\B
</td>
<td width="74%">
A non word boundary.
</td>
</tr>
<tr>
<td width="26%">
\A
</td>
<td width="74%">
Beginning of a string.
</td>
</tr>
<tr>
<td width="26%">
\Z
</td>
<td width="74%">
End of a string, or before linefeed at the end.
</td>
</tr>
<tr>
<td width="26%">
\z
</td>
<td width="74%">
End of a string.
</td>
</tr>
</table>

<h3 id="21">
Greedy repetition
</h3>

<table border="1" width="95%">
<tr>
<td width="26%">
<b>Construct</b>
</td>
<td width="74%">
<b>Matches</b>
</td>
</tr>
<tr>
<td width="26%">
X?
</td>
<td width="74%">
Zero or one occurrence of X
</td>
</tr>
<tr>
<td width="26%">
X*
</td>
<td width="74%">
Zero or more occurrence of X
</td>
</tr>
<tr>
<td width="26%">
X+
</td>
<td width="74%">
One or more occurrence of X
</td>
</tr>
<tr>
<td width="26%">
X{n}
</td>
<td width="74%">
n times of X
</td>
</tr>
<tr>
<td width="26%">
X{n,}
</td>
<td width="74%">
n times or more repetition of X
</td>
</tr>
<tr>
<td width="26%">
X{n,m}
</td>
<td width="74%">
between n and m times of repetition of X
</td>
</tr>
</table>

<h3 id="22">
Non-greedy repetition
</h3>

<table border="1" width="95%">
<tr>
<td width="26%">
<b>Construct</b>
</td>
<td width="74%">
<b>Matches</b>
</td>
</tr>
<tr>
<td width="26%">
X??
</td>
<td width="74%">
Zero or one occurrence of X
</td>
</tr>
<tr>
<td width="26%">
X*?
</td>
<td width="74%">
Zero or more occurrences of X
</td>
</tr>
<tr>
<td width="26%">
X+?
</td>
<td width="74%">
One or more occurrences of X
</td>
</tr>
<tr>
<td width="26%">
X{n}?
</td>
<td width="74%">
n times of X
</td>
</tr>
<tr>
<td width="26%">
X{n,}?
</td>
<td width="74%">
n times or more repetition of X
</td>
</tr>
<tr>
<td width="26%">
X{n,m}?
</td>
<td width="74%">
between n and m times of repetition of X
</td>
</tr>
</table>

<h3 id="23">
Logical operators
</h3>

<table border="1" width="95%">
<tr>
<td width="26%">
<b>Construct</b>
</td>
<td width="74%">
<b>Matches</b>
</td>
</tr>
<tr>
<td width="26%">
XY
</td>
<td width="74%">
X followed by Y
</td>
</tr>
<tr>
<td width="26%">
X|Y
</td>
<td width="74%">
X or Y
</td>
</tr>
</table>

<h3 id="24">
Grouping and special constructs 
</h3>

<p id="25">
See <a href="#regexp-new-capturing-2">Section 2.3 Capturing and back reference</a> below for
the operation of capturing and reference.
</p>

<table border="1" width="95%">
<tr>
<td width="26%">
<b>Construct</b>
</td>
<td width="74%">
<b>Matches</b>
</td>
</tr>
<tr>
<td width="26%">
(X)
</td>
<td width="74%">
Groups X, and captures submatch.
</td>
</tr>
<tr>
<td width="26%">
(?&lt;name&gt;X)
</td>
<td width="74%">
Groups X, and captures submatch, assigning name as the name of the
submatch.  Name must consist of a sequence of word-constituent
characters.
</td>
</tr>
<tr>
<td width="26%">
(?:X)
</td>
<td width="74%">
Groups X, but does no captures.
</td>
</tr>
<tr>
<td width="26%">
(?imsx-imsx:X)
</td>
<td width="74%">
Groups X, with turning on/off the given flags.
</td>
</tr>
<tr>
<td width="26%">
(?imsx-imsx)
</td>
<td width="74%">
Successfully matches nothing, and changes the given flags within the
current group.
</td>
</tr>
<tr>
<td width="26%">
(?=X)
</td>
<td width="74%">
Zero-width positive look-ahead
</td>
</tr>
<tr>
<td width="26%">
(?!X)
</td>
<td width="74%">
Zero-width negative look-ahead
</td>
</tr>
<tr>
<td width="26%">
(?&lt;=X)
</td>
<td width="74%">
Zero-width positive look-behind
</td>
</tr>
<tr>
<td width="26%">
(?&lt;!X)
</td>
<td width="74%">
Zero-width negative look-behind
</td>
</tr>
<tr>
<td width="26%">
(?&gt;X)
</td>
<td width="74%">
Matches X, and never backtrack. (also known as "standalone" group)
</td>
</tr>
<tr>
<td width="26%">
(?(n)Y)
</td>
<td width="74%">
If submatch N has a value, match Y.
</td>
</tr>
<tr>
<td width="26%">
(?(n)Y|Z)
</td>
<td width="74%">
If submatch X has a value, match Y; otherwise match Z.
</td>
</tr>
<tr>
<td width="26%">
(?(?=X)Y|Z)<br>
(?(?!X)Y|Z)<br>
(?(?&lt;=X)Y|Z)<br>
(?(?&lt;!X)Y|Z)
</td>
<td width="74%">
Try the look-ahead or look-behind assertion of X, and if succeeds,
match Y; otherwise match Z. '|Z' part can be omitted.
</td>
</tr>
</table>

<h3 id="26">
Back reference
</h3>

<table border="1" width="95%">
<tr>
<td width="26%">
<b>Construct</b>
</td>
<td width="74%">
<b>Matches</b>
</td>
</tr>
<tr>
<td width="26%">
\n
</td>
<td width="74%">
Matches the n-th submatch (n&gt;=1).  If n-th submatch doesn't have a
value, it doesn't match anything (match just fails). If n is more than
one digit, it becomes a back reference only if there are that many
capturing groups in the regular expressions; otherwise, it is
interpreted as an octal character notation if possible.
</td>
</tr>
<tr>
<td width="26%">
\k&lt;name&gt;
</td>
<td width="74%">
Matches the submatch with name.  If there are more than one submatches
that has the name, this tries to match the one that has the biggest
number first, and if it fails, the smaller numbered submatches are
tried.
</td>
</tr>
</table>




<hr><h2 id="27"><a name="regexp-new-capturing-2">2.3 Capturing and back reference</a></h2>

<p id="28">
Capturing submatches <code>(X)</code> and
<code>(?&lt;name&gt;X)</code> are numbered in the order of its
opening parenthesis from left to right. Named submatch is counted the
same as unnamed submatch, and can be back-referenced by both name and
number.
</p>
<p id="29">
When the input string matches X, the portion of the input string is saved.
It can be referenced within a regular expression, by the back reference
construct, or can be returned to the user program as a submatch.
</p>
<p id="30">
If the capturing construct matches more than once, it saves the last
match.
</p>



<hr><h2 id="31"><a name="regexp-tree-2">2.4 Regexp trees</a></h2>

<p id="32">
Most functions that accept a regexp string such as <a href="operators/excl/match-re.htm"><b>match-re</b></a> and <a href="operators/excl/compile-re.htm"><b>compile-re</b></a> also accept a regexp tree. A regexp
tree is an s-expression with the syntax described below. The syntax
was defined by CL-PPCRE and is intended to be compatible with it. This
documentation was taken from the CL-PPCRE documentation, available as
<a href="http://www.weitz.de/cl-ppcre/">http://www.weitz.de/cl-ppcre/</a>.
</p>
<p id="33">
Programmers are usually most familiar with regexp string syntax, and
it suffices for many normal regexp applications.  However, string
syntax does not scale very well -- complex regexps are hard to write
and even harder to parse. The frequent need for backslach escapes is
a further complication. In such cases, programmers may find tree
syntax easiler to code in Lisp source code editors with their autmatic
indentation and parentheses matching.
</p>
<p id="34">
Further, in any application that generates regular expressions on the
fly will undoubtedly find it easier to generate s-expr tress than
trying to perform and extra level of encoding into string syntax, only
to force the regexp system immediately to parse the string back.
</p>
<p id="35">
Tree syntax is as follows:
</p>
<ul>
<li id="36">
Every string and character is a parse tree and is treated literally as
a part of the regular expression, i.e. parentheses, brackets,
asterisks and such aren't special.
</li>
<li id="37">
The symbol <code>:void</code> is equivalent to the empty string.
</li>
<li id="38">
The symbol <code>:everything</code> is equivalent to Perl's dot,
i.e it matches everything (except maybe a newline character depending
on the mode).
</li>
<li id="39">
The symbols <code>:word-boundary</code> and
<code>:non-word-boundary</code> are equivalent to Perl's "\b"
and "\B".
</li>
<li id="40">
The symbols <code>:digit-class</code>,
<code>:non-digit-class</code>,
<code>:word-char-class</code>,
<code>:non-word-char-class</code>,
<code>:whitespace-char-class</code>, and
<i>:non-whitespace-char-class</i> are equivalent to
Perl's special character classes "\d", "\D", "\w", "\W", "\s", and
"\S" respectively.
</li>
<li id="41">
The symbols <code>:start-anchor</code>,
<code>:end-anchor</code>,
<code>:modeless-start-anchor</code>,
<code>:modeless-end-anchor</code>, and
<code>:modeless-end-anchor-no-newline</code> are equivalent to
Perl's "^", "$", "\A", "\Z", and "\z" respectively.
</li>
<li id="42">
The symbols <code>:case-insensitive-p</code>,
<code>:case-sensitive-p</code>,
<code>:multi-line-mode-p</code>,
<code>:not-multi-line-mode-p</code>,
<code>:single-line-mode-p</code>, and
<code>:not-single-line-mode-p</code> are equivalent to Perl's
embedded modifiers "(?i)", "(?-i)", "(?m)", "(?-m)", "(?s)", and
"(?-s)". As usual, changes applied to modes are kept local to the
innermost enclosing grouping or clustering construct.
</li>
<li id="43">
<code>(:flags {&lt;modifier&gt;}*)</code> where &lt;modifier&gt;
is one of the modifier symbols from above is used to group modifier
symbols. The modifiers are applied from left to right. (This construct
is obviously redundant. It is only there because it's used by the
parser.)
</li>
<li id="44">
<code>(:sequence {&lt;parse-tree&gt;}*)</code> means a sequence
of parse trees, i.e. the parse trees must match one after
another. Example: <code>(:sequence #\f #\o #\o)</code> is
equivalent to the parse tree "foo".
</li>
<li id="45">
<code>(:group {&lt;parse-tree&gt;}*)</code> is like
<code>:sequence</code> but changes applied to modifier flags
(see above) are kept local to the parse trees enclosed by this
construct. Think of it as the S-expression variant of Perl's
&quot;(?:&lt;pattern&gt;)&quot; construct.
</li>
<li id="46">
<code>(:alternation {&lt;parse-tree&gt;}*)</code> means an
alternation of parse trees, i.e. one of the parse trees must
match. Example: <code>(:alternation #\b #\a #\z)</code> is
equivalent to the Perl regex string "b|a|z".
</li>
<li id="47">
<code>(:branch &lt;test&gt; &lt;parse-tree&gt;)</code> is for
conditional regular expressions with the syntax
<pre id="48">
  (?(condition)yes-pattern)
  (?(condition)yes-pattern|no-pattern)
</pre>
<p id="49">
&lt;test&gt; is either a number which stands for a register or a parse
tree which is a look-ahead or look-behind assertion. If the parse-tree
following the condition is an alteration, it must enclose exactly one
or two parse trees where the second one (if present) will be treated
as the &quot;no-pattern&quot; - in all other cases &lt;parse-tree&gt; will be
treated as the &quot;yes-pattern&quot;, executed if the condition matched.  If
the condition refers to a register, the condition succeeds if that
register already succeeded in matching somehing.
</p>
</li>
<li id="50">
<code>(:positive-lookahead|:negative-lookahead|:positive-lookbehind|:negative-lookbehind
&lt;parse-tree&gt;)</code> -- the meaning should be pretty obvious.
</li>
<li id="51">
<code>(:greedy-repetition|:non-greedy-repetition
&lt;min&gt; &lt;max&gt; &lt;parse-tree&gt;)</code> where &lt;min&gt; is a
non-negative integer and &lt;max&gt; is either a non-negative integer
not smaller than &lt;min&gt; or <code>nil</code> will
result in a regular expression which tries to match &lt;parse-tree&gt;
at least &lt;min&gt; times and at most &lt;max&gt; times (or as often
as possible if &lt;max&gt; is <code>nil</code>). So, e.g.,
<code>(:non-greedy-repetition 0 1 "ab")</code> is equivalent to
the Perl regex string "(?:ab)??".
</li>
<li id="52">
<code>(:standalone &lt;parse-tree&gt;)</code> is an
"independent" subexpression, i.e. <code>(:standalone
"bar")</code> is equivalent to the Perl regex string &quot;(?&gt;bar)&quot;.
</li>
<li id="53">
<code>(:register &lt;parse-tree&gt;)</code> is a capturing
register group. As usual, registers are counted from left to right
beginning with 1.
</li>
<li id="54">
<code>(:back-reference &lt;number&gt;)</code> where
&lt;number&gt; is a positive integer is a back-reference to a register
group.  <code>(:char-class|:inverted-char-class
{&lt;item&gt;}*)</code> where &lt;item&gt; is either a character, a
character range, or a symbol for a special character class (see above)
will be translated into a (one character wide) character class. A
character range looks like <code>(:range &lt;char1&gt;
&lt;char2&gt;)</code> where &lt;char1&gt; and &lt;char2&gt; are
characters such that <code>(char&lt;= &lt;char1&gt;
&lt;char2&gt;)</code> is true. Example:
<code>(:inverted-char-class #\a (:range #\d #\g)
:digit-class)</code> is equivalent to the Perl regex string
"[^aD-G\d]".
</li>
</ul>
<p id="55">
There is a small region of ambiguity between string syntax and tree
syntax.  Although a single string is a valid parse tree, it will be
interpreted as a Perl regexp strings when given to compile-re and
friends. To circumvent this you can use the equivalent parse tree
(:GROUP &lt;string&gt;).  See also <a href="operators/excl/quote-re.htm"><b>quote-re</b></a>.
</p>
<p id="56">
If you want to find out how parse trees are related to Perl regex
strings you should play around with <a href="operators/excl/parse-re.htm"><b>parse-re</b></a> - a function which converts a Perl
regexp strings to a parse tree.
</p>



<hr><h2 id="57"><a name="regexp-new-api-2">2.5 User-level API in the regexp2 module</a></h2>

<p id="58">
There are seven functions (listed first) and three macros in the API:
</p>
<ul>
<li id="59">
<a href="operators/excl/compile-re.htm"><b>compile-re</b></a>
</li>
<li id="60">
<a href="operators/excl/match-re.htm"><b>match-re</b></a>
</li>
<li id="61">
<a href="operators/excl/quote-re.htm"><b>quote-re</b></a>
</li>
<li id="62">
<a href="operators/excl/parse-re.htm"><b>parse-re</b></a>
</li>
<li id="63">
<a href="operators/excl/replace-re.htm"><b>replace-re</b></a>
</li>
<li id="64">
<a href="operators/excl/split-re.htm"><b>split-re</b></a>
</li>
<li id="65">
<a href="operators/excl/re-submatch.htm"><b>re-submatch</b></a>
</li>
<li id="66">
<a href="operators/excl/re-lambda.htm"><b>re-lambda</b></a>
</li>
<li id="67">
<a href="operators/excl/re-let.htm"><b>re-let</b></a>
</li>
<li id="68">
<a href="operators/excl/re-case.htm"><b>re-case</b></a>
</li>
</ul>




<hr><h2 id="69"><a name="regexp-new-compatibility-2">2.6 Compatibility issues in the regexp2 module</a></h2>

<ol>
<li id="70">
Traditionally, '{' and '}' characters that do not consist of a valid
repetition syntax are taken literally.  That is, a regular expression
"x{1,3,4}" matches the string "x{1,3,4}", and a regular expression
"a{" matches the string "a{".  Currently, these regular expressions
raise a syntax error in our regexp library.
</li>
<li id="71">
Embedded Perl expressions like (?{ $a = 3+$b }) are not supported
because Lisp cannot execute Perl code.
</li>
<li id="72">
The following escape sequences are not supported.  Precisely speaking,
these are actually a feature of Perl's literal string syntax, and not
a part of regular expression.
<pre id="73">
  \N{name}   named char
  \lx        lowercase x
  \ux        uppercase x
  \Lx..\E    lowercase x..
  \Ux..\E    uppercase x..
  \Qx..\E    quote non-alphanumeric chars in x.
</pre>
</li>
<li id="74">
The character properties (\p{property} and \P{property}), and extended
unicode combining sequence \X, aren't supported.
</li>
<li id="75">
POSIX character class syntax [:class:] within character classes is not
supported.
</li>
<li id="76">
<b>Inconsistent capturing and alternation order</b>. This is due to
Perl's bug. Only appears in the mixture of very tricky situation and
optimization. See <a href="http://www.weitz.de/cl-ppcre/">http://www.weitz.de/cl-ppcre/</a>
for the details.
</li>
</ol>



<hr><h2 id="77"><a name="regexp-new-performace-2">2.7 Performance notes in the regexp2 module</a></h2>

<p id="78">
Theoretically ACL's regexp library uses the same mechanism that Perl
and CL-PPCRE are using: Nondeterministic finite automaton (NFA).  When
there are multiple possibilies of matching, it "remembers" the current
state and tries each possibility one at a time.  If a trial fails, it
backs up the last saved state and tries the next possibility; that is
called a "backtrack". It is possible to compose a very short regular
expression that does a huge number of backtracks; if you have nested
repetitions and alternations, the number of required backtracks grows
exponentially.
</p>
<p id="79">
The regexp optimizer tries to reduce the number of backtracks, but it is
not always possible.  Here are some tips to improve the performance
of the matcher.
</p>
<ul>
<li id="80">
If applicable, use of standalone group <code>(?&gt;X)</code> in
the inner loop. It effectively turns the nested repetition into
unnested repetition from the viewpoint of NFA.  Lots of optimizations
can be done for unnested repetition, but not much can be done for
a nested one.
</li>
<li id="81">
If the input string is very long, it is a good idea to split it up by
non-backtracking regexp first, then apply more compilicated regexp to
the small chunks.  Non-backtracking NFA runs in constant space and
linear time to the input length.  Single-nested backtracking NFA runs
in linear space and quadratic time to the input length.
<p id="82">
Note that an unnested greedy repetition followed by a character or a
character set that are exclusive to the beginning of the repetition
becomes a non-backtracking regexp; for example, the regular expression
<code>(\w+)\s+</code> runs without backtracking.
</p>
</li>
</ul>




<hr><hr><h2 id="83"><a name="regexp-old-1">3.0 The older regexp API</a></h2>

<p id="84">
A regular expression is a pattern that matches one or more
strings. Technically, the patterns we support go beyond regular
expressions, however we'll continue to call them regular
expressions. Allegro CL provides regular expression (regexp)
functionality as described in this document.
</p>

<p id="85">
In a regular expression string, characters are either <i>normal</i>
or <i>special</i>.  A normal character stands for itself, a special
character has a meaning described below.
</p>

<p id="86">
There are two contexts in a regular expression: characters within a
[...] expression and those elsewhere.
</p>

<p id="87">
Special characters outside a [...] are: <code>* . [ ] \ + ^
$</code> (asterisk, period, left bracket, right bracket, backslash,
plus sign, circumflex accent, and dollar sign).
These characters can be made normal characters by preceding them
with a backslash. Some of these characters are only special in
certain places in the string (see below for the details).
</p>


<p id="88">
Special characters within a [...] are: <code>^ ]</code>.
These characters can only be made non-special by placing them in
a certain position in the [...] expression (more details
below). Note that backslash is not a special character in this
context.
</p>

<p id="89">
There are certain characters that when preceded by a backslash outside
of a [...]  expression turn into special characters. Those characters
are: <code>( ) | w W b B 0 1 2 3 4 5 6 7 8 9</code>.
</p>

<p id="90">
A regular expression is defined as:
</p>

<table border="1" cellpadding="2" width="95%">
  <tr>
    <td valign="top"><i>a</i></td>
    <td>Where <i>a</i> is any non-special character, matches itself.</td>
  </tr>
  <tr>
    <td valign="top"><i>xy</i></td>
    <td>Where <i>x</i> and <i>y</i> are regular expressions, 
    matches the concatenation of the
    regular expressions.</td>
  </tr>
  <tr>
    <td valign="top"><i>m*</i></td>
    <td>A single character regular expression followed by * 
    matches zero or more occurrences
    of <i>m</i>. If there is a choice, it always matches 
    the longest sequence of <i>m</i>'s.</td>
  </tr>
  <tr>
    <td valign="top"><i>m+</i></td>
    <td>A single character expression followed by + matches one 
    or more occurrences of <i>m</i>.
    If there is a choice, it always matches the longest 
    sequence of <i>m</i>'s.</td>
  </tr>
  <tr>
    <td valign="top">.</td>
    <td>A period matches any character (except newline--see notes 
    on the <a href="operators/excl/match-regexp.htm"><b>match-regexp</b></a> 
    function).</td>
  </tr>
  <tr>
    <td valign="top">^</td>
    <td>If this is the first character of the regular 
    expression string it forces the match to
    start at the beginning of the to-be-matched string. 
    If this character appears after the
    beginning of the string it stands for itself.</td>
  </tr>
  <tr>
    <td valign="top">$</td>
    <td>If this is the last character of the regular expression 
    string it forces the match to
    end at the end of the to-be-matched string. If this 
    character appears before the end of
    the regular expression string, it stands for itself.</td>
  </tr>
  <tr>
    <td valign="top">[..]</td>
    <td>This matches exactly one character from the set of 
    characters denoted by the pattern
    inside the brackets. This pattern has a different form 
    than elsewhere in the regular
    expression: <code>[abcs-y3-8]</code> matches 
    either <code>a</code>, <code>b</code> 
    or <code>c</code>,
    or <code>s</code> through <code>y</code>, 
    or <code>3</code> through <code>8</code>. You can
    invert the set using the caret as the first character. 
    <code>[^a-z]</code> matches any
    character not in the range <code>a</code> through 
    <code>z</code>. In order to include the
    right bracket in the set it has to be listed first 
    (or after the caret): <code>[]ab]</code>
    matches <code>a</code>, <code>b</code> 
    or the right bracket. <code>[^]ab]</code> matches
    any character except <code>a</code>, 
    <code>b</code> or the right bracket. In order to
    match a hyphen it has to be first or last: 
    <code>[b-]</code> matches <code>b</code> or a
    hyphen. In order to match a caret it has to be 
    somewhere other than the first character. <code>[b^]</code>
    matches <code>b</code> or a caret.</td>
  </tr>
  <tr>
    <td valign="top">\(<em>x</em>\)</td>
    <td>This grouping syntax matches whatever <em>x</em> 
    matches, and at the same time
    remembers what <em>x</em> matches. There can be up to 
    9 groups defined in a regular
    expression string. Each group is given a number from 1 
    to 9 based on the order in which
    they appear in the pattern string. </td>
  </tr>
  <tr>
    <td valign="top"><em>x</em>\|<em>y</em></td>
    <td>This tries to match <em>x</em>, and if that fails 
    it tries to match <em>y</em>. To
    control what constitutes <em>x</em> and <em>y</em> 
    you can use the <code>\( \)</code>
    grouping. For example, <code>abc\|def</code>
    means <code>abc</code> or <code>def</code>
    whereas <code>a\(bc\|de\)f</code> means 
    <code>a</code> followed by <code>bc</code> 
    or <code>de</code>
    followed by <code>f</code>.</td>
  </tr>
  <tr>
    <td valign="top">\<em>n</em></td>
    <td>If <em>n</em> is 1 through 9 then this stands for 
    the string matched by group 1
    through 9. If there is no string assigned to group 
    <em>n</em> then this is match failure.
    There is no group 0 so the form \0 is illegal 
    and an error is signaled when the regular
    expression is parsed.</td>
  </tr>
  <tr>
    <td valign="top">\w</td>
    <td>Matches a word character. It is equivalent 
    to <code>[a-zA-Z0-9]</code>.</td>
  </tr>
  <tr>
    <td valign="top">\W</td>
    <td>Matches anything but a word character. It is 
    equivalent to <code>[^a-zA-Z0-9]</code>.</td>
  </tr>
  <tr>
    <td valign="top">\b</td>
    <td>Matches a blank character (one of space, form feed, 
    tab and newline).</td>
  </tr>
  <tr>
    <td valign="top">\B</td>
    <td>matches anything but a blank character (one of space, 
    form feed, tab and newline).</td>
  </tr>
  <tr>
    <td valign="top">\<i>a</i></td>
    <td>For any character <i>a</i> not mentioned above stands for 
    a itself. It is unwise to
    put in extra backslashes since while \x may stand for just x 
    today, in the future it may
    have a different meaning.</td>
  </tr>
</table>

<p id="91">
When typing a regular expression in Lisp source code keep in mind that
in order to represent a backslash in a string constant you need two
backslashes. The Lisp reader reads "foo\+" as
"foo+", when what you probably wanted was "foo\\+"
(where you are putting a backslash in front of the + to remove its
special meaning so you could match the string <em>foo+</em>.)
</p>

<p id="92">
The + and * characters must follow a single character regular
expression. They cannot follow a group expression, even if that group
matches just one character. In other words <code>\(a\)*</code> is not
legal. <code>[a]*</code> is legal since the <code>[..]</code>
expression always matches one character.
</p>

<h3 id="93">Compatibility with other regular expression parsers
</h3>
<p id="94">
Various operating systems and other utilities provide regular expression
parsers. Here are some notes on some of them:
</p>
<ul>
<li id="95">
The UNIX version (on Solaris) supports <code>x\{m,n\}</code>
meaning between <code>m</code> and <code>n</code>
occurrences of <code>x</code>. It also supports
<code>\&lt;</code> and <code>\&gt;</code> as matching word
beginnings and word endings, where a word is a C identifier. The UNIX
version does not support the <code>+</code> special character
(possibly since you can get it with <code>\{1,\}</code>).
</li>
<li id="96">
The Linux version supports <code>x?</code> meaning 0 or 1
occurrence of x. We can get that with <code>\(x\|\)</code>.
</li>
<li id="97">
The GNU Emacs regular expression parser supports a lot of
additional features.
</li>
</ul>

<h3 id="98">
Allegro CL functionality</h3>

<p id="99">Several functions are supported in this facility. Each is
documented on its own page. The functions are
</p>
<ul>
<li id="100">
<a href="operators/excl/compile-regexp.htm"><b>compile-regexp</b></a>
</li>
<li id="101">
<a href="operators/excl/match-regexp.htm"><b>match-regexp</b></a>
</li>
<li id="102">
<a href="operators/excl/replace-regexp.htm"><b>replace-regexp</b></a>
</li>
<li id="103">
<a href="operators/excl/split-regexp.htm"><b>split-regexp</b></a>
</li>
</ul>

<p id="104">
We repeat most of the information for <a href="operators/excl/compile-regexp.htm"><b>compile-regexp</b></a> and <a href="operators/excl/match-regexp.htm"><b>match-regexp</b></a> (the two more important
functions) here for reading convenience.
</p>

<hr><h3 id="105"><a name="compile-regexp-op-bookmarkxx"></a>compile-regexp</h3><h3 id="106">Function</h3><h4 id="107">Package: excl</h4>

<p id="108"><b>Arguments: </b><i>regexp</i></p>

<p id="109">Compiles the string <i>regexp</i> into a regular
expression object and returns that object. If there are syntax errors
in the string, an error will be signaled.
</p>

<hr>

<hr><h3 id="110"><a name="match-regexp-op-bookmarkxx"></a>match-regexp</h3><h3 id="111">Function</h3><h4 id="112">Package: excl</h4>


<p id="113"><b>Arguments: </b><i>
regexp match-string
</i>&amp;key  (<i>newlines-special</i> t)<i> case-fold shortest</i> (<i>return</i> :string) (<i>start</i> 0) (<i>end</i> (length match-string))<i>
</i></p>

<p id="114">
The <em><code>regexp</code></em> argument is a regular
expression object (the result of <code>regexp-compile</code>) or
it is a string (in which case it will be compiled into a regular
expression object). The <code>match-string</code> is a string to
match against the regular expression. The function will attempt to
match the regular expression against the
<code>match-string</code> starting at the first character of the
<code>match-string</code>, and if that fails it will look inside
the <code>match-string</code> for a match (unless the regular
expression begins with a caret).
</p>

<p id="115">The keyword arguments are:</p>

<table border="0" width="95%">
<tr>
<td valign="top">
<code>:newlines-special</code>
</td>
<td>
If true then a newline will not match the . [i.e. the <i>dot</i>]
regular expression.  This is useful to prevent multiline matches.
</td>
</tr>
<tr>
    <td valign="top"><code>:case-fold</code></td>
    <td>If true then the <code>match-string</code> 
    is effectively mapped to
    lower case before doing the match. Thus lower case 
    characters in the regular expression
    match either case and upper case characters match only 
    upper case characters.</td>
  </tr>
  <tr>
    <td valign="top"><code>:return</code></td>
    <td><p id="116">A failed match returns
    <code>nil</code>. If the
    value of <i>return</i> is <code>:string</code> then 
    a
    successful match returns multiple values. The first 
    value is <code>t</code>.
    The second value is the substring of the 
    <code>match-string</code> that
    matched the regular expression. The third value 
    (if any) is the substring that matched
    group 1. The fourth value is the substring that 
    matched group 2. And so on. If you use the
    \| form, then some groups may have no associated 
    match in which case <code>nil</code> 
    will be returned as that value. In highly nested \| forms, a
    group may return a match string when in the final match 
    that group had no match.</p>
    <p id="117">If the
    value of <i>return</i> is 
    <code>:index</code> then it is just like 
    <code>:string</code> except that instead of the 
    strings being returned, a
    cons is returned giving the start and 
    end indices in the original <code>match-string</code>
    of the match. The end index is one greater than the 
    last character in the substring.</p>
    <p id="118">If the value of <i>return</i> is 
    <code>nil</code> then the one value 
    <code>t</code> is returned when the match succeeds.</p></td>
  </tr>
  <tr>
    <td valign="top"><code>:start</code></td>
    <td>The first character in the <code>match-string</code> to match
    against.</td>
  </tr>
  <tr>
    <td valign="top"><code>:end</code></td>
    <td>One past the last character in the <code>match-string</code> to
    match against.</td>
  </tr>
  <tr>
    <td vAlign="top"><i>shortest</i></td>
    <td>This makes <a href="operators/excl/match-regexp.htm"><b>match-regexp</b></a> 
    return the shortest rather than the longest
    match. One motivation for this is parsing html. Suppose you 
    want to search for the next
    item in italics, which in html looks like 
    <code>
    &lt;i&gt;foo&lt;/i&gt;
    </code>. Suppose your <i>string</i> is
    <code>&quot;&lt;i&gt;foo&lt;/i&gt; and &lt;i&gt;bar&lt;/i&gt;&quot;</code>.
    The following example shows the difference:
    <pre id="119">
    user(10): (match-regexp &quot;&lt;i&gt;.*&lt;/i&gt;&quot; string)
    t
    &quot;&lt;i&gt;foo&lt;/i&gt; and  &lt;i&gt;bar&lt;/i&gt;
    user(11): (match-regexp &quot;&lt;i&gt;.*&lt;/i&gt;&quot; string
                        :shortest t)
    t
    &quot;&lt;i&gt;foo&lt;/i&gt;&quot;
     </pre></td>
  </tr>
</table>

<p id="120"><strong>Compilation note</strong>: there is a compiler macro
defined for <code>match-regexp</code> that will handle in a
special way <code>match-regexp</code> calls where the first
argument is a constant string. That is, this form
<code>(match-regexp "foo" x)</code> will compile to
code that will arrange to call <code>compile-regexp</code> on
the string when the code is fasled in. Since the cost of
<code>compile-regexp</code> is high, this saves a lot of
time. </p>

<hr>

</body><hr><p id="2"><small>Copyright (c) 1998-2010, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br><small>Documentation for Allegro CL version 8.2. This page was not revised from the 8.1 page.</small><br>
<small>Created 2010.1.21.</small>
<br></p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faqs/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 8.2</b><br><small><a href="introduction.htm#updates-s">Unrevised from 8.1 to 8.2.</a></small><br><a href="http://www.franz.com/support/documentation/8.1/doc/regexp.htm">8.1 version</a></td></tr></table></html>