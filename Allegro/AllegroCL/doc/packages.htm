<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"> <title>Packages</title></head><link rel="stylesheet" href="acldoc-styles.css" type="text/css"><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faqs/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 8.2</b><br><small><a href="introduction.htm#updates-s">Unrevised from 8.1 to 8.2.</a></small><br><a href="http://www.franz.com/support/documentation/8.1/doc/packages.htm">8.1 version</a></td></tr></table><h1 id="2">Packages</h1><p id="3">This document contains the following sections:</p><a href="#packages-intro-1">1.0 Packages introduction</a><br><a href="#hier-packs-1">2.0 Hierarchical Packages</a><br>&nbsp;&nbsp;&nbsp;<a href="#relative-2">2.1 Relative package names</a><br>&nbsp;&nbsp;&nbsp;<a href="#relpack-ansi-compat-2">2.2 Compatibility with ANSI Common Lisp</a><br>&nbsp;&nbsp;&nbsp;<a href="#pack-prefixes-2">2.3 Package prefixes reserved by Allegro CL</a><br>&nbsp;&nbsp;&nbsp;<a href="#new-cl-funs-2">2.4 New Common Lisp functions</a><br>&nbsp;&nbsp;&nbsp;<a href="#hier-pack-implementation-2">2.5 The implementation of Hierarchical Packages</a><br>&nbsp;&nbsp;&nbsp;<a href="#hier-pack-tests-2">2.6 Testing the Hierarchical Packages Implementation</a><br><a href="#packages-in-acl-1">3.0 Packages in Allegro CL</a><br><a href="#notes-on-specific-packages-1">4.0 Notes on specific packages</a><br><a href="#package-nicknames-1">5.0 Package nicknames</a><br><a href="#package-locking-1">6.0 Package locking and package definition locking</a><br>&nbsp;&nbsp;&nbsp;<a href="#package-locking-2">6.1 Package locking</a><br>&nbsp;&nbsp;&nbsp;<a href="#package-definition-locking-2">6.2 Package definition locking</a><br>&nbsp;&nbsp;&nbsp;<a href="#implementation-packages-2">6.3 Implementation packages</a><br>&nbsp;&nbsp;&nbsp;<a href="#package-locked-errors-2">6.4 Package locked errors</a><br>&nbsp;&nbsp;&nbsp;<a href="#circumventing-package-locked-errors-2">6.5 Locally circumventing package locked errors</a><br>&nbsp;&nbsp;&nbsp;<a href="#default-locked-packages-2">6.6 The packages locked by default</a><br>&nbsp;&nbsp;&nbsp;<a href="#package-locking-justification-2">6.7 Justification for package locking</a><br><hr><hr><h2 id="4"><a name="packages-intro-1">1.0 Packages introduction</a></h2>

<p id="5">Common Lisp allows the use of packages to keep different parts of
an application separate, permitting multiple use of symbol names and
independent development of different parts of a large program. As
delivered, Allegro CL comprises several packages, and users should be
aware of which packages are available, which should be used by the
user, and which should, in general, be avoided.</p>

<p id="6">
Starting in release 6.0, Allegro CL has implemented a hierarchical
package naming scheme, allowing the specification of a hierarchy of
packages, and the use of relative package specifiers, analogous to
relative pathnames. While this facility is an extension to the ANSI spec,
programs that do not use hierarchical naming are unaffected
(except for the handling of rather unusual, erroneous code). Programs
that use it, however, may have to be modified to be portable.
See <a href="#hier-packs-1">Section 2.0 Hierarchical Packages</a>.
</p>

<p id="7">Lisp permits already-defined functions to be redefined
dynamically. However, redefining system-defined functions (either from
the Common Lisp standard in the common-lisp package or from the
Allegro CL implementation, in packages such as excl, system, etc.) is
almost always a bad idea. Allegro CL implements a package-locking
system which protects symbols in reserved packages from new or changed
function definitions. See the discussions under the heading 
<a href="#package-locking-1">Section 6.0 Package locking and package definition locking</a> below.</p>

<hr><hr><h2 id="8"><a name="hier-packs-1">2.0 Hierarchical Packages</a></h2>

<p id="9">
The Common Lisp package system, designed and standardized some
years ago, is not hierarchical. Since Common Lisp was standardized,
other languages, including Java and Perl, have evolved namespaces
which are hierarchical. This document describes a hierarchical
package naming scheme for Common Lisp. We hope that CL
implementations other than just Allegro CL will include this
facility. All the source code used in Allegro CL to implement the
facility is included below.
</p>

<p id="10">
The goals of hierarchical packages in Common Lisp are: 
</p>

<ul>
  <li id="11">Reduce collisions with user-defined packages: it is a well-known
    problem that package names used by the Lisp implementation and
    those defined by users can easily conflict. The intent of
    hierarchical packages is to reduce such conflicts to a
    minimum.</li> 
    <li id="12">Improve modularity: the current organization of
    packages in various implementations has grown over the years and
    appears somewhat random. Organizing future packages into a
    hierarchy will help make the intention of the implementation more
    clear.</li> 
    <li id="13">Foster growth in Common Lisp programs, or modules,
    available to the CL community: the Perl and Java communities are
    able to contribute code to repositories, with minimal fear of
    collision, because of the hierarchical nature of the name spaces
    used by the contributed code. We want the Lisp community to
    benefit from shared modules in the same way.</li>
</ul>

<p id="14">
In a nutshell, a dot (.) is used to separate levels in package
names, and a leading dot signifies a relative package
name. Absolute package names require no modifications to the
underlying CL implementation. Relative package names require small and
simple modifications, for which the source code is given below.
</p>

<p id="15">
The choice of dot follows Java. Perl, another language with
hierarchical packages, uses a colon (:) as a delimiter, but the
colon is already reserved in Common Lisp.
</p>

<p id="16">
Franz intends to extend the hierarchy below to currently existing
packages. The Allegro CL test harness (see
<a href="test-harness.htm">test-harness.htm</a>) is in the <i>util.test</i>
package.
</p>

<hr><h2 id="17"><a name="relative-2">2.1 Relative package names</a></h2>

<p id="18">Relative package names are needed for the same reason as relative
pathnames, for brevity and to reduce the brittleness of absolute
names.</p>

<p id="19">A relative package name is one that begins with one or more
dots. A single dot means the current package, two dots mean the
parent of the current package, and so on.</p>

<p id="20">
Here are some examples, assuming that packages named mypack,
<code>mypack.foo</code>, <code>mypack.foo.bar</code>,
<code>mypack.foo.baz</code>, <code>mypack.bar</code>,
<code>mypack.bar.baz</code>, <code>foo</code>, and
<code>foo.bar</code>, have all been created:
</p>

<table border="2" cellpadding="3" cellspacing="1" width="95%">
  <tr>
    <th width="24%" align="left">relative name</th>
    <th width="36%" align="left">current package</th>
    <th width="116%" align="left">absolute name of referenced package</th>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>foo</code></td>
    <td width="36%"><i>any</i></td>
    <td width="116%"><code>foo</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>foo.bar</code></td>
    <td width="36%"><i>any</i></td>
    <td width="116%"><code>foo.bar</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>.foo</code></td>
    <td width="36%"><code>mypack</code></td>
    <td width="116%"><code>mypack.foo</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>.foo.bar</code></td>
    <td width="36%"><code>mypack</code></td>
    <td width="116%"><code>mypack.foo.bar</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>..foo</code></td>
    <td width="36%"><code>mypack.bar</code></td>
    <td width="116%"><code>mypack.foo</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>..foo.baz</code></td>
    <td width="36%"><code>mypack.bar</code></td>
    <td width="116%"><code>mypack.foo.baz</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>...foo</code></td>
    <td width="36%"><code>mypack.bar.baz</code></td>
    <td width="116%"><code>mypack.foo</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>.</code></td>
    <td width="36%"><code>mypack.bar.baz</code></td>
    <td width="116%"><code>mypack.bar.baz</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>..</code></td>
    <td width="36%"><code>mypack.bar.baz</code></td>
    <td width="116%"><code>mypack.bar</code></td>
  </tr>
  <tr>
    <td width="24%" valign="top"><code>...</code></td>
    <td width="36%"><code>mypack.bar.baz</code></td>
    <td width="116%"><code>mypack</code></td>
  </tr>
</table>

<p id="21"><strong>Note 1</strong>: To repeat what we said just before the
table, all packages in the hierarchy must exist. </p>

<p id="22"><strong>Note 2: WARNING ABOUT NICKNAMES!</strong> Unless you
provide nicknames for your hierarchical packages (and we recommend
against doing so because the number gets quite large), you can only
use the names supplied. You cannot mix in nicknames or alternate
names. <code>cl-user</code> (and <code>user</code>) are
nicknames of the <code>common-lisp-user</code> package. Consider
the following:</p>

<pre id="23">(defpackage :cl-user.foo)</pre>

<p id="24">When the current package (the value of
<code>*package*</code>) is <code>common-lisp-user</code>,
you might expect <code>.foo</code> to refer to
<code>cl-user.foo</code>, but it does not. It refers to the
non-existent package <code>common-lisp-user.foo</code>. Note
that the purpose of nicknames is to provide shorter names in place of
the longer names designed to be fully descriptive. The hope is that
hierarchical packages makes longer names unnecessary and thus makes
nicknames unnecessary.
</p>

<p id="25">
<strong>Note 3</strong>: multiple dots can only appear at the
beginning. <code>foo.bar..baz</code> does not mean
<code>foo.baz</code> -- it is invalid. (Of course, it is
perfectly legal to name a package <code>foo.bar..baz</code> but
<a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a> will not
process such a name to find <code>foo.baz</code> in the package
hierarchy.)
</p>



<hr><h2 id="26"><a name="relpack-ansi-compat-2">2.2 Compatibility with ANSI Common Lisp</a></h2>

<p id="27">
The implementation of hierarchical packages modifies <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a> and provides certain auxiliary
functions, <a href="operators/excl/package-parent.htm"><b>package-parent</b></a>,
<a href="operators/excl/package-children.htm"><b>package-children</b></a>, and
<a href="operators/excl/relative-package-name-to-package.htm"><b>relative-package-name-to-package</b></a>, as described
in this section. (<a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a>
itself requires no modification.)
</p>

<p id="28">While the changes to <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a> are small and described below, it
is an important consideration for authors who would like their
programs to run on a variety of implementations that using
hierarchical packages will work in an implementation without the
modifications discussed in this document. We show why not after
describing the changes to <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a>.</p>

<p id="29">Absolute hierarchical package names require no changes in the
underlying CL implementation.</p>

<h3 id="30">Changes to cl:find-package:</h3>

<p id="31">Using relative hierarchical package names requires a simple
modification of <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a>.
</p>

<p id="32">In ANSI CL, <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a>,
if passed a package object, returns it; if passed a string, <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a> looks for a package with
that string as its name or nickname, and returns the package if it
finds one and returns <code>nil</code> if it does not; if passed
a symbol, the symbol name (a string) is extracted and <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a> proceeds as it does
with a string. </p>

<p id="33">For implementing hierarchical packages, the behavior when the
argument is a package object (return it) does not change. But when the
argument is a string starting with one or more dots not directly
naming a package, <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a>
will, instead of returning <code>nil</code>, check whether the
string can be resolved as naming a relative package, and if so, return
the associated absolute package object. (If the argument is a symbol,
the symbol name is extracted and <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a> proceeds as it does with a
string argument.)</p>

<p id="34">In Allegro CL, <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a>
passes a string to the function
<strong>excl::package-name-to-package</strong>, which returns a
package object or <code>nil</code>. Without hierarchical
packages, <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a> returns
<code>nil</code> if
<strong>excl::package-name-to-package</strong> returns
<code>nil</code>. With hierarchical packages, if
<strong>excl::package-name-to-package</strong> returns
<code>nil</code>, <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a> calls
<strong>excl::relative-package-name-to-package</strong>, which again returns
a package object or <code>nil</code>. If <code>nil</code>
is returned at this point, <strong>cl:find-package</strong> returns
<code>nil</code>.</p>

<p id="35">The complete source code for the modifications made to Allegro CL
(except for the modifications to <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a>) is given below and is in the
public domain. It can be used by any CL vendor to augment their
implementation to behave as this document suggests. <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a> should be modified according
to the description just above -- trying to resolve a name as relative
if the name does not itself name a package.</p>

<p id="36"><strong>Note</strong> that you should not use leading dots in
package names when using hierarchical packages.</p>

<h3 id="37">Using hierarchical packages without modifying cl:find-package:</h3>

<p id="38">Even without the modifications to <strong>cl:find-package</strong>,
authors need not avoid using relative package names, but the ability
to reuse relative package names is restricted. The following
example illustrates this:</p>

<blockquote>
  <p id="39">Consider a module <i>foo</i> which is composed of the <i>my.foo.bar</i> 
  and <i>my.foo.baz</i>
  packages. In the code for each of these packages there are relative package
  references, <i>..bar</i> and <i>..baz</i>.</p>
  <p id="40">Implementations that have the new <strong>cl:find-package</strong> would have on their <code>*features*</code> list the symbol <code>:relative-package-names</code>.
  Then, in the <i>foo</i> module, there would be definitions of the <i>my.foo.bar</i> and <i>my.foo.baz</i>
  packages like so:</p>
  <pre id="41">(defpackage :my.foo.bar
  #-relative-package-names (:nicknames #:..bar)
  ...)

(defpackage :my.foo.baz
  #-relative-package-names (:nicknames #:..baz)
  ...)</pre>
  <p id="42">Then, in a <code>#-relative-package-names</code> implementation, the
  symbol <code>my.foo.bar:blam</code> would be visible from <i>my.foo.baz</i>
  as <code>..bar:blam</code>, just as it would from a <code>#+relative-package-names</code> implementation.</p>
</blockquote>

<p id="43">So, even without the implementation of the augmented <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a>, one can still write
CL code that will work in both types of implementations, but
<em>..bar</em> and <em>..baz</em> are now used, so you cannot also
have <em>otherpack.foo.bar</em> and <em>otherpack.foo.baz</em> and use
<em>..bar</em> and <em>..baz</em> as relative names. (The point of
hierarchical packages, of course, is to allow reusing relative package
names.)</p>



<hr><h2 id="44"><a name="pack-prefixes-2">2.3 Package prefixes reserved by Allegro CL</a></h2>

<p id="45">
Starting in Allegro CL 6.0, Franz Inc. typically puts newly created
packages under the following top-level names:
</p>

<ul>
  <li id="46"><em>net</em> -- network related modules <ul>
      <li id="47"><em>uri</em> -- URI/URL/URN parser 
      (see <a href="uri.htm">uri.htm</a>)</li>
      <li id="48"><em>aserve</em> -- web server (see
      <a href="aserve/aserve.html">aserve/aserve.html</a>)</li>
      <li id="49"><em>rpc</em> -- Lisp-to-Lisp remote procedure call
      (see <a href="rpc.htm">rpc.htm</a>)</li>
    </ul>
  </li>
  <li id="50"><em>xml</em> -- used for generated namespaces</li>
  <li id="51"><em>javatools</em>
    <ul>
    <li id="52"><em>jlinker</em> -- Java interface components
    (see <a href="jlinker.htm">jlinker.htm</a>)</li>
    <li id="53"><em>jil</em> -- Java-in-Lisp bytecode compiler
    (see <a href="jil.htm">jil.htm</a>)</li>
    </ul>
  </li>
  <li id="54"><em>cg</em> -- common graphics</li>
  <li id="55"><em>ide</em> -- cg-based graphical development environment</li>
  <li id="56"><em>corba</em></li>
  <li id="57"><em>ffi</em> -- foreign function related modules</li>
  <li id="58"><em>util</em> -- utility modules</li>
</ul>

<p id="59">
The use of these top-level names as packages in applications might run
into problems with Allegro CL 6.0 and future versions. Note that all current
package names (such as <em>excl</em>, <em>system</em> etc.) will also
be used.
</p>



<hr><h2 id="60"><a name="new-cl-funs-2">2.4 New Common Lisp functions</a></h2>

<p id="61">
To facilitate using hierarchical packages, we introduce several new
functions, other than the changed <a href="../ansicl/dictentr/find-pac.htm"><b>find-package</b></a>:
<strong>excl::relative-package-name-to-package</strong>, <a href="operators/excl/package-parent.htm"><b>package-parent</b></a> and <a href="operators/excl/package-children.htm"><b>package-children</b></a>. The source code for these
functions is also given below.
</p>

<p id="62">These functions are documented below with their implementation.</p>



<hr><h2 id="63"><a name="hier-pack-implementation-2">2.5 The implementation of Hierarchical Packages</a></h2>

<pre id="64">
;; The following source code is in the public domain.
;; Provided &quot;as is&quot; with no warranty of any kind.  
;; Use at your own risk.

(pushnew :relative-package-names *features*)

(defun relative-package-name-to-package (name)
  ;; Given a package name, a string, do a relative package name lookup.
  ;;
  ;; It is intended that this function will be called from find-package.
  ;; In Allegro, find-package calls package-name-to-package, and the latter
  ;; function calls this function when it does not find the package.
  ;;
  ;; Because this function is called via the reader, we want it to be as
  ;; fast as possible.
  (declare (optimize speed))
  (flet ((relative-to (package name)
	   (if* (string= &quot;&quot; name)
	      then package
	      else (package-name-to-package
		    (concatenate 'simple-string
		      (package-name package) &quot;.&quot; name))))
	 (find-non-dot (name)
	   (do* ((len (length name))
		 (i 0 (1+ i)))
	       ((= i len) nil)
	     (declare (fixnum len i))
	     (when (char/= #\. (schar name i)) (return i)))))
    (when (char= #\. (schar (simple-string name) 0))
      (let* ((last-dot-position (or (find-non-dot name) (length name)))
	     (n-dots last-dot-position)
	     (name (subseq name last-dot-position)))
	(cond ((= 1 n-dots)
	       ;; relative to current package
	       (relative-to *package* name))
	      (t
	       ;; relative to our (- n-dots 1)'th parent
	       (let ((p *package*)
		     tmp)
		 (dotimes (i (1- n-dots))
		   (when (not (setq tmp (package-parent p)))
		     (error &quot;The parent of ~a does not exist.&quot; p))
		   (setq p tmp))
		 (relative-to p name))))))))

(defun package-parent (package-specifier)
  ;; Given package-specifier, a package, symbol or string, return the
  ;; parent package.  If there is not a parent, signal an error.
  ;;
  ;; Because this function is called via the reader, we want it to be as
  ;; fast as possible.
  (declare (optimize speed))
  (flet ((find-last-dot (name)
	   (do* ((len (1- (length name)))
		 (i len (1- i)))
	       ((= i -1) nil)
	     (declare (fixnum len i))
	     (when (char= #\. (schar name i)) (return i)))))
    (let* ((child (cond ((packagep package-specifier)
			 (package-name package-specifier))
			((symbolp package-specifier)
			 (symbol-name package-specifier))
			((stringp package-specifier) package-specifier)
			(t (error &quot;Illegal package specifier: ~s.&quot;
				  package-specifier))))
	   (dot-position (find-last-dot child)))
      (cond (dot-position
	     (let ((parent (subseq child 0 dot-position)))
	       (or (package-name-to-package parent)
		   (error &quot;The parent of ~a does not exist.&quot; child))))
	    (t (error &quot;There is no parent of ~a.&quot; child))))))

(defun package-children (package-specifier &amp;key (recurse t))
  ;; Given package-specifier, a package, symbol or string, return all the
  ;; packages which are in the hierarchy &quot;under&quot; the given package.  If
  ;; :recurse is nil, then only return the immediate children of the
  ;; package.
  ;;
  ;; While this function is not called via the reader, we do want it to be
  ;; fast.
  (declare (optimize speed))
  (let ((res ())
	(parent (cond ((packagep package-specifier)
		       (package-name package-specifier))
		      ((symbolp package-specifier)
		       (symbol-name package-specifier))
		      ((stringp package-specifier) package-specifier)
		      (t (error &quot;Illegal package specifier: ~s.&quot;
				package-specifier)))))
    (labels
	((string-prefix-p (prefix string)
	   ;; Return length of `prefix' if `string' starts with `prefix'.
	   ;; We don't use `search' because it does much more than we need
	   ;; and this version is about 10x faster than calling `search'.
	   (let ((prefix-len (length prefix))
		 (seq-len (length string)))
	     (declare (fixnum prefix-len seq-len))
	     (when (&gt;= prefix-len seq-len)
	       (return-from string-prefix-p nil))
	     (do* ((i 0 (1+ i)))
		 ((= i prefix-len) prefix-len)
	       (declare (fixnum i))
	       (when (not (char= (schar prefix i) (schar string i)))
		 (return nil)))))
	 (test-package (package-name package)
	   (let ((prefix
		  (string-prefix-p (concatenate 'simple-string parent &quot;.&quot;)
				   package-name)))
	     (cond (recurse (when prefix (pushnew package res)))
		   (t (when (and prefix
				 (not (find #\. package-name :start prefix)))
			(pushnew package res)))))))

      ;; In Allegro, list-all-packages calls `sort', so use an internal
      ;; method to get the package names.
      #+allegro
      (maphash #'test-package *package-names*)
      #-allegro
      (dolist (package (list-all-packages))
	(funcall #'test-package (package-name package) package))
      
      res)))
</pre>



<hr><h2 id="65"><a name="hier-pack-tests-2">2.6 Testing the Hierarchical Packages Implementation</a></h2>

<p id="66">
The following test code can be used to check a hierarchical package
implementation. You must use the Allegro CL test harness, documented
in the <a href="test-harness.htm">test-harness.htm</a>. The test harness is loaded
by the <code>(require :tester)</code> form.
</p>

<pre id="67">
;; The following source code is in the public domain.
;; Provided &quot;as is&quot; with no warranty of any kind.  
;; Use at your own risk.

(eval-when (compile eval load)
  (require :tester))

(defpackage :package-tests
  (:use #:common-lisp #:excl #:util.test)
  (:import-from #:excl #:package-children)
  (:import-from #:excl #:package-parent))

(in-package :package-tests)

(defpackage :package-tests.a)
(defpackage :package-tests.a.b)
(defpackage :package-tests.a.b.c)
(defpackage :package-tests.a.b.c.d)
(defpackage :package-tests.a.b.c.d.e)
(defpackage :package-tests.a.b.c.d.f)
(defpackage :package-tests.a.b.c.e)
(defpackage :package-tests.a.b.c.f)
(defpackage :package-tests.a.b.d)
(defpackage :package-tests.a.b.e)
(defpackage :package-tests.a.c)
(defpackage :package-tests.a.d)
(defpackage :package-tests.b)
(defpackage :package-tests.c)
(defpackage :package-tests.d)

(defpackage :package-tests-foo.bar.baz)
(defpackage :package-tests-foo.bar.baz.wham)

(defun do-package-tests ()
  (test t
	(progn #+relative-package-names t
	       #-relative-package-names nil)
	:test #'eq)
  
;;;; test package-children
  (test '(&quot;package-tests.a&quot; &quot;package-tests.b&quot;
	  &quot;package-tests.c&quot; &quot;package-tests.d&quot;)
	(sort (mapcar #'package-name
		      (package-children :package-tests :recurse nil))
	      #'string&lt;)
	:test #'equal)
  (test '(&quot;package-tests.a&quot; &quot;package-tests.a.b&quot; &quot;package-tests.a.b.c&quot;
	  &quot;package-tests.a.b.c.d&quot; &quot;package-tests.a.b.c.d.e&quot;
	  &quot;package-tests.a.b.c.d.f&quot; &quot;package-tests.a.b.c.e&quot;
	  &quot;package-tests.a.b.c.f&quot; &quot;package-tests.a.b.d&quot; &quot;package-tests.a.b.e&quot;
	  &quot;package-tests.a.c&quot; &quot;package-tests.a.d&quot; &quot;package-tests.b&quot;
	  &quot;package-tests.c&quot; &quot;package-tests.d&quot;)
	(sort (mapcar #'package-name (package-children :package-tests))
	      #'string&lt;)
	:test #'equal)
  (test '(&quot;package-tests.a.b.c.d&quot; &quot;package-tests.a.b.c.d.e&quot;
	  &quot;package-tests.a.b.c.d.f&quot; &quot;package-tests.a.b.c.e&quot;
	  &quot;package-tests.a.b.c.f&quot;)
	(sort (mapcar #'package-name (package-children :package-tests.a.b.c))
	      #'string&lt;)
	:test #'equal)
  (test '(&quot;package-tests.a.b.c.d&quot; &quot;package-tests.a.b.c.e&quot;
	  &quot;package-tests.a.b.c.f&quot;)
	(sort (mapcar #'package-name
		      (package-children :package-tests.a.b.c :recurse nil))
	      #'string&lt;)
	:test #'equal)
  (test '(&quot;package-tests.a.b.c.d.e&quot; &quot;package-tests.a.b.c.d.f&quot;)
	(sort (mapcar #'package-name (package-children :package-tests.a.b.c.d))
	      #'string&lt;)
	:test #'equal)
  (test '(&quot;package-tests.a.b.c.d.e&quot; &quot;package-tests.a.b.c.d.f&quot;)
	(sort (mapcar #'package-name
		      (package-children :package-tests.a.b.c.d :recurse nil))
	      #'string&lt;)
	:test #'equal)
  (test '()
	(package-children :package-tests.b)
	:test #'equal)
  (test '()
	(package-children :package-tests.c)
	:test #'equal)
  (test '()
	(package-children :package-tests.d)
	:test #'equal)
  
;;;; test package-parent
  (test (find-package :package-tests)
	(package-parent :package-tests.a))
  (test (find-package :package-tests.a)
	(package-parent :package-tests.a.b))
  (test (find-package :package-tests.a.b)
	(package-parent :package-tests.a.b.c))
  (test (find-package :package-tests.a.b.c)
	(package-parent :package-tests.a.b.c.d))
  (test (find-package :package-tests.a.b.c.d)
	(package-parent :package-tests.a.b.c.d.e))
  (test (find-package :package-tests.a.b.c.d)
	(package-parent :package-tests.a.b.c.d.f))
  (test (find-package :package-tests.a.b.c)
	(package-parent :package-tests.a.b.c.e))
  (test (find-package :package-tests.a.b.c)
	(package-parent :package-tests.a.b.c.f))
  (test (find-package :package-tests.a.b)
	(package-parent :package-tests.a.b.d))
  (test (find-package :package-tests.a.b)
	(package-parent :package-tests.a.b.e))
  (test (find-package :package-tests.a)
	(package-parent :package-tests.a.c))
  (test (find-package :package-tests.a)
	(package-parent :package-tests.a.d))
  (test (find-package :package-tests)
	(package-parent :package-tests.b))
  (test (find-package :package-tests)
	(package-parent :package-tests.c))
  (test (find-package :package-tests)
	(package-parent :package-tests.d))

  (test-error (package-parent :package-tests))
  (test-error (package-parent :package-tests-foo.bar.baz))
  (test-error (package-parent :package-tests-foo.bar))
  (test-error (package-parent :package-tests-foo))
  
;;;; test find-package
  (dolist
      (item
	  '((:package-tests.a         :package-tests.a &quot;.&quot;)
	    (:package-tests           :package-tests.a &quot;..&quot;)
	    (:package-tests.b         :package-tests.a &quot;..b&quot;)
	    (:package-tests.c         :package-tests.a &quot;..c&quot;)
	    (:package-tests.d         :package-tests.a &quot;..d&quot;)
	    (:package-tests.a.b       :package-tests.b &quot;..a.b&quot;)
	    (:package-tests           :package-tests.a.b &quot;...&quot;)
	    (:package-tests.b         :package-tests.a.b &quot;...b&quot;)
	    (:package-tests.a.b.c.d.f :package-tests.a.b.c.d &quot;...c.d.f&quot;)
	    (:package-tests           :package-tests.a.b.c.d &quot;.....&quot;)
	    (:package-tests.b         :package-tests.a.b.c.d &quot;.....b&quot;)
	    (:package-tests.a.b.c.d   :package-tests.a.b.c.d &quot;.&quot;)
	    (:package-tests.a.b.c     :package-tests.a.b.c &quot;.&quot;)
	    (:package-tests.a.b       :package-tests.a.b &quot;.&quot;)))
    (test (symbol-name (first item))
	  (let* ((*package* (find-package (second item)))
		 (p (find-package (third item))))
	    (cond (p (package-name p))
		  (t (error &quot;could not find package ~s.&quot; (third item)))))))

  (test-error (find-package &quot;..&quot;))
  (test-error (find-package &quot;...&quot;))
  (test-error (find-package &quot;....&quot;))
  (test-error (find-package &quot;....foo&quot;))
  (let ((*package* (find-package :package-tests.b)))
    (test-error (find-package &quot;...&quot;))))

(let ((*test-errors* 0)
      (*test-successes* 0)
      (*test-unexpected-failures* 0))
  (format t &quot;Beginning package tests...~%&quot;)
  (do-package-tests)
  (format t &quot;Completed package tests.~%&quot;)
  (format t &quot;** Successes: ~s~%&quot; *test-successes*)
  (format t &quot;** Errors: ~s~%&quot; *test-errors*)
  (format t &quot;** Unexpected failures: ~s~%&quot; *test-unexpected-failures*))
</pre>



<hr><hr><h2 id="68"><a name="packages-in-acl-1">3.0 Packages in Allegro CL</a></h2>

<p id="69">
In addition to the hierarchical packages named in
<a href="#pack-prefixes-2">Section 2.3 Package prefixes reserved by Allegro CL</a>, the following packages
used by Allegro CL are of direct importance to the user. Note that all
nicknames are not listed in every case. Use <a href="../ansicl/dictentr/package4.htm"><b>package-nicknames</b></a> applied to a package to see
the complete list. The first nickname listed in each case is the
principal nickname.
</p>

<p id="70">Some of these packages may not exist in a standard Allegro CL image
until a <em>fasl</em> file containing the functionality associated
with the package is loaded. In most cases, the loading is automatic
when the package is referenced. Thus</p>

<pre id="71">
(find-package :cltl1)
</pre>

<p id="72">causes <em>cltl1.fasl</em> to be loaded from the bundle.</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="794">
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><p id="73" ALIGN="CENTER">Name</p></td>
    <td WIDTH="8%" VALIGN="TOP"><p id="74" ALIGN="CENTER">Some nicknames</p></td>
    <td WIDTH="39%" VALIGN="TOP"><p id="75" ALIGN="CENTER">Brief Description</p></td>
    <td WIDTH="11%" VALIGN="TOP"><p id="76" ALIGN="CENTER">Locked?</p></td>
    <td WIDTH="23%" VALIGN="TOP"><p id="77" ALIGN="CENTER">Notes</p></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>acl-socket</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Socket interface functionality. See <a href="socket.htm">socket.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">No</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>aclwin</code></td>
    <td WIDTH="8%" VALIGN="TOP">aclwin302</td>
    <td WIDTH="39%" VALIGN="TOP">Functionality from Allegro CL 3.0.2 kept in 6.x for
    backward compatibility. </td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP"><p id="78">Exists in Windows and Unix. 
    In Unix, do </p> <p id="79">(require :aclwin)</p>
    <p id="80">In Unix, symbols having to do with graphics have no function 
    definition. Functionality
    that is Windows-specific generates an error when called in Unix.</p></td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>clos</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">the MOP extension to CLOS (CLOS functionality is in
    common-lisp).</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Always present in an image.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>cltl1</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Some symbols removed from the Common Lisp standard by X3J13.</td>
    <td WIDTH="11%" VALIGN="TOP">No</td>
    <td WIDTH="23%" VALIGN="TOP">Functionality named by symbols in this package is out of date
    and use should be avoided. Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>cg</code></td>
    <td WIDTH="8%" VALIGN="TOP">common-graphics</td>
    <td WIDTH="39%" VALIGN="TOP">Common Graphics windows functionality.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Windows only. Always present in an image with the IDE.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>common-graphics-user</code></td>
    <td WIDTH="8%" VALIGN="TOP">cg-user</td>
    <td WIDTH="39%" VALIGN="TOP">User environment in the IDE</td>
    <td WIDTH="11%" VALIGN="TOP">No</td>
    <td WIDTH="23%" VALIGN="TOP">Windows only. Uses aclwin, excl, cg, cltl1, cl, ide. Always
    present in an image with the IDE.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>common-lisp</code></td>
    <td WIDTH="8%" VALIGN="TOP">cl</td>
    <td WIDTH="39%" VALIGN="TOP">Standard CL symbols.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Always present in an image.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>common-lisp-user</code></td>
    <td WIDTH="8%" VALIGN="TOP">cl-user<br>user</td>
    <td WIDTH="39%" VALIGN="TOP">User environment.</td>
    <td WIDTH="11%" VALIGN="TOP">No</td>
    <td WIDTH="23%" VALIGN="TOP">Uses cl and excl. Always present in an image.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>compiler</code></td>
    <td WIDTH="8%" VALIGN="TOP">comp</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with the compiler.
    See <a href="compiling.htm">compiling.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>cross-reference</code></td>
    <td WIDTH="8%" VALIGN="TOP">xref</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with the cross
    referencer. See <a href="cross-reference.htm">cross-reference.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>dde</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with 
    the DDE interface on Windows. See <a href="dde.htm">dde.htm</a></td>
    <td WIDTH="11%" VALIGN="TOP">No</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>defsystem</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with defsystem. See <a href="defsystem.htm">defsystem.htm</a></td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>debugger</code></td>
    <td WIDTH="8%" VALIGN="TOP">db</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with the debugger.
    See <a href="debugging.htm">debugging.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>excl</code></td>
    <td WIDTH="8%" VALIGN="TOP">excl</td>
    <td WIDTH="39%" VALIGN="TOP">General extensions to Common Lisp</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Always present in an image.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>foreign-functions</code></td>
    <td WIDTH="8%" VALIGN="TOP">ff</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with the foreign
    functions facility. See <a href="foreign-functions.htm">foreign-functions.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>garbage</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Package for compiler labels and some CLOS names. </td>
    <td WIDTH="11%" VALIGN="TOP">No</td>
    <td WIDTH="23%" VALIGN="TOP">Always present in an image.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>ide</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Integrated Development
    Environment functionality.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Windows only. Always present in an image with the IDE.</td>
  </tr>

  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>inspect</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with the inspector.
    See <a href="inspector.htm">inspector.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>keyword</code></td>
    <td WIDTH="8%" VALIGN="TOP"> </td>
    <td WIDTH="39%" VALIGN="TOP">Standard CL package.</td>
    <td WIDTH="11%" VALIGN="TOP">No</td>
    <td WIDTH="23%" VALIGN="TOP">Always present in an image.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>multiprocessing</code></td>
    <td WIDTH="8%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with multiprocessing.
    See <a href="multiprocessing.htm">multiprocessing.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>profiler</code></td>
    <td WIDTH="8%" VALIGN="TOP">prof</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with the runtime analyzer.
    See <a href="runtime-analyzer.htm">runtime-analyzer.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Autoloaded.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>system</code></td>
    <td WIDTH="8%" VALIGN="TOP">sys, si</td>
    <td WIDTH="39%" VALIGN="TOP">System functionality and internals.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Always present in an image.</td>
  </tr>
  <tr>
    <td WIDTH="19%" VALIGN="TOP"><code>top-level</code></td>
    <td WIDTH="8%" VALIGN="TOP">tpl</td>
    <td WIDTH="39%" VALIGN="TOP">Symbols naming functionality associated with the top level.
    See <a href="top-level.htm">top-level.htm</a>.</td>
    <td WIDTH="11%" VALIGN="TOP">Yes</td>
    <td WIDTH="23%" VALIGN="TOP">Always present in an image.</td>
  </tr>
</table>

<hr><hr><h2 id="81"><a name="notes-on-specific-packages-1">4.0 Notes on specific packages</a></h2>

<p id="82">When you start up Allegro CL on UNIX or without the Integrated
Development Environment on Windows, you are <i>in</i> the
<code>common-lisp-user</code> package. At the start, there are
no symbols in the <code>common-lisp-user</code> package, but the
<code>common-lisp</code> and <code>excl</code> packages
are used, so external symbols from those packages are available to the
<code>user</code> package. When you start the Integrated
Development Environment (Windows only) you are in the
<code>common-graphics-user</code> package.</p>

<p id="83">The <code>common-lisp</code> package contains only those symbols
specified in the ANSI CL specification. Some of the capabilities of
standard Common Lisp functions have been extended, but they can all be
used in the way specified in ANSI CL. The extensions are not portable,
of course. See <a href="implementation.htm">implementation.htm</a> for
more information on extensions to standard Common Lisp
functionality.</p>

<p id="84">With that caveat, if you use the common-lisp package only, you will
have portable code that can with greatest ease be ported to Common
Lisp systems other than Allegro CL. </p>

<p id="85">A number of symbols were removed from the Common Lisp standard by
the X3J13 committee.  We have maintained many of these symbols in the
<code>cltl1</code> package, for the purpose of providing
backward compatibility. </p>

<p id="86">The <code>excl</code> and <code>system</code> packages
contain many of the extensions in Allegro CL. Two packages in earlier
versions on UNIX (4.3.x and earlier), <code>franz</code> and
<code>stream</code>, have been merged with <code>excl</code>
starting in version 5.0.  Both <code>stream</code> and
<code>franz</code> are nicknames of
<code>excl</code>. <code>excl</code> is also the principal
nickname of the <code>excl</code> package to ensure that name is
used when <a href="variables/excl/s_print-nickname_s.htm"><code>*print-nickname*</code></a> is true.</p>

<p id="87">The <code>top-level</code> package contains symbols used by
the top level. Note that some of these symbols have the same names as
symbols in the <code>common-lisp</code> package (for example,
<a href="variables/tpl/s_print-level_s.htm"><code>*print-level*</code></a> and
<a href="variables/tpl/s_print-length_s.htm"><code>*print-length*</code></a>).
Therefore, we recommend that a package using the
<code>common-lisp</code> package not use (in the sense of <a href="../ansicl/dictentr/use-pack.htm"><b>use-package</b></a>) the
<code>top-level</code> package. </p>

<hr><hr><h2 id="88"><a name="package-nicknames-1">5.0 Package nicknames</a></h2>

<p id="89">Packages can have (usually shorter) nicknames, which can be used in
place of the full names. Symbols unavailable in the current package
are printed (during, e.g., tracing) with package qualifiers. Allegro
CL allows you to specify whether you want the (non-nickname) package
name as the qualifier or the principal nickname as the qualifier. The
following variable <a href="variables/excl/s_print-nickname_s.htm"><code>*print-nickname*</code></a> controls whether the printer
uses the full name or the principal nickname of a package (if true,
the principal nickname is used, if <code>nil</code>, the
package name is used). Note that certain utilities (e.g. <a href="../ansicl/dictentr/aproposa.htm"><b>apropos</b></a> and the debugger) bind this
variable to true and so always use the nickname.</p>

<p id="90">The principal nickname of some of the packages of interest to users
are listed next (<code>nil</code> means no defined
nicknames). </p>

<div align="left">

<table BORDER="1" CELLSPACING="1" CELLPADDING="8" WIDTH="525">
  <tr>
    <td VALIGN="TOP" COLSPAN="3"><p id="91" ALIGN="CENTER">Table 2: Package Nicknames</p></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><p id="92" ALIGN="CENTER">Package name</p></td>
    <td WIDTH="32%" VALIGN="TOP"><p id="93" ALIGN="CENTER">Principal Nickname (<code>nil</code> means none)</p></td>
    <td WIDTH="32%" VALIGN="TOP"><p id="94" ALIGN="CENTER">Other Nickname (some nicknames may not
    be listed)</p></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>common-lisp</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>cl</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>lisp</code></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>clos</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>excl</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>excl</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>stream</code></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>system</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>sys</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>si</code></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>common-lisp-user</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>cl-user</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>user</code></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>debugger</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>debug</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>db</code></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>inspect</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>nil</code></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>compiler</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>comp</code></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>flavors</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>fla</code></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>foreign-functions</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>ff</code></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>multiprocessing</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>mp</code></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>top-level</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>tpl</code></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>defsystem</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>defsys</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>ds</code></td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><code>cross-reference</code></td>
    <td WIDTH="32%" VALIGN="TOP"><code>xref</code></td>
    <td WIDTH="32%" VALIGN="TOP"> </td>
  </tr>
</table>
</div>

<p id="95">Package nicknames can be found with the Common Lisp function
<a href="../ansicl/dictentr/package4.htm"><b>package-nicknames</b></a>, which
returns a list of the nicknames of its argument, with the principal
one first.  Sometimes, you may wish to use a nickname of an Allegro CL
package as the name of your own package. (E.g. some users would like
to have their own package named <code>db</code>, perhaps for
database functionality, but <code>db</code> is a nickname of the
<code>debugger</code> package.) You can change the nicknames of
a package with <a href="../ansicl/dictentr/rename-p.htm"><b>rename-package</b></a>.
You must do it in a <a href="operators/excl/without-package-locks.htm"><b>without-package-locks</b></a> form, however, because
of package locking described just below.</p>

<hr><hr><h2 id="96"><a name="package-locking-1">6.0 Package locking and package definition locking</a></h2>

<p id="97">Packages have two kinds of locks as an extension in Allegro CL. The
package-lock protects a package from changes in its structure (its use
list, its exported symbols, etc.). The package-definition-lock
protects the symbols in the package from new or changed uses as the
name of a function, macro, structure, or type.</p>

<p id="98">Tracing and advice are not affected by either type of package locking.</p>

<hr><h2 id="99"><a name="package-locking-2">6.1 Package locking</a></h2>

<p id="100">When the function <a href="operators/excl/package-lock.htm"><b>package-lock</b></a> returns true when applied to a
package, we say the package is package-locked. When a package is
package-locked, the system will signal an error of type
package-locked-error when code is executed that tries to: </p>

<ul>
  <li id="101"><b>import</b> a symbol into the package (with <a href="../ansicl/dictentr/import.htm"><b>import</b></a> and <a href="../ansicl/dictentr/shadowin.htm"><b>shadowing-import</b></a>)</li>
  <li id="102"><b>export</b> a symbol from the package (with <a href="../ansicl/dictentr/export.htm"><b>export</b></a>).</li>
  <li id="103"><b>unexport</b> a symbol (with <a href="../ansicl/dictentr/unexport.htm"><b>unexport</b></a>)</li>
  <li id="104"><b>change the name</b> of the package (with <a href="../ansicl/dictentr/rename-p.htm"><b>rename-package</b></a>).</li>
  <li id="105"><b>change the packages used</b> by the package (with <a href="../ansicl/dictentr/use-pack.htm"><b>use-package</b></a> and <a href="../ansicl/dictentr/unuse-pa.htm"><b>unuse-package</b></a>).</li>
  <li id="106"><b>unintern</b> a symbol in the package (with <a href="../ansicl/dictentr/unintern.htm"><b>unintern</b></a>)</li>
  <li id="107"><b>shadow</b> a symbol (with <a href="../ansicl/dictentr/shadow.htm"><b>shadow</b></a> or <a href="../ansicl/dictentr/shadowin.htm"><b>shadowing-import</b></a>).</li>
</ul>

<p id="108">The list is exhaustive. Note that intern and delete-package cannot
signal a package-locked-error. The function <a href="operators/excl/package-lock.htm"><b>package-lock</b></a> applied to a package object (but
not a symbol or string naming a package) returns true if the package
is locked and returns <code>nil</code> if it is not
locked. Setf can be used with <a href="operators/excl/package-lock.htm"><b>package-lock</b></a> to lock or unlock a package.</p>



<hr><h2 id="109"><a name="package-definition-locking-2">6.2 Package definition locking</a></h2>

<p id="110">A package is package-definition-locked if the function <a href="operators/excl/package-definition-lock.htm"><b>package-definition-lock</b></a> (whose
argument must be a package object, not a package name) returns true
when applied to the package. When a package is
package-definition-locked, the system will signal an error when code
is executed that attempts any of the following actions on a symbol
homed in the package: </p>

<ul>
  <li id="111">defining it as a function (e.g. with <a href="../ansicl/dictentr/defun.htm"><b>defun</b></a> or <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a> of <a href="../ansicl/dictentr/fdefinit.htm"><b>fdefinition</b></a>)</li>
  <li id="112">defining it as a macro (e.g. with <a href="../ansicl/dictentr/defmacro.htm"><b>defmacro</b></a>)</li>
  <li id="113">defining it as a type specifier (with <a href="../ansicl/dictentr/defstruc.htm"><b>defstruct</b></a>, <a href="../ansicl/dictentr/defclass.htm"><b>defclass</b></a>,
    <a href="../ansicl/dictentr/deftype.htm"><b>deftype</b></a>)</li>
  <li id="114">defining it as a structure (with <a href="../ansicl/dictentr/defstruc.htm"><b>defstruct</b></a>)</li>
  <li id="115">defining it as a symbol macro</li>
  <li id="116">defining it as a compiler macro</li>
  <li id="117">if the symbol is <a href="../ansicl/dictentr/fboundp.htm"><b>fboundp</b></a>, lexically binding it with <a href="../ansicl/dictentr/fletlabe.htm"><b>flet</b></a>,
    <a href="../ansicl/dictentr/fletlabe.htm"><b>labels</b></a>, or <a href="../ansicl/dictentr/fletlabe.htm"><b>macrolet</b></a></li>
</ul>

<p id="118">Function names that are lists are also protected if the important
symbol (usually the cadr, e.g. <i>border</i> in <code>(setf
border)</code>) in the list is in the definition-locked package. We
repeat here the definition of <a href="operators/excl/package-definition-lock.htm"><b>package-definition-lock</b></a> because it describes
how the lock can be circumvented.</p>

<blockquote>
  <blockquote>
    <p id="119"><strong>package-definition-lock</strong> </p>
    <p id="120">Arguments: <em>package</em></p>
    <p id="121">Returns <code>t</code> or <code>nil</code> as package is or is not
    definition-locked. <em>package</em> must be a package object (it cannot be a symbol or a
    string). <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a> may be used with this function to definition-lock or unlock
    a package.</p>
    <p id="122">Even if a package is package-definition-locked, no error will be signaled when</p>
    <blockquote>
      <ol>
        <li id="123">the value of <a href="variables/excl/s_enable-package-locked-errors_s.htm"><code>*enable-package-locked-errors*</code></a>
          is <code>nil</code>;</li>
        <li id="124">the violation is dynamically inside the body of a call to the macro <a href="operators/excl/without-package-locks.htm"><b>without-package-locks</b></a>; </li>
        <li id="125">the list returned by applying <strong>package-implementation-packages</strong> to
          the value of <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a> contains the home package of the symbol being operated
          on. Implementation packages are defined just below. Note that unless you have specified a
          list of implementation packages for a package that does not include the package itself
          (which would be unusual), no error will be signaled when <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a> is the
          home package of the symbol being operated on.</li>
      </ol>
    </blockquote>
    <p id="126">If a violation is encountered while compiling a file, a warning is signaled rather than
    an error. If the resulting <em>fasl</em> file is loaded, an error will then be signaled.</p>
  </blockquote>
</blockquote>



<hr><h2 id="127"><a name="implementation-packages-2">6.3 Implementation packages</a></h2>

<p id="128">
Allegro CL allows a package to have a list of associated packages
(called <em>implementation packages</em>). No warning or error will be
signaled for a definition or redefinition in one package when the
value of <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a> is an
implementation package of that package. Both <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a> and <a href="../ansicl/dictentr/make-pac.htm"><b>make-package</b></a> have been extended to accept an
<i>implementation-packages</i> keyword
argument and the setfable function <a href="operators/excl/package-implementation-packages.htm"><b>package-implementation-packages</b></a> accesses that
list of packages.</p>

<p id="129">
The value of the <i>implementation-packages</i> argument
to <a href="../ansicl/dictentr/make-pac.htm"><b>make-package</b></a> should be a
list of strings naming packages. The <a href="../ansicl/dictentr/defpacka.htm"><b>defpackage</b></a> form should contain a subform which
is a list whose first element is
<code>:implementation-packages</code> and whose remaining
elements are strings naming the desired packages (as shown in the
example below). When unspecified, the list of implementation packages
defaults to a list containing the string naming the package being
defined. The <i>implementation-packages</i> argument is
not standard Common Lisp. You may wish to conditionalize it in
portable code, as shown next.
</p>

<pre id="130">
(defpackage :mypack 
    #+allegro (:implementation-packages "MYPACK"
                                        "MYPACK-2")
                ; other options as desired
   )
</pre>

<p id="131">
The <code>:implementation-packages</code> option will only be
read by Allegro CL. Note that since we specified a value, we had to
include "MYPACK" as well as "MYPACK-2" in order to
allow symbols whose home package is <code>mypack</code> to be
redefined without warning or error while the value of <a href="../ansicl/dictentr/package.htm"><code>*package*</code></a> is the
<code>mypack</code> package.
</p>

<p id="132">
Note that implementation packages protects against warnings and
errors for package definition locks only. Package locks (the
distinction is described above) are not affected.
</p>

<p id="133">
Here is an example. Suppose we define two packages: foo and
bar. "BAR" is on the
<code>:implementation-packages</code> list for
<strong>foo</strong>, but "FOO" is not on the
<code>:implementation-packages</code> list for
<code>bar</code>.  Both packages are definition-locked.
</p>


<pre id="134">
(defpackage :foo (:implementation-packages "FOO" "BAR"))
(defpackage :bar)
(setf (package-definition-lock (find-package :foo)) t)
(setf (package-definition-lock (find-package :bar)) t)
</pre>

<p id="135">
Consider the following two files. The first starts with
<code>(in-package :bar)</code> and defines a function on
<b>foo::mysym</b>. The second starts with
<code>(in-package :foo)</code> and defines a function on
<b>bar::my-other-sym</b>. Compiling or
loading the first file signals no warning or error, since the bar
package is an implementation package for the foo package. The second
signals a warning on compilation and an error on loading because the
<code>foo</code> package is not an implementation package for the
<code>bar</code> package.
</p>


<pre id="136">
;; File # 1
;; Compiling or loading this file will not signal a warning 
;; (for compilation)

;; or an error (for loading) even if the FOO package is 
;; definition locked,
;; because the BAR package is an implementation package of 
;; the FOO package.
(in-package :bar)
(defun foo::mysym (a b ) (+ a b))

;; File # 2
;; Compiling or loading this file will signal a warning 
;; (for compilation)
;; or an error (for loading) if the BAR package is definition 
;; locked, because
;; the FOO package is not an implementation package 
;; of the BAR package.
(in-package :foo)
(defun bar::my-other-sym (c) (sqrt c))
</pre>



<hr><h2 id="137"><a name="package-locked-errors-2">6.4 Package locked errors</a></h2>

<p id="138">
The following script shows what happens when you try to perform a
protected action on a package-locked package. Here we try to export
the symbol <code>excl::*debug-enclose-printer-errors*</code>
from the <code>excl</code> package.</p>

<pre id="139">
USER(3): (export 'excl:: *debug-enclose-printer-errors* 
                 (find-package :excl))
Error: #&lt;The EXCL package&gt; is locked against changes by EXPORT.
[condition type: PACKAGE-LOCKED-ERROR]

Restart actions (select using :continue):
0: Allow EXPORT to modify #&lt;The EXCL package&gt;.
[1c] USER(4):
</pre>

<p id="140">The next script shows what happens when you try to define a
function on a symbol in a package-definition-locked package. We try to
define a function on the symbol
<code>excl:*read-init-files*</code>. We chose this admittedly
strange example to make clear that a symbol need not already have a
function definition (the symbol in question does not) in order for an
error to be signaled.</p>

<pre id="141">
USER(18): (defun excl:*read-init-files* nil nil)
Error: Attempt to make a FUNCTION definition for the name
EXCL:*READ-INIT-FILES*. This name is in 
the EXCL package and defining it is a violation for
portable programs. The package EXCL has 
PACKAGE-LOCK-DEFINITIONS set, which causes the system 
to check for this violation.
[condition type: PACKAGE-LOCKED-ERROR]

Restart actions (select using :continue):
0: Set the FUNCTION definition of the name 
EXCL:*READ-INIT-FILES* anyway.
[1c] USER(19):
</pre>

<p id="142">In each case, the error has condition type package-locked-error and
in each case the error is continuable. By entering <i>:continue 0</i>,
the requested action (exporting the symbol or defining the function)
will take place. </p>

<p id="143">Note however that package locking is in place for a reason:
changing a system-supplied package or defining (or particularly
redefining) a function on a symbol in a system-supplied package can
cause Lisp to fail because assumptions about the package are
violated. </p>

<p id="144">Obviously there are times when changing a package or the definition
on a symbol is the right thing to do. If, for example, we instruct you
to make some change (say, export a symbol accidentally left off an
export list), we are guaranteeing that doing so will not have adverse
consequences.</p>



<hr><h2 id="145"><a name="circumventing-package-locked-errors-2">6.5 Locally circumventing package locked errors</a></h2>

<p id="146">The variable <a href="variables/excl/s_enable-package-locked-errors_s.htm"><code>*enable-package-locked-errors*</code></a> and macro
<a href="operators/excl/without-package-locks.htm"><b>without-package-locks</b></a> can be
used to prevent package-locked-errors (of either type -- ordinary
locks and definition locks) without actually unlocking a package. </p>

<p id="147">When <a href="variables/excl/s_enable-package-locked-errors_s.htm"><code>*enable-package-locked-errors*</code></a> is true,
executing code that violates package-locking or
package-definition-locking will signal errors and compiling such code
will signal warnings as described above. When it is <code>nil</code>, such code will execute without
package-locked-errors or compile-time warnings.</p>

<p id="148">The macro <a href="operators/excl/without-package-locks.htm"><b>without-package-locks</b></a>, which takes one or more
forms as its arguments, evaluates those forms with <a href="variables/excl/s_enable-package-locked-errors_s.htm"><code>*enable-package-locked-errors*</code></a>
bound to <code>nil</code>.</p>



<hr><h2 id="149"><a name="default-locked-packages-2">6.6 The packages locked by default</a></h2>

<p id="150">For symbols in the <code>common-lisp</code> package, all of
the actions prevented by package locking and package definition
locking are explicitly restricted by the ANSI specification (see
sections 11.1.2.1.2 and 11.1.2.1.2.1). The
<code>common-lisp</code> package is locked and definition locked
as are a number of Allegro CL packages, including</p>

<pre id="151">
    aclmop
    aclwin (Windows only)
    clos
    cltl1
    common-graphics (Windows only)
    common-lisp
    compiler
    cross-reference
    debugger
    defsystem
    excl
    excl.scm
    foreign-functions
    inspect
    lep
    multiprocessing
    profiler
    system
    top-level
</pre>



<hr><h2 id="152"><a name="package-locking-justification-2">6.7 Justification for package locking</a></h2>

<p id="153">For the <code>common-lisp</code> package, the restrictions of both
package-locks and package-lock-definitions locks are compliant with
the ANSI standard. Other system-provided packages in Allegro CL are
also locked, for the same reasons that the
<code>common-lisp</code> package is locked.</p>

<p id="154">Writers of application packages may want to lock their packages as
well, especially if the package may be used by other packages written
later. Package locks can detect inadvertent name collisions before
they cause program failures. The following forms will package-lock and
package-definition-lock the package <code>foo</code>. The same
forms, with <code>nil</code> instead of <code>t</code>, unlock the package.</p>

<pre id="155">
(setf (excl:package-lock (find-package :foo)) t)
(setf (excl:package-definition-lock (find-package :foo)) t)
</pre>




</body><hr><p id="2"><small>Copyright (c) 1998-2010, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br><small>Documentation for Allegro CL version 8.2. This page was not revised from the 8.1 page.</small><br>
<small>Created 2010.1.21.</small>
<br></p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faqs/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 8.2</b><br><small><a href="introduction.htm#updates-s">Unrevised from 8.1 to 8.2.</a></small><br><a href="http://www.franz.com/support/documentation/8.1/doc/packages.htm">8.1 version</a></td></tr></table></html>