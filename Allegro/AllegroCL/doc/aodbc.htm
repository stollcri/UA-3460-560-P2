<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"> <title>Allegro ODBC</title></head><link rel="stylesheet" href="acldoc-styles.css" type="text/css"><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faqs/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 8.2</b><br><small><a href="introduction.htm#updates-s">Unrevised from 8.1 to 8.2.</a></small><br><a href="http://www.franz.com/support/documentation/8.1/doc/aodbc.htm">8.1 version</a></td></tr></table><h1 id="2">Allegro ODBC</h1><p id="3">This document contains the following sections:</p><a href="#intro-1">1.0 Aodbc introduction</a><br>&nbsp;&nbsp;&nbsp;<a href="#platform-specific-2">1.1 Platform-specific information for aodbc</a><br><a href="#notes-1">2.0 Implementation notes for aodbc</a><br>&nbsp;&nbsp;&nbsp;<a href="#external-formats-2">2.1 Representing characters in databases in aodbc</a><br><a href="#using-1">3.0 Using ODBC</a><br><a href="#examples-1">4.0 ODBC examples</a><br>&nbsp;&nbsp;&nbsp;<a href="#simple-example-2">4.1 A simple interaction</a><br>&nbsp;&nbsp;&nbsp;<a href="#binding-input-2">4.2 Binding input parameters</a><br>&nbsp;&nbsp;&nbsp;<a href="#scanning-2">4.3 Scanning through rows</a><br><a href="#char-input-buffers-1">5.0 Character input buffers</a><br><a href="#queries-1">6.0 Queries</a><br><a href="#transactions-1">7.0 Transactions</a><br><a href="#references-1">8.0 Reference</a><br><a href="#conditions-1">9.0 Conditions</a><br><hr><hr><h2 id="4"><a name="intro-1">1.0 Aodbc introduction</a></h2>

<p id="5">
This document describes the Allegro ODBC interface. This is the second
version of the interface, originally introduced with release 5.0. The
earlier version (version 1 in earlier releases) is no longer
supported. 
</p>
<p id="6">
Allegro ODBC requires ODBC drivers that support either the version 2.0
or the version 3.0 ODBC definition. 
</p>

<p id="7">
An Allegro CL application accessing a database via this interface
consists of these layers
</p>

<ol>
  <li id="8">The application written in Lisp</li>
  <li id="9">Allegro ODBC</li>
  <li id="10">An ODBC driver manager. This is not part of the Allegro ODBC interface. 
    There is a
    driver manager that comes with certain Windows  programs 
    (and is controllable via the
    ODBC object in the Control Panel). For Unix users, companies 
    such as Intersolv sell
    ODBC driver managers.</li>
  <li id="11">An ODBC driver for the specific database being accessed. This driver 
    may be
    supplied by the same company that supplied the driver manager or 
    it may come from the
    database vendor.</li>
  <li id="12">The database server [optional] - for simple databases the 
    driver itself can do database
    operations and a server isn't needed. For high 
    performance client-server
    databases, the driver will communicate with the database server.</li>
</ol>

<p id="13">
The application program accesses and modifies the database via
<strong>sql</strong> statements. While there is a standard for
<strong>sql</strong>, most database vendors have extended sql to
support special features of their database engines. ODBC doesn't
impose a restriction on the <strong>sql</strong> statements you can
use, it just passes the <strong>sql</strong> on to the
database-specific driver. Thus if the goal is to make an
application that can work with any of a number of different databases,
it is the responsibility of the programmer to create only
<strong>sql</strong> statements that are portable between the
databases.
</p>

<p id="14">
Symbols naming functionality in AODBC version 2 are in the
<strong>dbi</strong> (nicknames include
<strong>database-interface</strong>) package.
</p>

<hr><h2 id="15"><a name="platform-specific-2">1.1 Platform-specific information for aodbc</a></h2>

<p id="16">
Allegro ODBC version 2 should run similarly on all
platforms. Differences arise not from the Allegro CL interface itself
but from differences in the ODBC drivers and databases and database
servers (if used). This section deals with platform-specific details,
mostly having to do with machine configuration. At this writing, there
is only one comment about the IBM/AIX platform.
</p>

<p id="17"><strong>IBM/AIX specific information:</strong></p>

<p id="18">
Allegro ODBC now works with DataDirect Technologies DataDirect drivers
3.11 or 3.7. (DataDirect Technologies was formerly Merant and before
that Intersolve.) To use them, you must be sure to install the
<em>nothread version</em>, as described in the
<em>/opt/odbc/READ.ME</em> file (installed on your computer when the
driver is installed).
</p>



<hr><hr><h2 id="19"><a name="notes-1">2.0 Implementation notes for aodbc</a></h2>

<ul>
  <li id="20">The ODBC driver manager that Allegro ODBC communicates with 
      must conform to ODBC version 2.0 or 3.0.</li>
  <li id="21">There are no intermediate level lisp-sql functions such as
     <strong>select-columns</strong> and <strong>update-columns</strong>
     because such functions need to
     generate sql statements that would be acceptable to all 
     database servers, and that is not possible.</li>
  <li id="22">Parameterized sql is supported. This allows an sql statement to be 
    parsed once and repeatedly executed, with a new parameter value supplied 
    each time. This
    reduces network traffic and server overhead.</li>
  <li id="23">The application can control the creation of Lisp objects to 
    represent results. For
    commands that return a sequence of rows the application can 
    control when specific columns
    of the row data are converted to a Lisp form.</li>
  <li id="24">Errors are signaled when exceptional conditions arise.</li>
</ul>



<hr><h2 id="25"><a name="external-formats-2">2.1 Representing characters in databases in aodbc</a></h2>


<p id="26">
Allegro CL supports various representations of characters. Along with
the standard 8-bit ASCII representation, 16-bit character formats are
supported. See <a href="iacl.htm">iacl.htm</a> for a discussion of this
issue.  External formats are described in the <a href="iacl.htm#external-formats-1">External formats</a> in that document.
</p>
<p id="27">
Allegro ODBC supports using external formats to specify the way
characters are represented in databases.  It is possible to specify on
a per-database basis how the characters in Lisp should be encoded into
a sequence of octets to be stored in a string object in the
database. Each database connection has an external-format slot which
you can set in the call to <a href="operators/dbi/connect.htm"><b>connect</b></a> and can read with <a href="operators/dbi/db-external-format.htm"><b>db-external-format</b></a> and change with <a href="operators/dbi/db-external-format.htm"><b>(setf
db-external-format)</b></a>.
</p>
<p id="28">
The default external format that aodbc uses is the one returned by the
form
<code>(crlf-base-ef
:latin1)</code> (see <a href="operators/excl/crlf-base-ef.htm"><b>crlf-base-ef</b></a>).
This external format encodes all 8
bit characters as the character's <a href="../ansicl/dictentr/char-co0.htm"><b>char-code</b></a>. Characters outside the 8 bit range
are encoded as the question mark character code. This external format
is ideal if you're running on an 8 bit character lisp (using
<b>alisp8</b> or <b>mlisp8</b> -- see <a href="startup.htm#executable-names-1">Allegro CL Executables</a> in
<a href="startup.htm">startup.htm</a>) or if you restrict yourself to 8 bit
characters on a 16 bit lisp. If you plan to use 16 bit characters in a
16 bit lisp then you may want to use the <code>:utf-8</code>
external format instead. If you plan for the database to be used by
other applications then you'll want to use an external format in Lisp
that those other applications understand.
</p>
<p id="29">
If you store information in the database using the <a href="operators/dbi/sql.htm"><b>sql</b></a> function then the external
format associated with the connection object of the database will
ensure that the correct encoding is done.
</p>
<p id="30">
If you use parameters to store data then you are reponsible for 
ensuring that the correct encoding is done when you copy a lisp string
into a parameter object.
</p>
<p id="31">
If you simply do:
</p>
<pre id="32">
(setf (ff:fslot-value param :data) "joe smith")
</pre>
<p id="33">
you will end up using whatever external format is in the current
locale object (stored in <a href="variables/excl/s_locale_s.htm"><code>*locale*</code></a>). If you want to be sure
to use utf-8 then you would want to bind <a href="variables/excl/s_locale_s.htm"><code>*locale*</code></a> to a locale with a
utf-8 external format:
</p>
<pre id="34">
(let ((*locale* (find-locale "x.utf-8")))
   (setf (ff:fslot-value param :data) "joe smith"))
</pre>
<p id="35">
Another method that retrieves the  external format from the <b>db</b> object
is to do
</p>
<pre id="36">
(with-native-string (s "joe smith" :external-format 
                     (db-external-format db))
   (setf (ff:fslot-value param :data) s))
</pre>
<p id="37">
In this case the string <i>s</i> is dynamic extent. This is fine for
<a href="operators/ff/fslot-value.htm"><b>(setf
ff:fslot-value)</b></a> since it copies the contents of <i>s</i> into
the <i>param</i> object.
</p>
<p id="38">
If you retrieve data with <a href="operators/dbi/loop-over-results.htm"><b>loop-over-results</b></a> and <a href="operators/dbi/rr-sql.htm"><b>rr-sql</b></a> then you should note that this macro and
function now take <i>db</i> keyword argument. You will
want to be sure to pass the <i>db</i> being accessed as
the value of the keyword argument to ensure that the external
format for that database is used for extracting string data.
</p>




<hr><hr><h2 id="39"><a name="using-1">3.0 Using ODBC</a></h2>

<p id="40">
You must load the aodbc-v2 module into Lisp. Do this with
</p>

<pre id="41">
(require :aodbc-v2)
</pre>

<p id="42">
ODBC refers to databases by <em><strong>data source
names</strong></em>. A data source name refers to an entry in a
table that lists which driver is to be used, which database is to be
opened, and certain driver-specific parameters that are to be used
when the database is opened. On Windows data source names are defined
using the ODBC item in the control panel. On Unix data source
names are defined in the <em>.odbc.ini</em> file (although this may be
done differently for different driver manager vendors).
</p>

<p id="43">
Once the connection is made to a database a <em>conversation
</em>ensues in which the application directs the database to do
something and the database responds with the results of that operation
(or signals an error). An application can have more than one
conversation going with a database and the conversations are kept
distinct by using distinct <em>statement handles</em>. When
Allegro ODBC connects to a database it allocates a statement handle
which it calls the default statement handle. This handle is usually
all that's needed for most applications.
</p>

<p id="44">
A conversation consists of the application asking or telling the
database something and the database responding with zero or more rows
of information. Each row returned has the same number of
columns. The database will also return the names for columns
that are named. 
</p>

<p id="45">
An application speaks to a database using the language
<em><strong>sql</strong></em>.  The sql understood by different
databases varies quite a bit. There are two areas of differences: the
data types supported and the sql extensions present. The common
subset of sql supported by all ODBC accessible databases is too weak
to be useful. Therefore you must study the sql manuals for the
databases you plan to access. 
</p>

<hr><hr><h2 id="46"><a name="examples-1">4.0 ODBC examples</a></h2>

<hr><h2 id="47"><a name="simple-example-2">4.1 A simple interaction</a></h2>

<p id="48">
In this example run on Windows we've previously created a data source
name <em><strong>test-db</strong></em> using the ODBC control in
the Control Panel. We start by establishing a connection to
the database with <a href="operators/dbi/connect.htm"><b>connect</b></a>. We
are using the Microsoft Access database which doesn't require us to
supply a user name or password to connect.
</p>

<pre id="49">
user(3): (setf testdb (dbi:connect :data-source-name &quot;test-db&quot;))
#&lt;dbi::odbc-db
     &quot;DSN=test-db;DBQ=C:\\temp\\testdb.mdb;DriverId=25;FIL=MS Access;MaxBufferSize=512;
     PageTimeout=5;&quot; @ #x2089808a&gt;
</pre>

<p id="50">
Next we create a table in the database. Note that we have to pass
the database connection object, <strong>testdb</strong>, to the
<a href="operators/dbi/sql.htm"><b>sql</b></a> function (as the value of
the <em>db</em> keyword argument). If we had set <a href="variables/dbi/s_default-database_s.htm"><code>*default-database*</code></a> to
<strong>testdb</strong> then we wouldn't have to pass in
<strong>testdb</strong>.
</p>

<pre id="51">
user(4): (dbi:sql "create table mytab (i integer)" :db testdb)
nil
</pre>

<p id="52">
Had the <a href="operators/dbi/sql.htm"><b>sql</b></a> statement failed,
an error would have been signaled. 
</p>

<p id="53">
Next we fill the table with ten rows. This isn't the most
efficient way to fill the table, both from the Lisp and ODBC
perspective. Later we'll see examples of parameterized sql
statements that work faster.
</p>

<pre id="54">
user(5): (dotimes (i 10) 
           (dbi:sql (format nil "insert into mytab values(~d)" i) 
                    :db testdb))
nil
</pre>

<p id="55">
Next we query the database and retrieve some of the rows:
</p>

<pre id="56">
user(6): (dbi:sql &quot;select * from mytab where i &lt; 5&quot; :db testdb)
((&quot;0&quot;) (&quot;1&quot;) (&quot;2&quot;) (&quot;3&quot;) (&quot;4&quot;))
(&quot;i&quot;)
</pre>

<p id="57">
There are two defaults at work in this call to <a href="operators/dbi/sql.htm"><b>sql</b></a>. One is that a second value is returned
from the call and that value is a list of the column names describing
the data returned as the first value. If you aren't going to use the
column names then adding <code>:column-names nil</code> to the
call to <a href="operators/dbi/sql.htm"><b>sql</b></a> is a good
idea. The second default is that the values returned by the
database are treated as strings. This is the most general way to
view the database data. If you know ahead of time the types of
the data returned you can have the data returned as other
types. Here we specify that the rows contain integers:</p>

<pre id="58">
user(6):  (dbi:sql &quot;select * from mytab where i &lt; 5&quot; :types '(:int) :db testdb )
((0) (1) (2) (3) (4))
(&quot;i&quot;)
</pre>

<p id="59">
Finally, it's good practice to disconnect from a database when the interaction is over,
using <a href="operators/dbi/disconnect.htm"><b>disconnect</b></a>:
</p>

<pre id="60">
user(7): (dbi:disconnect testdb)
#&lt;dbi::odbc-db
    &quot;DSN=test-db;DBQ=C:\\temp\\testdb.mdb;DriverId=25;FIL=MS Access;
     MaxBufferSize=512;PageTimeout=5;&quot; @ #x207137ca&gt;
user(8): 
</pre>



<hr><h2 id="61"><a name="binding-input-2">4.2 Binding input parameters</a></h2>

<p id="62">
Executing an sql statement is done in three steps: first the sql
statement is parsed by the driver or database server. Next a plan
is created for executing the statement in the database. Finally the
plan is executed and the results returned. The cost of the first two
steps can be eliminated in certain situations through the use of
<em>parameters</em>.  A parameter is denoted by a question mark in an
sql statement and this denotes a value that will be supplied later. A
parameterized sql statement combined with the ability to pre-parse an
sql statement and then repeatedly execute it allows one to effectively
execute different sql statements with no parsing overhead.
</p>

<p id="63">
As an example we'll show two functions that create a table and fill it
with 20,000 rows, each holding a number. The straightforward way
using only <a href="operators/dbi/sql.htm"><b>sql</b></a> is:
</p>

<pre id="64">
(defun param-store-simple (db)
  ;;
  (ignore-errors (dbi:sql "drop table foo12" :db db))
  (dbi:sql "create table foo12 (i int)" :db db)

  (dotimes (i 20000)
     (dbi:sql (format nil "insert into foo12 values (~d)" i) :db db)))
</pre>

<p id="65">The first action this function takes is to create a fresh
table. It does that by first removing the old table if it
exists. If the old table doesn't exist the <strong>drop
table</strong> will signal an error which the <strong>ignore-errors
</strong>will cause to be ignored. Next it creates the new table
and fills the table by building an sql statement for each row
entered. This method is expensive since it allocates a lot of
lisp strings and it causes the database server to have to repeatedly
parse very similar sql statements.</p>

<p id="66">
Now here's a version using parameters, <a href="operators/dbi/prepare-sql.htm"><b>prepare-sql</b></a> and <a href="operators/dbi/run-prepared-sql.htm"><b>run-prepared-sql</b></a> along with <a href="operators/dbi/sql.htm"><b>sql</b></a>:
</p>

<pre id="67">
(defun param-store-fast (db)
  ;;
  (ignore-errors (dbi:sql "drop table foo12" :db db))
  (dbi:sql "create table foo12 (i int)" :db db)

  (dbi:prepare-sql "insert into foo12 values (?)" :db db)
  (let ((par (dbi:bind-parameter 1 nil :int nil :db db)))
     (dotimes (i 20000)
          (setf (ff:fslot-value par :data) i)
          (dbi:run-prepared-sql :db db))))
</pre>

<p id="68">
After creating the fresh table we prepare to execute a
parameterized sql statement for repeated execution. Note the
question mark in the sql statement where the value would
be. Before we can execute this sql statement we must create a
block of memory to hold the parameter's value. This is what <a href="operators/dbi/bind-parameter.htm"><b>bind-parameter</b></a> does. It creates a
block of memory big enough to hold an integer and then binds it to the
one and only parameter of the sql statement. Each time around the
loop we set the value in the parameter memory block and then we call
<a href="operators/dbi/run-prepared-sql.htm"><b>run-prepared-sql</b></a>.
</p>

<p id="69">
Running these two functions against an Informix database, we found
that <strong>param-store-fast</strong> was three times faster than
<strong>param-store-simple</strong> and allocated one quarter of the
lisp heap space.
</p>

<p id="70">
Caution must be exercised when using <a href="operators/dbi/bind-parameter.htm"><b>bind-parameter</b></a>.  The user program must make
sure that the object bound to a parameter is not garbage collected
before the parameter is needed by a call to <a href="operators/dbi/sql.htm"><b>sql</b></a> or <a href="operators/dbi/run-prepared-sql.htm"><b>run-prepared-sql</b></a>. An object stays bound to a
parameter until that parameter is rebound to another object. The
parameter binding is associated with a particular statement handle,
which is usually the default statement handle for the database
accessed.
</p>

<p id="71">
<a href="operators/dbi/bind-parameter.htm"><b>bind-parameter</b></a>
allocates different objects for different types of values. For
integers it allocates an object defined as
</p>

<pre id="72">
(def-foreign-type (odbc-int-param (:accessor odbc-int-param))
    (:struct (data :int)
             (strlen :int)))
</pre>

<p id="73">
The <strong>data</strong> slot is where the value should be stored (as
shown in the example above). The <strong>strlen</strong>
slot is for use by the ODBC interface code and should not be
modified by user code.
</p>

<p id="74">
For floating point parameters <a href="operators/dbi/bind-parameter.htm"><b>bind-parameter</b></a> allocates an object defined as
</p>

<pre id="75">
(def-foreign-type (odbc-double-param (:accessor odbc-double-param))
    (:struct (data :double)
             (strlen :int)))
</pre>

<p id="76">
Note that the <strong>data</strong> field is a double precision
floating point number. The user code must be sure that what it is
storing in this field is a lisp double-float, for example: 
</p>

<pre id="77">
(setf (ff:fslot-value param :data) (float (compute-the-value) 1.0d0)
</pre>

<p id="78">
For string parameters <a href="operators/dbi/bind-parameter.htm"><b>bind-parameter</b></a> allocates one of the set of
foreign data types designed to hold strings. Again the way to store
values into the parameter is an expression like this
</p>

<pre id="79">
(setf (ff:fslot-value param :data) "joe smith")
</pre>



<hr><h2 id="80"><a name="scanning-2">4.3 Scanning through rows</a></h2>

<p id="81">
There are times when it's beneficial to run Lisp code during the
retrieval of rows that result from a query to the database. The
<a href="operators/dbi/rr-sql.htm"><b>rr-sql</b></a> function and <a href="operators/dbi/loop-over-results.htm"><b>loop-over-results</b></a> macros support
this. The <a href="operators/dbi/rr-sql.htm"><b>rr-sql</b></a> function
issues the sql query but does not retrieve the values. The <a href="operators/dbi/loop-over-results.htm"><b>loop-over-results</b></a> macro causes its
body argument to be invoked once per row returned by the
database. Within the body values the column values for that particular
row can be retrieved.
</p>

<p id="82">
One important use for this retrieval method is to run a
Lisp-written predicate over the database. The predicate can
examine just the columns it needs to determine if a row should be
included in the result set. By not examining columns that aren't
needed for the predicate, a large amount of consing of lisp
values can be eliminated.
</p>

<p id="83">
The following is a complete example of the idea mentioned
above. A new table is defined and populated. Then we
retrieve all the rows from the table and return a set that satisfies a
lisp predicate. This predicate cannot be written in sql.
</p>

<pre id="84">
(defun loop-over-example (db)
  
  ;; create a new table 
  (ignore-errors (dbi:sql "drop table loetab" :db db))
  (dbi:sql "create table loetab (a int, b int, c int, d int, e int)" :db db)
  
  ;; fill the table
  (dotimes (i 50)
    (dbi:sql (format nil "insert into loetab values(~d,~d,~d,~d,~d)"
		     i
		     (* 2 i)
		     (* 3 i)
		     (* 4 i)
		     (* 5 i))
	     :db db))
  
  (let ((hstmt (dbi:db-hstmt db)))
    (dbi:rr-sql hstmt (format nil "select * from loetab") :db db)
    
    (let (res)
      (dbi:loop-over-results
       (:db db :hstmt hstmt  :types '(:int :int :int :int :int) :return res)
       
       (let ((a (dbi:column-value 1))
	     (b (dbi:column-value 2)))
          (if* (eql #x40 (logand #x40 (logxor a b))) ;; sample predicate	 
            then ; satisfied, save this row
		 (push (list a b (dbi:column-value 3) (dbi:column-value 4)
			     (dbi:column-value 5))
		       res)))
       ))))
</pre>



<hr><hr><h2 id="85"><a name="char-input-buffers-1">5.0 Character input buffers</a></h2>

<p id="86">
When an sql statement is executed and data is to be returned, Allegro
ODBC assigns buffers to each column and then fetches each row. Some
databases support a character datatype that can be very
long. Unfortunately the ODBC driver doesn't inform Allegro ODBC
just how big the buffers must be in order to read the row data for a
given query. Thus Allegro ODBC just picks an arbitrary sized
buffer (1024 characters, by default). If data is returned that
is too big for the buffer Allegro ODBC is notified and tries to
retrieve it using a different method. This usually succeeds but
it depends on features not found in all ODBC drivers. If Allegro ODBC
can't retrieve the data then it signals the
<strong>dbi:odbc-error-width-too-small</strong> condition. In
that case you'll have to use the <strong>:width</strong> argument
found in many of the functions and macros described below in order to
increase the size of the buffer before a query is done.</p>

<p id="87">The only database we've encountered so far for which Allegro ODBC has to signal the <strong>dbi:odbc-error-width-too-small</strong>
condition is Oracle version 7.</p>

<hr><hr><h2 id="88"><a name="queries-1">6.0 Queries</a></h2>

<p id="89">
Allegro ODBC offers three ways to retrieve data after a select sql
statement is executed. The simplest is to just retrieve all of the
returned rows at once and this is the default behavior of the <a href="operators/dbi/sql.htm"><b>sql</b></a> function. A more complex way of
retrieving results is with <a href="operators/dbi/rr-sql.htm"><b>rr-sql</b></a> and <a href="operators/dbi/loop-over-results.htm"><b>loop-over-results</b></a>. This allows you to abort the
retrieve of all rows at any time. A third way to retrieve row data is
via a <em><strong>query</strong></em> object. A query object is
returned by <a href="operators/dbi/sql.htm"><b>sql</b></a> when the
<em>query</em> keyword is given a true value. A query object can be
asked at any time, by the function <a href="operators/dbi/fetch-row.htm"><b>fetch-row</b></a>, for the next row of data from the
query. There can be multiple query objects active and they can be
accessed in any order.
</p>

<p id="90">
Query objects use resources and should be closed with <a href="operators/dbi/close-query.htm"><b>close-query</b></a> when no longer needed.
</p>

<hr><hr><h2 id="91"><a name="transactions-1">7.0 Transactions</a></h2>

<p id="92">
Normally when a sql statement is executed the results are commited to the
database and other users of the database can view them. 
</p>
<p id="93">
You may wish to execute two or more sql statements before making the results
visible. You may also wish to undo the effects of a sequence of
sql statements. Grouping a sequence of sql statements into a transaction 
allows you to treat the effect of all the statements as one atomic change
to the database which you either cause to occur by commiting the change
or cancel by rolling back the change.
</p>
<p id="94">
In order to use transactions in allegro odbc you must first turn off
the autocommit behavior (connections all start autocommitting),
controlled by the <a href="operators/dbi/set-autocommit.htm"><b>set-autocommit</b></a> function:
</p>
<pre id="95">
(dbi:sql-autocommit nil :db db)
</pre>
<p id="96">
Now you can issue a sequence of sql statements. You'll see the effect
of those statements reflected in the contents of the database but no
other user connected to the database will see them. In order to make
these changes visible to everyone you commit the changes with a call
to <a href="operators/dbi/end-transaction.htm"><b>end-transaction</b></a>:
</p>
<pre id="97">
(dbi:end-transaction :commit :db db)
</pre>
<p id="98">
This ends that transaction and starts a new one.
</p>
<p id="99">
If you decided that you didn't want the changes you've made then 
you can roll them back, again with a call to <a href="operators/dbi/end-transaction.htm"><b>end-transaction</b></a>:
</p>
<pre id="100">
(dbi:end-transaction :rollback :db db)
</pre>
<p id="101">
This form also ends a transaction and starts another.
</p>
<h3 id="102">Notes:</h3>
<ul>
<li id="103">
Some database drivers don't support transactions. Be sure to make
some tests with your database configuration before designing an application
to depend on transactions.
</li>
<li id="104">
In order to implement transactions some databases will lock out access
to rows you've changed but haven't yet committed. Thus transactions
that take a long time can harm the multi-user performance of 
a database application.  
</li>
<li id="105">
Do not use the sql commit and rollback operators in place of <a href="operators/dbi/end-transaction.htm"><b>end-transaction</b></a>. In
certain cirumstances this can confuse the odbc drivers.
</li>
</ul>

<hr><hr><h2 id="106"><a name="references-1">8.0 Reference</a></h2>

<p id="107">
The symbols naming functionality in Allegro ODBC version 2 are in the
dbi package. Each has its own description page. In this section, we
provide brief descriptions (and argument lists for operators) along
with a link to the documentation page.
</p>

<h3 id="108">Operators</h3>

<p id="109">Functions are labeled (f), generic functions (gf), and macros (m).</p>

<table border="1" width="79%">
  <tr>
    <td width="21%"><strong>Name</strong></td>
    <td width="16%"><strong>Argument List</strong></td>
    <td width="46%"><strong>Brief description</strong></td>
    <td width="17%"><strong>See examples</strong></td>
  </tr>
  <tr>
    <td width="21%">
    <a href="operators/dbi/bind-parameter.htm"><b>bind-parameter</b></a>&nbsp;
    <strong>(f)</strong></td>
    <td width="16%"><em>param-num obj type width &key db hstmt</em></td>
    <td width="46%">creates a binding for a parameter for a parameterized sql 
    statement.</td>
    <td width="17%"><a href="#binding-input-2">2</a></td>
  </tr>
  <tr>
    <td width="21%"><a href="operators/dbi/close-query.htm"><b>close-query</b></a>
    &nbsp; <strong>(f)</strong></td>
    <td width="16%"><em>query</em></td>
    <td width="46%">Closes the argument query object (<a href="operators/dbi/sql.htm"><b>sql</b></a>
    returns a query object when the query keyword argument is true).</td>
    <td width="17%"></td>
  </tr>
  <tr>
    <td width="21%"><a href="operators/dbi/connect.htm"><b>connect</b></a> 
    &nbsp;<strong>(f)</strong></td>
    <td width="16%"><em>&key data-source-name user password prompt 
    hwnd width external-format connect-string non-blocking</em></td>
    <td width="46%">establishes a connection to the database denoted 
    by <em>data-source-name</em>
    (a string) and returns a database object.</td>
    <td width="17%"><a href="#simple-example-2">1</a></td>
  </tr>
  <tr>
    <td width="21%"><a href="operators/dbi/db-external-format.htm"><b>db-external-format</b></a>
    &nbsp;<strong>(f)</strong></td> 
    <td width="16%"><em>db</em></td> <td width="46%">return the external
    format used with this database. <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a> can change it.</td> 
    <td width="17%"></td>
  </tr>
  <tr>
    <td width="21%"><a href="operators/dbi/db-hstmt.htm"><b>db-hstmt</b></a> 
    &nbsp;<strong>(gf)</strong></td>
    <td width="16%"><em>db</em></td>
    <td width="46%">returns the default statement handle for this database connection.</td>
    <td width="17%"><a href="#scanning-2">3</a></td>
  </tr>
<tr>
<td width="21%"><a href="operators/dbi/db-non-blocking.htm"><b>db-non-blocking</b></a>
&nbsp;<strong>(f)</strong></td> <td width="16%"><em><small>db</small></em></td> <td width="46%">returns
the value of the non-blocking flag of the database. It can be set with
<strong>(setf db-non-blocking)</strong>.</td> <td width="17%"></td>
</tr>
<tr>
<td width="21%"><a href="operators/dbi/db-width.htm"><b>db-width</b></a> 
&nbsp;<strong>(gf)</strong></td>
<td width="16%"><em><small>db</small></em></td>
<td width="46%">returns the default size for character buffers used to retrieve the
results of sql statements. It can be set with <strong>(setf db-width)</strong>.</td>
<td width="17%"></td>
</tr>
  <tr>
    <td width="21%"><a href="operators/dbi/disconnect.htm"><b>disconnect</b></a> 
    &nbsp;<strong>(f)</strong></td>
    <td width="16%"><em>db</em></td>
    <td width="46%">Close down the given database connection.</td>
    <td width="17%"><a href="#simple-example-2">1</a></td>
  </tr>
  <tr>
    <td width="21%"><a href="operators/dbi/end-transaction.htm"><b>end-transaction</b></a>
    &nbsp;<strong>(f)</strong></td>
    <td width="16%"><em>action &key; db</em></td>
    <td width="46%">Commit or rollback the current transaction when
    <a href="operators/dbi/set-autocommit.htm"><b>set-autocommit</b></a>
     is <code>nil</code>.</td>
    <td width="17%"></td>
  </tr>
  <tr>
    <td width="21%"><a href="operators/dbi/fetch-row.htm"><b>fetch-row</b></a> 
    &nbsp;<strong>(f)</strong></td>
    <td width="16%"><em>query &optional (eof-errorp t) eof-value</em></td>
    <td width="46%">Fetches the next row of query (query objects are 
    returned by <a href="operators/dbi/sql.htm"><b>sql</b></a> when 
    the <em>query</em> keyword argument is
    true). The behavior when there are no more rows is determined 
    by <em>eof-errorp</em> (if
    true, an error is signaled) and <em>eof-value</em> 
    (if <em>eof-errorp</em> is nil, this
    value is returned instead of an error being signaled).</td>
    <td width="17%"></td>
  </tr>
  <tr>
    <td width="21%"><a href="operators/dbi/list-all-database-tables.htm"><b>list-all-database-tables</b></a>
    &nbsp;<strong>(f)</strong></td>
    <td width="16%"><em>&key db hstmt</em></td>
    <td width="46%">Returns (as two values) a list of all the tables in the database and a
    list of the column headers that describe the data.</td>
    <td width="17%"></td>
  </tr>
  <tr>
    <td width="21%"><a href="operators/dbi/list-all-table-columns.htm"><b>list-all-table-columns</b></a>
    &nbsp;<strong>(f)</strong></td>
    <td width="16%"><em>table &key db hstmt</em></td>
    <td width="46%">Returns (as two values) a list of all the columns in the table and a
    list of the column headers that describe the data.</td>
    <td width="17%"></td>
  </tr>
  <tr>
    <td width="21%"><a href="operators/dbi/loop-over-results.htm"><b>loop-over-results</b></a>
    &nbsp; <strong>(m)</strong></td>
    <td width="16%"><em>(&key types column-names 
    do-column-names return hstmt width db)
    &rest body</em></td>
    <td width="46%">After executing a sql statement with 
    <a href="operators/dbi/rr-sql.htm"><b>rr-sql</b></a>, this form loops 
    once for each result
    row, evaluating the <em>body</em>.</td>
    <td width="17%"><a href="#scanning-2">3</a></td>
  </tr>
  <tr>
    <td width="21%"><a href="operators/dbi/prepare-sql.htm"><b>prepare-sql</b></a> 
    &nbsp;<strong>(f)</strong></td>
    <td width="16%"><em>sql-statement &key db hstmt</em></td>
    <td width="46%">Check the <em>sql-statement</em> for errors and prepare for its execution,
    but don't execute the statement.</td>
    <td width="17%"><a href="#binding-input-2">2</a></td>
  </tr>
  <tr>
    <td width="21%"><a href="operators/dbi/rr-sql.htm"><b>rr-sql</b></a> 
    &nbsp;<strong>(f)</strong></td>
    <td width="16%"><em>hstmt sql-statement &key db</em></td>
    <td width="46%">This function runs the <em>sql-statement</em> 
    on the database for which <em>hstmt</em>
    is a statement handle. The keyword argument specifies the database whose
    external format should be used.</td>
    <td width="17%"><a href="#scanning-2">3</a></td>
  </tr>
  <tr>
    <td width="21%"><a href="operators/dbi/run-prepared-sql.htm"><b>run-prepared-sql</b></a> 
    &nbsp;<strong>(f)</strong></td>
    <td width="16%"><em>&key db hstmt row-count width</em></td>
    <td width="46%">Execute the sql statement that was last prepared via <a href="operators/dbi/prepare-sql.htm"><b>prepare-sql</b></a>.</td>
    <td width="17%"><a href="#binding-input-2">2</a></td>
  </tr>
  <tr>
    <td width="21%"><a href="operators/dbi/set-autocommit.htm"><b>set-autocommit</b></a>
    &nbsp;<strong>(f)</strong></td>
    <td width="16%"><em>value &key; db</em></td>
    <td width="46%">Set the value of the autocommit
    option. If true, sql statements commit immediately.
    If <code>nil</code>, sql statements commit only when
    <a href="operators/dbi/end-transaction.htm"><b>end-transaction</b></a> is called (and can
    instead be rolled back).</td>
    <td width="17%"></td>
  </tr>
  <tr>
    <td width="21%"><a href="operators/dbi/sql.htm"><b>sql</b></a> 
    &nbsp;<strong>(f)</strong></td>
    <td width="16%"><em>sql-statement &key db hstmt types query column-names row-count
    width</em></td>
    <td width="46%">This is the primary function for doing 
    database queries and
    modification. The <em>sql-statement</em> is executed on 
    the database and the results are
    returned.</td>
    <td width="17%"><a href="#simple-example-2">1</a>, 
    <a href="#binding-input-2">2</a>, 
    <a href="#scanning-2">3</a></td>
  </tr>
</table>

<h3 id="110">Variables</h3>

<table border="1" width="100%">
  <tr>
    <td width="24%"><a href="variables/dbi/s_auto-trim-strings_s.htm"><code>*auto-trim-strings*</code></a>
    </td>
    <td width="76%">If true, trailing blanks in a returned string are trimmed. Default is t.</td>
  </tr>
  <tr>
    <td width="24%"><a href="variables/dbi/s_default-database_s.htm"><code>*default-database*</code></a>
    </td>
    <td width="76%">The value must be nil or a database returned by 
    connect. If a database, it
    provides the default for some functions needing a database argument, 
    such as <a href="operators/dbi/sql.htm"><b>sql</b></a>.</td>
  </tr>
  <tr>
    <td width="24%"><a href="variables/dbi/s_default-odbc-external-format_s.htm"><code>*default-odbc-external-format*</code></a></td>
    <td width="76%">the default external format to be used for database 
    connections.
    Initially the value is the external format
    returned by evaluating the form <code>(crlf-base-ef
    :latin1)</code> (see <a href="operators/excl/crlf-base-ef.htm"><b>crlf-base-ef</b></a>).</td>
  </tr>
  <tr>
    <td width="24%"><a href="variables/dbi/s_null-value_s.htm"><code>*null-value*</code></a>
    </td>
    <td width="76%">This variable is used to represent null values in a 
    row of values returned
    by a database access (such rows can contain null values). 
    The initial value for
    *null-value* is nil.</td>
  </tr>
</table>

<hr><hr><h2 id="111"><a name="conditions-1">9.0 Conditions</a></h2>

<p id="112">
Errors in ODBC are signaled with the <strong>dbi:odbc-error</strong>
condition. It has these fields:
</p>

<table border="1" width="100%">
  <tr>
    <td width="33%"><big><big>Field</big></big></td>
    <td width="33%"><big><big>Reader</big></big></td>
    <td width="34%"><big><big>Meaning</big></big></td>
  </tr>
  <tr>
    <td width="33%">state</td>
    <td width="33%"><strong>dbi::odbc-diag-state</strong></td>
    <td width="34%">official ODBC error indicator, it is a five character string where the
    first two characters denote the class</td>
  </tr>
  <tr>
    <td width="33%">native-error</td>
    <td width="33%"><strong>dbi::odbc-diag-native-error</strong></td>
    <td width="34%">integer holding the database specific error code</td>
  </tr>
  <tr>
    <td width="33%">message</td>
    <td width="33%"><strong>dbi::odbc-diag-message</strong></td>
    <td width="34%">official ODBC string describing the error </td>
  </tr>
  <tr>
    <td width="33%">action</td>
    <td width="33%"><strong>dbi::odbc-diag-action</strong></td>
    <td width="34%">string describing the context in which the error occurred</td>
  </tr>
</table>

<p id="113">
There is one condition,
<strong>dbi:odbc-error-width-too-small</strong> (a subclass of
<strong>dbi:odbc-error</strong>) which is signaled when data cannot be
extracted from the database because the buffer was too small and the
database does have the ability to send the data in small chunks.
</p>

</body><hr><p id="2"><small>Copyright (c) 1998-2010, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br><small>Documentation for Allegro CL version 8.2. This page was not revised from the 8.1 page.</small><br>
<small>Created 2010.1.21.</small>
<br></p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faqs/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 8.2</b><br><small><a href="introduction.htm#updates-s">Unrevised from 8.1 to 8.2.</a></small><br><a href="http://www.franz.com/support/documentation/8.1/doc/aodbc.htm">8.1 version</a></td></tr></table></html>