<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"> <title>Debugging</title></head><link rel="stylesheet" href="acldoc-styles.css" type="text/css"><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faqs/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 8.2</b><br><small><a href="introduction.htm#updates-s">Unrevised from 8.1 to 8.2.</a></small><br><a href="http://www.franz.com/support/documentation/8.1/doc/debugging.htm">8.1 version</a></td></tr></table><h1 id="2">Debugging</h1><p id="3">This document contains the following sections:</p><a href="#debugging-intro-1">1.0 Introduction</a><br><a href="#debugger-getting-out-1">2.0 Getting out of the debugger</a><br><a href="#internal-funs-1">3.0 Internal functions</a><br><a href="#background-processes-1">4.0 Debugging background processes</a><br><a href="#stack-commands-1">5.0 Stack commands </a><br>&nbsp;&nbsp;&nbsp;<a href="#zoom-2">5.1 :zoom</a><br>&nbsp;&nbsp;&nbsp;<a href="#brief-moderate-verbose-2">5.2 :brief, :moderate, and :verbose modes of :zoom</a><br>&nbsp;&nbsp;&nbsp;<a href="#all-t-nil-2">5.3 :all t and :all nil modes of :zoom</a><br>&nbsp;&nbsp;&nbsp;<a href="#function-t-nil-2">5.4 :function t and :function nil modes of :zoom</a><br>&nbsp;&nbsp;&nbsp;<a href="#specials-t-nil-2">5.5 :specials t and :specials nil modes of :zoom</a><br>&nbsp;&nbsp;&nbsp;<a href="#relative-t-nil-2">5.6 :relative t and :relative nil modes of :zoom</a><br>&nbsp;&nbsp;&nbsp;<a href="#bt-2">5.7 The :bt command for a quick look at the stack</a><br>&nbsp;&nbsp;&nbsp;<a href="#zoom-variables-2">5.8 Variables that affect the behavior of :zoom</a><br>&nbsp;&nbsp;&nbsp;<a href="#special-handling-of-certain-errors-2">5.9 Special handling of certain errors by :zoom</a><br>&nbsp;&nbsp;&nbsp;<a href="#zoom-analogs-2">5.10 :zoom analogs and stack movement commands</a><br>&nbsp;&nbsp;&nbsp;<a href="#hiding-frames-2">5.11 Commands that hide frames</a><br>&nbsp;&nbsp;&nbsp;<a href="#frame-info-2">5.12 Frame information commands</a><br>&nbsp;&nbsp;&nbsp;<a href="#local-variable-evaluation-2">5.13 Local variables and evaluation</a><br>&nbsp;&nbsp;&nbsp;<a href="#programmatic-backtrace-2">5.14 Getting a backtrace programmatically</a><br><a href="#local-variables-1">6.0 Local variables and the debugger</a><br>&nbsp;&nbsp;&nbsp;<a href="#discarding-local-variable-info-2">6.1 Discard local variable information before dumplisp</a><br>&nbsp;&nbsp;&nbsp;<a href="#local-discussion-summary-2">6.2 Summary of the discussion of locals </a><br>&nbsp;&nbsp;&nbsp;<a href="#waht-are-locals-2">6.3 What are local variables?</a><br>&nbsp;&nbsp;&nbsp;<a href="#compiler-treatment-of-locals-2">6.4 How does the compiler treat local variables?</a><br>&nbsp;&nbsp;&nbsp;<a href="#using-registers-vs-using-stack-2">6.5 What is the difference between using registers and using the stack?</a><br>&nbsp;&nbsp;&nbsp;<a href="#live-and-dead-ranges-2">6.6 Live and dead ranges of local variables</a><br>&nbsp;&nbsp;&nbsp;<a href="#locals-in-tail-functions-2">6.7 Locals and functions in the tail position</a><br>&nbsp;&nbsp;&nbsp;<a href="#live-range-example-2">6.8 Example showing live range</a><br>&nbsp;&nbsp;&nbsp;<a href="#locals-debug-one-2">6.9 The debug=1 behavior with locals</a><br>&nbsp;&nbsp;&nbsp;<a href="#locals-debug-two-2">6.10 The behavior with debug=2</a><br>&nbsp;&nbsp;&nbsp;<a href="#locals-debug-one-two-problems-2">6.11 Problem with debug=1 and debug=2 behavior before a local has a value</a><br>&nbsp;&nbsp;&nbsp;<a href="#why-debug-three-2">6.12 Why only have good behavior of locals at debug=3?</a><br>&nbsp;&nbsp;&nbsp;<a href="#debug-three-behavior-2">6.13 The behavior with debug=3 (and speed &lt; 3)</a><br>&nbsp;&nbsp;&nbsp;<a href="#locals-debug-three-speed-three-2">6.14 The behavior with debug=3 and speed=3</a><br>&nbsp;&nbsp;&nbsp;<a href="#want-to-see-dead-locals-2">6.15 I compiled with debug=3 but I want to see dead locals anyway</a><br><a href="#break-on-exit">7.0 Break on exit</a><br><a href="#return-and-restart-1">8.0 :return and :restart</a><br><a href="#ghost-frames-1">9.0 Ghost frames in backtraces</a><br>&nbsp;&nbsp;&nbsp;<a href="#ghost-summary-2">9.1 Summary of the ghost frames section</a><br>&nbsp;&nbsp;&nbsp;<a href="#what-is-ghost-2">9.2 What is a ghost frame?</a><br>&nbsp;&nbsp;&nbsp;<a href="#optimizations-causing-ghost-2">9.3 What kinds of optimizations cause ghost frames?</a><br>&nbsp;&nbsp;&nbsp;<a href="#how-does-debugger-know-about-ghost-2">9.4 How does the debugger know about ghost frames?</a><br>&nbsp;&nbsp;&nbsp;<a href="#displaying-ghost-2">9.5 When will the debugger display ghost frames?</a><br>&nbsp;&nbsp;&nbsp;<a href="#returning-from-ghost-2">9.6 Can I return from or restart a ghost frame?</a><br>&nbsp;&nbsp;&nbsp;<a href="#suspension-points-in-ghost-2">9.7 What do the suspension points (`...') mean in a ghost frame?</a><br>&nbsp;&nbsp;&nbsp;<a href="#no-suspension-points-in-ghost-2">9.8 The ghost frame has no `...'s; are all possible frames displayed?</a><br>&nbsp;&nbsp;&nbsp;<a href="#no-ghost-displayed-2">9.9 No ghost frames are displayed. Do all functions appear on the stack?</a><br>&nbsp;&nbsp;&nbsp;<a href="#ghost-in-brief-2">9.10 Ghost frames in a brief backtrace</a><br>&nbsp;&nbsp;&nbsp;<a href="#turn-off-printing-ghost-2">9.11 Can I turn off printing of ghost frames?</a><br>&nbsp;&nbsp;&nbsp;<a href="#system-functions-and-ghost-2">9.12 Can backtraces involving system functions have ghost frames?</a><br>&nbsp;&nbsp;&nbsp;<a href="#ghost-and-composer-2">9.13 Ghost frames and Allegro Composer</a><br><a href="#tracer-1">10.0 The tracer</a><br>&nbsp;&nbsp;&nbsp;<a href="#tracing-function-objects-2">10.1 Tracing function objects</a><br>&nbsp;&nbsp;&nbsp;<a href="#trace-example-2">10.2 Trace example</a><br>&nbsp;&nbsp;&nbsp;<a href="#tracing-methods-2">10.3 Tracing setf, :before, and :after methods and internal functions</a><br><a href="#stepper-1">11.0 The stepper</a><br>&nbsp;&nbsp;&nbsp;<a href="#turning-stepping-off-2">11.1 Turning stepping off</a><br>&nbsp;&nbsp;&nbsp;<a href="#other-stepping-commands-2">11.2 Other stepping commands and variables</a><br>&nbsp;&nbsp;&nbsp;<a href="#stepping-example-2">11.3 Stepping example</a><br><a href="#ldb-stepper-1">12.0 The Lisp DeBug (ldb) stepper</a><br>&nbsp;&nbsp;&nbsp;<a href="#entering-ldb-stepper-2">12.1 Entering and Exiting the ldb stepper</a><br>&nbsp;&nbsp;&nbsp;<a href="#ldb-functional-interface-2">12.2 Ldb stepper functional interface</a><br>&nbsp;&nbsp;&nbsp;<a href="#ldb-example-2">12.3 Ldb stepping example run</a><br><a href="#source-step-1">13.0 The source stepper</a><br><a href="#gdb-support-1">Appendix A. gdb (or dbx or windbg) interface</a><br><hr><hr><h2 id="4"><a name="debugging-intro-1">1.0 Introduction</a></h2>

<p id="5">
Allegro CL provides a number of facilities for debugging and
correcting Lisp code.  Among these facilities are a set of commands to
view and manipulate the runtime stack, a tracer, a stepper and an
inspector. All are documented in this document except the inspector,
which is documented in <a href="inspector.htm">inspector.htm</a>. 
</p>

<p id="6">
Debugger functionality is included by default in development images
(those built with either the <em>include-debugger</em> or
<em>include-devel-env</em> arguments to <a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a> specified true). If you are
building a runtime image and want debugging capability, be sure to
specify <em>include-debugger</em> true (you cannot specify
<em>include-devel-env</em> true when building a runtime image).  See
<a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a> and
<a href="building-images.htm">building-images.htm</a> for information on
arguments to <a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a>. Note that the stepper is not
permitted in runtime images.
</p>

<p id="7">
A feature in Allegro CL is the ability to debug background
processes in separate Lisp listeners. See <a href="operators/excl/use-background-streams.htm"><b>use-background-streams</b></a> and 
<a href="#background-processes-1">Section 4.0 Debugging background processes</a>
for more information. If you are unable to use the facility described
there, note the following. When multiprocessing is enabled, the user
must be careful to ensure that he or she is debugging the correct
process. The user types to the <i>listener</i> process, and debugs the
<i>focused</i> process. Initially, they are the same process. The
focus is changed only by user action. But if the focus is changed, the
processes will not be the same, and it is important that the user keep
track of which process is being debugged.  Where relevant, the
description of a debugging command specifies how it is used with
multiprocessing. Users who are not using the multiprocessing facility
need not concern themselves with these distinctions. 
</p>

<p id="8">
Note too that debugging compiled code is affected by what
optimizations were in force when the code was compiled. These
optimizations are discussed in <a href="compiling.htm">compiling.htm</a>.
Suffice it to say here that functions compiled for speed over safety
may be harder to debug for the following reasons. 
</p>

<ol>
  <li id="9">Functions may be compiled inline, so it may be hard to figure out where you are,
    comparing what you expect from looking at the source to what you see on the stack. </li>
  <li id="10">The real error may have gone unnoticed and the reported error may occur much later,
    perhaps in a different function. Thus you may notice unexpected arguments to a function
    (resulting in an error) but it may be difficult to discover where these arguments came
    from. </li>
  <li id="11">The error messages themselves may be quite uninformative. This is because errors are not
    caught by type or argument checking, but rather later, system problems.</li>
</ol>

<p id="12">One more point: if an error occurs in code compiled for speed over
safety which is hard to debug, one strategy is to recompile the code
for safety over speed. It should then be easier to correct.</p>

<h3 id="13">
The debugger in an application
</h3>

<p id="14">
You can include much of the debugger (except the stepper) in a runtime
application (see <a href="runtime.htm">runtime.htm</a> for details). Further,
the document <a href="debugger-api.htm">debugger-api.htm</a> provides information
about the internals of the debugger and using it, it is possible to
provide a customized debugging interface. Note that
<a href="debugger-api.htm">debugger-api.htm</a> does not describe things needed in
ordinary use of Allegro CL.
</p>

<hr><hr><h2 id="15"><a name="debugger-getting-out-1">2.0 Getting out of the debugger</a></h2>

<p id="16">Debugger commands are available all the time, so you are never
really in or out of the debugger. When an error occurs, you are put
into a break loop (as indicated by the number in brackets in the
prompt). See <a href="top-level.htm">top-level.htm</a> for complete
details, but briefly, the top-level command <a href="tpl-commands/pop.htm"><b>:pop</b></a> will pop up one break level and the
top-level command <a href="tpl-commands/reset.htm"><b>:reset</b></a> will
return you to the top-level, out of all break levels, as the following
example shows:</p>

<pre id="17">
USER(1): (car 1)
Error: Attempt to take the car of 1 which is not listp.
   [condition type: SIMPLE-ERROR]
[1] USER(2): :reset
USER(3):
</pre>

<hr><hr><h2 id="18"><a name="internal-funs-1">3.0 Internal functions</a></h2>

<p id="19">Users trying to debug code will often have occasion to look at the
stack for a list of recent function calls. Included in the list will
be functions with names like: <strong><em>operator</em>_2op</strong>
and <strong><em>operator</em>_3op</strong> where
<em><strong>operator</strong></em> is a numeric function such as *, +,
&lt;, etc. These functions are used in place of the expected functions
(*, +, &lt;, etc.) for compiler efficiency. They should be interpreted
as the functions named by operator. Thus, for example,
<strong>&lt;_2op</strong> should be interpreted <strong>&lt;</strong>
(i.e. the less-than predicate). </p>

<hr><hr><h2 id="20"><a name="background-processes-1">4.0 Debugging background processes</a></h2>

<p id="21">The background-streams facilities described in this section only
work when Allegro CL has been started with the
<strong>fi:common-lisp</strong> command to Emacs. The Emacs-Lisp
interface is fully described in 
<a href="eli.htm">eli.htm</a>. If you are not running under Emacs
(or if the backdoor connection between Lisp and Emacs has not been
established), you will not get the behavior described here. Note that
it is not an error to use background streams when not running Lisp
under Emacs. The described effect (creating a new listener in another
Emacs buffer) will not happen. But if you later establish the
connection, background streams will be used. The function <a href="operators/excl/use-background-streams.htm"><b>use-background-streams</b></a> is called
automatically when Lisp starts up so it is not necessary to call it
explicitly.  However, you should call it if you do not get the
expected behavior.</p>

<p id="22">If an error occurs in a background process while Allegro Composer
is not running, another listener buffer is created at once and output
from the error is printed in the new listener buffer. To test the
effect of background streams, evaluate the following forms.</p>

<pre id="23">
(fmakunbound 'foo)
  (mp:process-run-function "bad process" 'foo)
</pre>

<p id="24">These forms start a background process that will break and cause a
new listener to be created. A message will be printed to the new
listener saying that a background process has broken due to foo being
undefined.</p>

<p id="25">Background streams work by setting the global values of the
following streams to the background stream:</p>

<pre id="26">
*terminal-io*
*debug-io*
*standard-input*
*query-io*
</pre>


<p id="27">Note that setting the value of those streams has the following
consequences: </p>

<ul>
  <li id="28">The debugger checks to see if <code>*debug-io*</code> is a
    background stream and if so,
    it causes a listener to be created.</li>
  <li id="29">Any attempt to do I/O on those streams results in an error.</li>
</ul>

<p id="30">The second effect is less drastic than it sounds. The existing Lisp
listener (what you see when Lisp starts up) has already bound all the
listed streams so it does not see the global value at all. There may
be a problem if you start your own processes (with, e.g., <a href="operators/mp/process-run-function.htm"><b>process-run-function</b></a>),
however.  You should (and all applications should) set up your own
streams. Consider the following two examples. In the first, the
function run by <a href="operators/mp/process-run-function.htm"><b>process-run-function</b></a> takes a stream
argument and is passed <code>*terminal-io*</code>. This will work
without error. In the second, the function itself contains a reference
to <code>*terminal-io*</code>. It will signal an error if background
streams are used.</p>

<pre id="31">
;;; This will work:
(mp:process-run-function
      "foo"
      #'(lambda (stream)
          (format stream "This is from process ~a~%"
                  mp:*current-process*))
      *terminal-io*)
;;; This will fail:
(mp:process-run-function
      "foo"
      #'(lambda ()
          (format *terminal-io* "This is from process ~a~%"
          mp:*current-process*)))
</pre>

<p id="32">The variable <a href="variables/excl/s_initial-terminal-io_s.htm"><code>*initial-terminal-io*</code></a> holds the original
<code>*terminal-io*</code> stream when Lisp starts up. It may be
useful for processes that aren't connected to a usable
<code>*terminal-io*</code> but wish to produce some output, for
example for debugging. </p>

<hr><hr><h2 id="33"><a name="stack-commands-1">5.0 Stack commands </a></h2>

<p id="34">The <i>runtime stack</i> is the entity where arguments and
variables local to Lisp functions are stored. When a function is
called, the calling function evaluates and <i>pushes</i> the arguments
to the called function onto the stack. The called function then
references the stack when accessing its arguments. It also allocates
space for its local variables. A <i>stack frame</i> is the area on the
stack where the arguments to one function call and also its local
variables reside. If <b>foo</b> calls <b>bar</b>, which in turns calls
<b>yaf</b>, then (at least, and typically) three stack frames are
<i>active</i> when <b>yaf</b> is entered. The frame for the most
recently called function is on the <i>top</i> of the stack. The
commands described in the following subsections access and display the
stack.  After a frame is examined, it normally becomes the <i>current
stack frame</i>. Further reference to the stack will, by default,
operate on the current stack frame. When a break level is entered, the
current frame pointer is typically the first interesting frame.</p>

<p id="35">A <em>frame object</em> is a type of Lisp object. A <em>frame
expression</em> is the printed representation of that object. We are
somewhat imprecise in this document in distinguishing between frame
objects (the internal Lisp object) and frame expressions (what you see
printed) because in most cases, the distinction is not
important. Where the distinction is important, we say <em>frame
object</em> or <em>frame expression</em>.</p>

<hr><h2 id="36"><a name="zoom-2">5.1 :zoom</a></h2>

<p id="37">The <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> top-level command
prints the evaluation stack. It uses the current stack frame as the
center of attention, and prints some number of frames on either side
of the current frame. The value of the variable <a href="variables/tpl/s_zoom-display_s.htm"><code>*zoom-display*</code></a> is the
total number of frames to display, and an equal number of frames are
printed above and below the current stack frame, if possible. The
arguments to the <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> command
control the type and quantity of the displayed stack. </p>

<p id="38">
After a <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> or any of its
analogs (such as <a href="tpl-commands/top.htm"><b>:top</b></a> or <a href="tpl-commands/bottom.htm"><b>:bottom</b></a>) the special variable
<code>cl:*</code> contains the lisp expression representing the
current frame. That expression is approximately what is shown in a
moderate display with <code>:function</code> 
&nbsp;<code>nil</code>, regardless of the mode in which <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> itself displays.
</p>

<p id="39">
Here are some examples of <a href="tpl-commands/zoom.htm"><b>:zoom</b></a>
command calls. We cause an error by trying to evaluate
<code>foo</code>, which has no value.</p>

<pre id="40">
USER(1): foo
Error: Attempt to take the value of the unbound variable `FOO'.
  [condition type: UNBOUND-VARIABLE]
[1] USER(2):
</pre>



<hr><h2 id="41"><a name="brief-moderate-verbose-2">5.2 :brief, :moderate, and :verbose modes of :zoom</a></h2>

<p id="42">These arguments to <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> (only
one can be specified true and that value controls further <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> commands until a new value is
specified) control the amount of information printed. </p>

<p id="43">In <code>:brief</code> mode, only the function name is displayed
for each frame and more than one frame is displayed on a single
line. The current frame (EVAL) is displayed on its own line.</p>

<pre id="44">
[1] USER(2): :zoom :brief t
Evaluation stack:

  ERROR &lt;-
EVAL &lt;-
 TPL:TOP-LEVEL-READ-EVAL-PRINT-LOOP &lt;- TPL:START-INTERACTIVE-TOP-LEVEL &lt;-
</pre>

<p id="45">In <code>:moderate</code> mode, each frame is on its own line and
the function name and arguments appear.</p>

<pre id="46">
[1] USER(3): :zoom :moderate t
Evaluation stack:

 (ERROR UNBOUND-VARIABLE :NAME ...)
-&gt;(EVAL FOO)
 (TPL:TOP-LEVEL-READ-EVAL-PRINT-LOOP)
 (TPL:START-INTERACTIVE-TOP-LEVEL
 #&lt;EXCL::BIDIRECTIONAL-TERMINAL-STREAM @ #x18ad06&gt;
 #&lt;Function TOP-LEVEL-READ-EVAL-PRINT-LOOP @ #x2df9de&gt; ...)
</pre>

<p id="47">In <code>:verbose</code> mode, several lines are used per frame and
much more information about arguments is provided.</p>

<pre id="48">
[1] USER(4): :zoom :verbose t
Evaluation stack:
 
   call to ERROR
required arg: EXCL::DATUM = UNBOUND-VARIABLE
&amp;rest EXCL::ARGUMENTS = (:NAME FOO :FORMAT-CONTROL ...)
function suspended at relative address 600
 
-&gt;call to EVAL
required arg: EXP = FOO
function suspended at relative address 212
 
   call to TPL:TOP-LEVEL-READ-EVAL-PRINT-LOOP
function suspended at relative address 692
 
   call to TPL:START-INTERACTIVE-TOP-LEVEL
required arg: *TERMINAL-IO* = #&lt;EXCL::BIDIRECTIONAL-TERMINAL-STREAM @ #x18ad06&gt;
required arg: FUNCTION = #&lt;Function TOP-LEVEL-READ-EVAL-PRINT-LOOP @ #x2df9de&gt;
required arg: TPL::ARGS = NIL
&amp;key TPL::INITIAL-BINDINGS = :UNSUPPLIED
function suspended at relative address 468
 
[1] USER(5):
</pre>

<p id="49">Note that in verbose mode, each frame specifies the location at
which the function was suspended:</p>

<pre id="50">
  call to ERROR
required arg: EXCL::DATUM = UNBOUND-VARIABLE
&rest EXCL::ARGUMENTS = (:NAME FOO :FORMAT-CONTROL ...)
function suspended at relative address 600
</pre>

<p id="51">The suspension location may be relative or absolute (it is relative
in the example just shown). It represents the value of the program
counter at the time the function was suspended (usually because it
called another function). The suspension location may be the
instruction that caused the suspension (a call instruction or an
instruction that caused trapping) or it may be the next instruction to
be executed when the function is reactivated. </p>

<p id="52">Suspension locations are interpreted as follows: </p>

<ul>
  <li id="53"><strong>Relative</strong>: a relative address is the distance from the start of the
    function's codevector. It can be seen by disassembling the function with <a href="../ansicl/dictentr/disassem.htm"><b>disassemble</b></a>
    with the absolute keyword argument <code>nil</code> (see <a href="implementation.htm">implementation.htm</a>
    for information on <a href="../ansicl/dictentr/disassem.htm"><b>disassemble</b></a>). The leftmost column of the
    disassembly shows the relative address of each instruction in bytes. Relative addresses
    are needed for Lisp functions because their codevectors may move so the actual address of
    a particular function may change after a garbage collection. </li>
  <li id="54"><strong>Absolute</strong>: an absolute address is an address that will not change within
    the current Lisp process execution. Absolute addresses will be given when a frame
    represents a runtime operation. Examples of runtime operations are calls to <a href="../ansicl/dictentr/apply.htm"><b>apply</b></a>
    and <a href="../ansicl/dictentr/funcall.htm"><b>funcall</b></a> , which are written in low-level lisp-assembler code.</li>
</ul>

<p id="55">When a runtime operation is encountered in
<code>:verbose</code> mode, a symbol-table is built (if an
up-to-date one does not already exist) if possible. This build may
take some time and trigger several garbage collections. After the
symbol table is built, the address is associated with a name in the table
and printed as its offset. </p>

<p id="56">If the symbol table cannot be built, then no interpretation is
given to the suspension location, only the absolute address is
shown. Here is an example from the verbose backtrace following the
attempt to evaluate an unbound variable:</p>

<pre id="57">
----------------------------
 -&gt;call to SYS::..CONTEXT-SAVING-RUNTIME-OPERATION with 0 arguments.
function suspended at address #x6fa1b1d0 (unbound+404)
</pre>

<p id="58">Note that any non-lisp function can be disassembled (with <a href="../ansicl/dictentr/disassem.htm"><b>disassemble</b></a>) if it is represented in
the symbol table by the string associated with its name. Thus</p>

<pre id="59">
(cl:disassemble "qcons")
</pre>

<p id="60">will print the disassembly of the runtime operation
"qcons". If the name is not in the symbol table,
cl:disassemble will complain that the argument is invalid.</p>



<hr><h2 id="61"><a name="all-t-nil-2">5.3 :all t and :all nil modes of :zoom</a></h2>

<p id="62">Using the same error as above (trying to evaluate
<code>foo</code>, which is unbound), here is the difference
between specifying <code>:all t</code> and <code>:all
nil</code> as arguments to <a href="tpl-commands/zoom.htm"><b>:zoom</b></a>. The frames hidden by default are
those specified by default by <a href="tpl-commands/hide.htm"><b>:hide</b></a>.</p>

<pre id="63">
[1] USER(5): :zoom :all nil :moderate t
Evaluation stack:
 
  (ERROR UNBOUND-VARIABLE :NAME ...)
-&gt;(EVAL FOO)
  (TPL:TOP-LEVEL-READ-EVAL-PRINT-LOOP)
  (TPL:START-INTERACTIVE-TOP-LEVEL
     #&lt;EXCL::BIDIRECTIONAL-TERMINAL-STREAM @ #x18ad06&gt;
     #&lt;Function TOP-LEVEL-READ-EVAL-PRINT-LOOP @ #x2df9de&gt; ...)
[1] USER(6): :zoom :all t
Evaluation stack:
 
... 1 more newer frame ...
 
  (ERROR UNBOUND-VARIABLE :NAME ...)
  (EXCL::UNBOUND-VARIABLE-HANDLER FOO)
  (EXCL::ER-GENERAL-ERROR-HANDLER-ONE 5 FOO)
  (EXCL::%EVAL FOO)
-&gt;(EVAL FOO)
  (TPL::READ-EVAL-PRINT-ONE-COMMAND NIL NIL)
  (EXCL::READ-EVAL-PRINT-LOOP :LEVEL 0)
  (TPL::TOP-LEVEL-READ-EVAL-PRINT-LOOP1)
  (TPL:TOP-LEVEL-READ-EVAL-PRINT-LOOP)
 
... more older frames ...
[1] USER(7):
</pre>



<hr><h2 id="64"><a name="function-t-nil-2">5.4 :function t and :function nil modes of :zoom</a></h2>

<p id="65">The difference between specifying the <code>:function</code>
argument to <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> &nbsp;<code>t</code> or <code>nil</code> can be shown by one
frame, so we have removed all but one displayed frame. With
<code>:function t</code>, the exact function object is
identified.</p>

<pre id="66">
[1] USER(7): :zoom :function t
Evaluation stack: [note: some lines removed]
 
-&gt;(FUNCALL #&lt;Function EVAL @ #x1216d6&gt; FOO)
 
[1] USER(8): :zoom :function nil
Evaluation stack: [note: some lines removed]
 
-&gt;(EVAL FOO)
</pre>



<hr><h2 id="67"><a name="specials-t-nil-2">5.5 :specials t and :specials nil modes of :zoom</a></h2>

<p id="68">The difference between specifying the <code>:specials</code>
argument to <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> &nbsp;<code>t</code> or <code>nil</code> can be shown with
one frame so some printed material is deleted. With <code>:specials
t</code>, the names and values of specials associated with the
frame are shown.</p>

<pre id="69">
[1] USER(10): :zoom :specials t
Evaluation stack: [note: some lines removed]
 
-&gt;(EVAL FOO)
     EXCL::%VENV% = NIL
     EXCL::%FENV% = NIL
     EXCL::%BENV% = NIL
     EXCL::%GENV% = NIL
     EXCL::%FUNCTION-SPEC% = NIL
</pre>

<p id="70">The stack with <code>:specials nil</code> only shows the
stack frame:</p>

<pre id="71">
[1] USER(11): :zoom :specials nil
Evaluation stack: [note: some lines removed]
 
-&gt;(EVAL FOO)
</pre>



<hr><h2 id="72"><a name="relative-t-nil-2">5.6 :relative t and :relative nil modes of :zoom</a></h2>

<p id="73">The <code>:relative</code> argument causes <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> to identify a frame with respect to
the current frame. The identification is done with a number and either
`u' (meaning up or newer than the current frame) or `d' (meaning down
or older than the current frame).</p>

<pre id="74">
[1] USER(18): :zoom :relative t
Evaluation stack:
 
1u: (ERROR UNBOUND-VARIABLE :NAME ...)
   -&gt;(EVAL FOO)
1d: (TPL:TOP-LEVEL-READ-EVAL-PRINT-LOOP)
2d: (TPL:START-INTERACTIVE-TOP-LEVEL
        #&lt;EXCL::BIDIRECTIONAL-TERMINAL-STREAM @
#x18ad06&gt;
               
...)
</pre>

<p id="75">The stack with :relative <code>nil</code> does not
display numbers next to frames.</p>

<pre id="76">
[1] USER(18): :zoom :relative nil
Evaluation stack:
 
  (ERROR UNBOUND-VARIABLE :NAME ...)
-&gt;(EVAL FOO)
  (TPL:TOP-LEVEL-READ-EVAL-PRINT-LOOP)
  (TPL:START-INTERACTIVE-TOP-LEVEL
     #&lt;EXCL::BIDIRECTIONAL-TERMINAL-STREAM @ #x18ad06&gt; ...)
</pre>



<hr><h2 id="77"><a name="bt-2">5.7 The :bt command for a quick look at the stack</a></h2>

<p id="78">The <a href="tpl-commands/bt.htm"><b>:bt</b></a> command provides a
quick way to scan the stack.</p>

<p id="79">Here is the effect of the <a href="tpl-commands/bt.htm"><b>:bt</b></a>
command on the example above (attempt to evaluate foo which has no
value). In this case, <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> is
printing all frames (:all t) so <a href="tpl-commands/bt.htm"><b>:bt</b></a> does as well.</p>

<pre id="80">
[1] USER(24): :bt
Evaluation stack:
 
EVAL &lt;-
  TPL::READ-EVAL-PRINT-ONE-COMMAND &lt;- 
  EXCL::READ-EVAL-PRINT-LOOP &lt;-
  TPL::TOP-LEVEL-READ-EVAL-PRINT-LOOP1 &lt;-
  TPL:TOP-LEVEL-READ-EVAL-PRINT-LOOP &lt;- APPLY &lt;-
  TPL:START-INTERACTIVE-TOP-LEVEL &lt;- TPL::START-TOP-LEVEL &lt;-
  EXCL::START-REBORN-LISP
</pre>



<hr><h2 id="81"><a name="zoom-variables-2">5.8 Variables that affect the behavior of :zoom</a></h2>

<p id="82">
The following variables affect the behavior of <a href="tpl-commands/zoom.htm"><b>:zoom</b></a>, usually by providing a default for
an argument to <a href="tpl-commands/zoom.htm"><b>:zoom</b></a>. Note that
the values of some of these variables are changed when <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> is called with the argument
associated with the variable specified. All symbols naming the
variables are in the <code>top-level</code> package (nicknamed
<code>tpl</code>).
</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="638">
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><a href="variables/tpl/s_zoom-display_s.htm"><code>*zoom-display*</code></a></td>
    <td WIDTH="50%" VALIGN="TOP">Controls the maximum number of stack frames displayed by a
    call to <a href="tpl-commands/zoom.htm"><b>:zoom</b></a>. Default for the <code>:count</code>
    argument for <a href="tpl-commands/zoom.htm"><b>:zoom</b></a>.</td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><a href="variables/tpl/s_zoom-print-circle_s.htm"><code>*zoom-print-circle*</code></a></td>
    <td WIDTH="50%" VALIGN="TOP"><code>cl:*print-circle*</code> is bound to this during <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> output.</td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><a href="variables/tpl/s_zoom-print-level_s.htm"><code>*zoom-print-level*</code></a></td>
    <td WIDTH="50%" VALIGN="TOP"><code>cl:*print-level*</code> is bound to this during <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> output.</td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><a href="variables/tpl/s_zoom-print-length_s.htm"><code>*zoom-print-length*</code></a></td>
    <td WIDTH="50%" VALIGN="TOP"><code>cl:*print-length*</code> is bound to this during <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> output.</td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><a href="variables/tpl/s_zoom-print-special-bindings_s.htm"><code>*zoom-print-special-bindings*</code></a></td>
    <td WIDTH="50%" VALIGN="TOP">Default for the <code>:specials</code> argument to <a href="tpl-commands/zoom.htm"><b>:zoom</b></a>. Value reset if <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> is called with :specials specified.</td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><a href="variables/tpl/s_zoom-show-newer-frames_s.htm"><code>*zoom-show-newer-frames*</code></a></td>
    <td WIDTH="50%" VALIGN="TOP">If true, <a href="tpl-commands/zoom.htm"><b>:zoom</b></a>
    output shows frames newer than the current frame.</td>
  </tr>
  <tr>
    <td WIDTH="50%" VALIGN="TOP"><a href="variables/tpl/s_auto-zoom_s.htm"><code>*auto-zoom*</code></a></td>
    <td WIDTH="50%" VALIGN="TOP">Controls whether frames are printed after moving up or down a
    frame or displaying the current frame (see :up, :dn, and :current).</td>
  </tr>
</table>



<hr><h2 id="83"><a name="special-handling-of-certain-errors-2">5.9 Special handling of certain errors by :zoom</a></h2>

<p id="84">Here is how calls to undefined functions and calls with the wrong
number of arguments, both in compiled code, are handled. </p>

<p id="85">If, in compiled code, a call is made to an undefined function
<b>foo</b>, a frame on the stack will be
created to represent that call and it will show all of the arguments
passed to <b>foo</b>.</p>

<p id="86">For example:</p>

<pre id="87">
user(4): (defun bar (x) (foo 1 2 3 4 x))
bar
user(5): (compile 'bar)
compiling bar
user(6): (bar 222)
Error: the function foo is undefined.
  [condition type: undefined-function]
 
Restart actions (select using :continue):
  0: Try calling foo again
  1: Return a value instead of calling foo
  2: Try calling a function other than foo
  3: Setf the symbol-function of foo and call it again
[1] user(7): :zoom
Evaluation stack:
 
  (error #&lt;undefined-function @ #x10b9a86&gt;)
-&gt;(foo 1 2 ...)
  (bar 222)
  (eval (bar 222))
  (tpl:top-level-read-eval-print-loop)
  (tpl:start-interactive-top-level
      #&lt;excl::bidirectional-terminal-stream @ #x2aa24e&gt;
      #&lt;Function top-level-read-eval-print-loop @ #x2d96de&gt;
...)
[1] user(8): :cur
(foo 1 2 3 4 222)
[1] user(9):
</pre>

<p id="88">This frame can be restarted after defining foo:</p>

<pre id="89">
[1] user(10): (defun foo (&rest x) x)
foo
[1] user(11): :cur
(foo 1 2 3 4 222)
[1] user(12): :restart 
(1 2 3 4 222)
user(13):
</pre>

<p id="90">In the wrong number of arguments situation (in our case, too few
arguments) we again get an ordinary frame with the unsupplied
arguments identified as <code>:unknown</code>:</p>

<pre id="91">
USER(14): (defun baz (a b c)
            (+ a b c))
BAZ
USER(15): (compile 'baz)
BAZ
NIL
NIL
USER(16): (baz 1 2)
Error: BAZ got 2 args, wanted 3 args.
  [condition type: PROGRAM-ERROR]
[1] USER(17): :zo
Evaluation stack:
 
  (ERROR PROGRAM-ERROR :FORMAT-CONTROL ...)
-&gt;(BAZ 1 2 :UNKNOWN)
  (EVAL (BAZ 1 2))
  (TPL:TOP-LEVEL-READ-EVAL-PRINT-LOOP)
  (TPL:START-INTERACTIVE-TOP-LEVEL
       #&lt;EXCL::BIDIRECTIONAL-TERMINAL-STREAM @
#x487586&gt;
       #&lt;Function TOP-LEVEL-READ-EVAL-PRINT-LOOP @
#x49114e&gt; ...)
[1] USER(18):
</pre>



<hr><h2 id="92"><a name="zoom-analogs-2">5.10 :zoom analogs and stack movement commands</a></h2>

<p id="93">The following commands are used to move the current frame pointer
around the stack.</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="638">
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/dn.htm"><b>:dn</b></a></td>
    <td WIDTH="67%" VALIGN="TOP">Move down the stack</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/up.htm"><b>:up</b></a></td>
    <td WIDTH="67%" VALIGN="TOP">Move up the stack.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/bottom.htm"><b>:bottom</b></a></td>
    <td WIDTH="67%" VALIGN="TOP">Move to the bottom (oldest frame) of the stack.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/top.htm"><b>:top</b></a></td>
    <td WIDTH="67%" VALIGN="TOP">Move to the top (newest frame) of the stack.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/find.htm"><b>:find</b></a></td>
    <td WIDTH="67%" VALIGN="TOP">Move to the frame associated with the <i>function-name</i>
    argument to this command.</td>
  </tr>
</table>



<hr><h2 id="94"><a name="hiding-frames-2">5.11 Commands that hide frames</a></h2>

<p id="95">These commands control which frames are displayed. Note that their
effect can be overridden by calling <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> with the :all argument specified
<code>t</code>.</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="638">
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/hide.htm"><b>:hide</b></a></td>
    <td WIDTH="67%" VALIGN="TOP">Hide (i.e. <a href="tpl-commands/zoom.htm"><b>:zoom</b></a>
    should not display unless :all is specified t) things specified by the arguments.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><a href="tpl-commands/unhide.htm"><b>:unhide</b></a></td>
    <td WIDTH="67%" VALIGN="TOP">Unhide (i.e. <a href="tpl-commands/zoom.htm"><b>:zoom</b></a>
    with :all <code>nil</code> should display) things specified by the arguments. <strong>:unhide</strong>
    called with no arguments causes the list of hidden objects to revert to the default set of
    hidden objects. Note that if you want to see all frames in the stack, you should call <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> with a true value for
    the <em>all</em> argument. <strong>:unhide</strong> itself is not designed to unhide all
    frames.</td>
  </tr>
</table>

<pre id="96">
;; In this example we hide all frames in the tpl package.
USER(66): :unhide
Reverting hidden objects to initial state.
USER(67): :hide
hidden packages: LEP EXCL SYSTEM CLOS DEBUGGER
hidden packages internals: TOP-LEVEL
hidden functions: BLOCK APPLY
hidden frames: :INTERPRETER :EVAL :INTERNAL
;;
;; We cause a BREAK and do a :zoom.
USER(68): (break)
Break: call to the `break' function.
 
Restart actions (select using :continue):
  0: return from break.
[1c] USER(69): :zoom :moderate t
Evaluation stack:
 
  (BREAK &quot;call to the `break' function.&quot;)
-&gt;(EVAL (BREAK))
  (TPL:TOP-LEVEL-READ-EVAL-PRINT-LOOP)
  (TPL:START-INTERACTIVE-TOP-LEVEL
      #&lt;EXCL::BIDIRECTIONAL-TERMINAL-STREAM @ #x19e67e&gt;
      #&lt;Function TOP-LEVEL-READ-EVAL-PRINT-LOOP @ #x1c7ad6&gt;
...)
;;
;; We hide all symbols in the TOP-LEVEL package.
[1c] USER(70): :hide :package tpl
[1c] USER(71): :zoom
Evaluation stack:
 
  (BREAK &quot;call to the `break' function.&quot;)
-&gt;(EVAL (BREAK))
[1c] USER(72):
</pre>



<hr><h2 id="97"><a name="frame-info-2">5.12 Frame information commands</a></h2>

<p id="98">The following commands identify the current frame and the function
called by the current frame.</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="638">
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><a href="tpl-commands/current.htm"><b>:current</b></a></td>
    <td WIDTH="64%" VALIGN="TOP">Print the current stack frame and set the value of <code>cl:*</code>
    to be the frame expression.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><a href="tpl-commands/function.htm"><b>:function</b></a></td>
    <td WIDTH="64%" VALIGN="TOP">Print the function object called in the current stack frame
    and set the value of <code>cl:*</code> to that object.</td>
  </tr>
  <tr>
    <td WIDTH="36%" VALIGN="TOP"><a href="tpl-commands/frame.htm"><b>:frame</b></a></td>
    <td WIDTH="64%" VALIGN="TOP">Print out information about the current frame.</td>
  </tr>
</table>

<pre id="99">
;; In the example below, we use :current, :function and :frame. 
;; Note that we use :hide :binding to limit the amount of output 
;; printed in this example.
user(47): (defun foo (x)
            (let ((a (1+ x)))
              (let ((b
(1+ a)))
               
(progn (break &quot;foo: ~a&quot; b)
                      
(foo 1 2 3 4 5 x a b)))))
foo
 
;; :hide :binding causes binding frames to be hidden.
user(48): :hide :binding
user(49): (foo 10)
Break: foo: 12
 
Restart actions (select using :continue):
  0: return from break.
[1c] user(50): :zoom
Evaluation stack:
 
  (break &quot;foo: ~a&quot; 12)
-&gt;(foo 10)
  (eval (foo 10))
  (tpl:top-level-read-eval-print-loop)
  (tpl:start-interactive-top-level
      #&lt;excl::bidirectional-terminal-stream @ #x280886&gt;
      #&lt;Function top-level-read-eval-print-loop @ #x2ce19e&gt;
...)
;;
;; Print out the current frame.
[1c] user(51): :current
(foo 10)
 
;; Print out the function object associated with the 
;; current frame.
[1c] user(52): :function
#&lt;Interpreted Function foo @ #xaf983e&gt;
 
;; Print out interesting information about the frame. Note 
;; that the information printed included frames hidden by the
;; :hide :binding command
[1c] user(53): :frame
Expression: (foo 10)
  Source code: (let ((a (1+ x))) ..)
  Local x: 10
  Source code: (let ((b (1+ a))) ..)
  Local a: 11
  Source code: (progn (break &quot;foo: ~a&quot; b) (foo 1 2 3 4 5 x a b))
  Local b: 12
[1c] user(54): :res
user(55): 
</pre>



<hr><h2 id="100"><a name="local-variable-evaluation-2">5.13 Local variables and evaluation</a></h2>

<p id="101">
The commands described in this section operate in some fashion on
frames. Note that local name information (which is very useful for
debugging) is only loaded from a compiled file if the variable <a href="variables/excl/s_load-local-names-info_s.htm"><code>*load-local-names-info*</code></a> is
non-<code>nil</code> when the compiled (fasl) file is
loaded.
</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="638">
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><a href="tpl-commands/local.htm"><b>:local</b></a></td>
    <td WIDTH="68%" VALIGN="TOP">This command causes the values of local variables for the
    current stack frame to be printed. The handling of local variables by the debugger is
    discussed under the heading 
    <a href="#local-variables-1">Section 6.0 Local variables and the debugger</a>
    below for complete information and examples.</td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><a href="tpl-commands/set-local.htm"><b>:set-local</b></a></td>
    <td WIDTH="68%" VALIGN="TOP">This command sets the value of the specified (as an argument)
    local variable to value, which is evaluated. The local variable is identified by name if
    interpreted, or name or index if compiled.</td>
  </tr>
  <tr>
    <td WIDTH="32%" VALIGN="TOP"><a href="tpl-commands/evalmode.htm"><b>:evalmode</b></a></td>
    <td WIDTH="68%" VALIGN="TOP">This command allows evaluation in context, that is local
    variables can be used by name in forms typed to the top level. Setting such a local
    variable (with <a href="../ansicl/dictentr/setq.htm"><b>setq</b></a> or <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a>) at the top level will
    change the value in the frame. Evaluation in context does not always
    work as desired (unavoidably so because of the lexically-scoped 
    design of Lisp). It should only be used temporarily while debugging.</td>
  </tr>
</table>




<hr><h2 id="102"><a name="programmatic-backtrace-2">5.14 Getting a backtrace programmatically</a></h2>

<p id="103">
Sometimes, particularly when a program is being run in batch mode
(rather than interactively) or when the user of the program is not
familiar with Lisp internals, you may want to generate a backtrace (as
produced by <a href="tpl-commands/zoom.htm"><b>:zoom</b></a>)
programmatically, perhaps writing it to a file as part of a problem
report.
</p>

<p id="104">
Functionality for doing this is in the autozoom module, with symbols
in the <code>top-level.debug</code> package. Load this module
with the command
</p>
<pre id="105">
(require :autozoom)
</pre>
<p id="106">
If you want this functionality in an application, be sure to include
:autozoom in the list of required files (the third required argument
to <a href="operators/excl/generate-application.htm"><b>generate-application</b></a>).
</p>
<p id="107">
There are two operators provided: the macro <a href="debugging.htm#with-auto-zoom-and-exit-op-bookmarkxx"><b>with-auto-zoom-and-exit</b></a> and the
function <a href="debugging.htm#zoom-op-bookmarkxx"><b>zoom</b></a>. Both are defined in this
section.  The source for <b>with-auto-zoom-and-exit</b> is available
in the file <em>[Allegro directory]/src/autozoom.cl</em>.
</p>

<hr><h3 id="108"><a name="zoom-op-bookmarkxx"></a>zoom</h3><h3 id="109">Function</h3><h4 id="110">Package: top-level.debug</h4>

<p id="111"><b>Arguments: </b><i>
stream </i> &amp;rest <i>zoom-command-args</i><i>
</i>&amp;key  (<i>count</i> t) (<i>all</i> t)<i>
 &amp;allow-other-keys
</i></p>

<p id="112">
Generate an execution stack trace to
<b><i>stream</i></b>. This function is a wrapper for the
top-level <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> command and is
intended to be used in applications that want to report unexpected
errors. See <a href="debugging.htm#with-auto-zoom-and-exit-op-bookmarkxx"><b>with-auto-zoom-and-exit</b></a>.
</p>
<p id="113">
This function is only useful when used in conjunction with <a href="../ansicl/dictentr/handler0.htm"><b>handler-bind</b></a>.  For example:
</p>

<pre id="114">
 (handler-bind
    ((error (lambda (condition)
	      ;; write info about CONDITION to a log file...
              (format *log-stream* \"Error in app: ~a~%\" condition)

	      ;; send a zoom to the log file, too
	      (top-level.debug:zoom *log-stream*))))
  (application-init-function))
</pre>

<p id="115">
The <b><i>count</i></b> and
<b><i>all</i></b> keywords are passed to the <a href="tpl-commands/zoom.htm"><b>:zoom</b></a>
command and are documented with that command.
</p>

<hr>

<hr><h3 id="116"><a name="with-auto-zoom-and-exit-op-bookmarkxx"></a>with-auto-zoom-and-exit</h3><h3 id="117">Macro</h3><h4 id="118">Package: top-level.debug</h4>

<p id="119"><b>Arguments: </b><i>
(place </i>&amp;key  (<i>count</i> t) (<i>all</i> t) (<i>exit</i> t)<i> no-unwind</i><i>)
</i> &amp;body <i>body</i><i>
</i></p>

<p id="120">
This macro generates an execution stack trace to
<b><i>place</i></b>, which can be a stream, <code>t</code> or a pathname. If a pathname, that file is opened,
created or superseded as necessary, and used. This macro is a wrapper
for top-level <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> command and is
intended to be used in applications that want to report unexpected
errors.
</p>
<p id="121">
The <b><i>count</i></b> and
<b><i>all</i></b> keywords are passed to the <a href="tpl-commands/zoom.htm"><b>:zoom</b></a>
command and are documented with that command.
</p>
<p id="122">
A non-<code>nil</code> value for
<b><i>exit</i></b> causes the running application to
terminate. The default value of <i>exit</i> is <code>t</code>. (The normal situations for using this macro are
(1) the program is running in batch mode and so there is no operator
available to do anything; and (2) the program is being used by a user
unfamiliar with the internals and so unable to do anything. As there
is no one to take any action, this macro typically gets a backtrace,
which is written to <i>place</i>, and then causes the
program to exit.)
</p>
<p id="123">
A non-<code>nil</code> value for
<b><i>no-unwind</i></b> causes unwind-protects in stack
frames above the error to be ignored. (This argument is simply passed
to <a href="operators/excl/exit.htm"><b>exit</b></a> which also accepts a
<i>no-unwind</i> keyword argument.)
<i>no-unwind</i> is ignored if <i>exit</i>
is <code>nil</code>. The default value of
<i>no-unwind</i> is <code>nil</code> (as it
is for <a href="operators/excl/exit.htm"><b>exit</b></a>).
</p>

<p id="124">
The source for this macro is provided with the Allegro CL
distribution, in <em>[Allegro directory]/src/autozoom.cl</em>.
</p>

<hr>





<hr><hr><h2 id="125"><a name="local-variables-1">6.0 Local variables and the debugger</a></h2>

<p id="126">Allegro CL provides for examining and modifying the values of local
variables in compiled code but this facility comes at a fairly
significant space cost (since extra information is needed in compiled
code to provide the debugger with this information).  Therefore, the
enhancement is only available in code compiled with the debug
optimization quality set to 3 (assuming compiler switches have their
default values). Further, local name information (which is very useful
for debugging) is only loaded from a compiled file if the variable
<a href="variables/excl/s_load-local-names-info_s.htm"><code>*load-local-names-info*</code></a> is non-<code>nil</code> when the compiled (fasl) file is loaded.
</p>

<hr><h2 id="127"><a name="discarding-local-variable-info-2">6.1 Discard local variable information before dumplisp</a></h2>

<p id="128">Before we discuss local variables in detail, we should remark that
the information necessary to provide information on local variables
for debugging takes up a fairly significant amount of space in the
image. If you have completed debugging and you want to dump an image
(with <a href="operators/excl/dumplisp.htm"><b>dumplisp</b></a>), you may
want to discard this information before dumping (to save space in the
dumped image). The function <a href="operators/excl/discard-local-name-info.htm"><b>discard-local-name-info</b></a> will do that.</p>



<hr><h2 id="129"><a name="local-discussion-summary-2">6.2 Summary of the discussion of locals </a></h2>

<ul>
  <li id="130">In code compiled with debug=3 (so <a href="variables/compiler/save-local-scopes-switch.htm"><code>save-local-scopes-switch</code></a>
    is true), information on the live ranges of local variables is stored. The debugger uses
    this information when the <a href="tpl-commands/local.htm"><b>:local</b></a> command
    is executed to print out just the locals which have valid values and are still in use.
    (The live range of a local is defined below. It is basically the time after a local is
    first assigned a value until the local is last used.) The variable 
    <a href="variables/excl/s_load-local-names-info_s.htm"><code>*load-local-names-info*</code></a> 
    should be non-<code>nil</code> when compiled (fasl) files
    created with local variable information are loaded.
  </li>
  <li id="131">There is a significant space cost to storing information on the live range of locals.
    For this reason, it is only done (by default) when debug=3. We do not recommend compiling
    code with debug=3 except for purposes of debugging.</li>
  <li id="132">In code compiled with debug=1 or debug=2, live ranges of locals are not stored. The
    debugger prints the contents of all locations assigned to locals when the <a href="tpl-commands/local.htm"><b>:local</b></a> command is executed. The value in a
    location of a local not yet assigned a value may cause the debugger to print a great deal
    of garbage.</li>
</ul>




<hr><h2 id="133"><a name="waht-are-locals-2">6.3 What are local variables?</a></h2>

<p id="134">The local variables in a function include the arguments of the
function and variables bound in a let or similar form within the
function. Arguments and other local variables are handled differently
by the system, as we describe below.</p>



<hr><h2 id="135"><a name="compiler-treatment-of-locals-2">6.4 How does the compiler treat local variables?</a></h2>

<p id="136">The names of local variables are not necessary in compiled code
(the locations are sufficient). Saving names takes space. The compiler
will only save names when the speed, safety, and debug compiler
optimization qualities are such that the compiler switch <a href="variables/compiler/save-local-names-switch.htm"><code>save-local-names-switch</code></a> is
true. It is usual when developing code (so debugging is likely) to
compile with that switch true, so names are available. In production
code, it is usual to compile so names are not saved, to save
space. When debugging code where names are not saved, locals are
identified by a numerical index.</p>

<p id="137">
Further, local name information, if stored in a compiled file, is only
loaded if the value of the variable <a href="variables/excl/s_load-local-names-info_s.htm"><code>*load-local-names-info*</code></a> is non-<code>nil</code> when compiled (fasl) files created with local
variable information are loaded.
</p>


<p id="138">Locals may be stored on the stack or in registers. Which method is
used depends on the type of processor. When there is hardware support
for using registers, the compiler stores local variables in
registers. The processors that provide that support include the Sparc
and the IBM RS/6000 processor. Where the necessary hardware support
does not exist, locals are stored on the stack. (Some locals may be
stored on the stack even in machines with the necessary hardware
support. This happens when the number of live locals at some point
exceeds the number of available registers -- eight on the Sparc and
ten on the RS/6000.) </p>



<hr><h2 id="139"><a name="using-registers-vs-using-stack-2">6.5 What is the difference between using registers and using the stack?</a></h2>

<p id="140">
The advantage of register access is that it is much faster than
stack access. But there is also a downside: there may not be a
variable name associated with the register, because it is transient
(because of efficient compilation) and never stored on the stack. This
means that debugging will be harder.
</p>

<p id="141">
We will get back to the advantages of placing values only in registers
below, but we want to emphasize the debugging costs so that they are
clear. Consider this example:
</p>
<pre id="142">
(defun blah (&rest format-args)
  (let ((result (apply #'format nil format-args)))
    (read-from-string result)))

(compile 'blah)

(blah "~a/0" 42)
</pre>

<p id="143">
Evaluating the last form will cause a divide by zero
(<code>result</code> is the string "42/0", which is then
read). But the variable named <code>result</code> never shows up
on the stack because it is transiently used as the return value from
an <a href="../ansicl/dictentr/apply.htm"><b>apply</b></a> and as the first
argument to <a href="../ansicl/dictentr/read-fro.htm"><b>read-from-string</b></a>, and thus does not
even move from its register location - in all Allegro CL
implementations, the first return-value register is also the first
argument register; this provides for extremely efficient
code. Therefore, when debugging (after the divide by zero error is
signaled), you want to look at the value of <code>result</code>
but will not be able to see it under that name.
</p>

<p id="144">
If you want to force storing values on the stack, you can trace
<b>read-from-string</b> with a form like
</p>
<pre id="145">
(trace (read-from-string :inside blah))
</pre>
<p id="146">
Or you can use the <a href="tpl-commands/break.htm"><b>:break</b></a>
top-level command to set an instruction-level breakpoint and
setting :ldb mode on will allow single-stepping to track the variables
(including the arg0/result register) if the user knows how to look at
the disassembler output and interpret assembler code.
</p>
<p id="147">
Or you can redefine <code>blah</code> to force
<code>result</code> onto the stack so that it will show up as
a local variable:
</p>
<pre id="148">
(defun blarg () nil)

(defun blah (&rest format-args)
  (let ((result (apply #'format nil format-args)))
    (blarg)
    (read-from-string result)))
</pre>

<p id="149">
Inserting the call to <code>blarg</code> forces
<code>result</code> onto the stack (because the register holding
its value cannot be protected during a function
call). <code>result</code> will thus show up in debugger when
the <a href="../ansicl/dictentr/read-fro.htm"><b>read-from-string</b></a>
errors. Note, however, that if local-scopes are compiled in, then the
debugger will not show the variable named <code>result</code>,
because it is a dead local (its last usage is as an argument to
read-from-string). To see the name in that situation,
<code>tpl::*print-dead-locals*</code> must be set to t (see 
<a href="#want-to-see-dead-locals-2">Section 6.15 I compiled with debug=3 but I want to see dead locals anyway</a>).
</p>

<p id="150">
Now back to the advantages of using registers to hold values. Because
of the very significant performance boost, registers are used whenever
possible. Further, when registers are used, the compiler will analyze
the code in order to determine the live ranges of locals and have
locals with disjoint live ranges share the same register (<em>live
range</em> is defined just <a href="#live-and-dead-ranges-2">below</a>). This allows
maximum use of registers.
</p>

<p id="151">
Locals stored on the stack do not share locations -- that is, each
local stored on the stack is assigned its own location. This is true
on machines where all locals are stored on the stack and on machines
where some locals are stored in registers and others are stored on the
stack. It may be that sharing locations on the stack would be a
desirable optimization (because of reduced stack growth). However, it
has not been implemented.</p>

<p id="152">The examples in the rest of this section are taken from a Sparc
machine and therefore registers are used for locals. All the behavior
described applies to any machine (whether or not registers are used to
store locals) except maybe the concept of register sharing.</p>



<hr><h2 id="153"><a name="live-and-dead-ranges-2">6.6 Live and dead ranges of local variables</a></h2>

<p id="154">When compiling a function, the compiler tries to determine when a
local variable is first used (typically, when it is bound) and when a
local variable is last used. The time that the local is used is called
the <em>live range</em> of the local. </p>

<p id="155">When locals can be stored in registers, if two locals have disjoint
live ranges, the compiler may use the same register to store the
values of both variables.</p>



<hr><h2 id="156"><a name="locals-in-tail-functions-2">6.7 Locals and functions in the tail position</a></h2>

<p id="157">Consider this definition:</p>

<pre id="158">
(defun foo (lis)
  (let ((a 10) (b 9))
    (pprint (list a b lis))
    (list-length lis)))
</pre>

<p id="159">The function <a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a> is
in the tail position, which means that what it returns will be
returned by <strong>foo</strong>, and so no information about
<strong>foo</strong> is needed on the stack. The compiler will always
arrange that the stack is cleared of all but the tail position
function when possible (regardless of whether it tail merges or
not). Therefore, the form <code>(foo 10)</code> will cause an
error when <a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a> is
applied to 10 -- which is not a list -- but the values of locals
<em>a</em> and <em>b</em> will not be available.</p>



<hr><h2 id="160"><a name="live-range-example-2">6.8 Example showing live range</a></h2>

<p id="161">The live and dead ranges are best shown by example. Consider the
following function definition:</p>

<pre id="162">
(defun loc-fun (arg)
  (let ((a (+ arg 1)) ;; a alive but see text
        (b (+ arg 2)) ;; b alive but see text
        (c 3)) ;; c alive
    (break "break1")
    (setq c (+ a b c arg))
                     
;; a and b are now dead
    (let ((d 4) ;; d alive
          (e 5)) ;; e alive
      (break "break2")
      (print (* d e c))))
                     
;; c, d, and e are now dead
  (let* ((x 10) ;; x alive
         (y 11) ;; y alive
         (z 12)) ;; z alive
    (break "break3")
    (print (+ x y z))))
</pre>

<p id="163">The comments show where the various locals become alive and when
they die. There is an issue about where <em>a</em> and <em>b</em>
become alive. Strictly speaking, <em>a</em>, <em>b</em>, and
<em>c</em> all become alive when the binding form completes. That is
guaranteed in <a href="../ansicl/dictentr/letlet.htm"><b>let</b></a> so if
<em>a</em> and <em>b</em> had lexically apparent values from above the
<a href="../ansicl/dictentr/letlet.htm"><b>let</b></a> form, they could be used
later in the binding form. In fact that does not happen, so the
compiler may make the assignment at the position indicated rather than
later. This point is illustrated under the heading 
<a href="#locals-debug-three-speed-three-2">Section 6.14 The behavior with debug=3 and speed=3</a>
below.
</p>

<p id="164">
The <a href="../ansicl/dictentr/break.htm"><b>break</b></a>s are inserted to
allow us to examine what is happening at various points.
</p>

<p id="165">
Compiling this function with debug 3 ensures that local names are
saved. Below we inspect the function object
<code>#'loc-fun</code>. This inspection was done on a Sparc, a
machine that uses registers to store locals and hence local locations
are shared. Things will likely look different on other types of
machines.
</p>

<p id="166">
As the inspection shows, information about locals is stored in slot 9.
</p>

<pre id="167">
user(46): (inspect #'loc-fun)
#&lt;Function loc-fun @ #x6ccd12&gt;
  lambda-list: (arg)
   0 excl-type ----&gt; Bit field: #x08
   1 flags --------&gt; Bit field: #x88
   2 start --------&gt; Bit field: #x006ccd54
   3 hash ---------&gt; Bit field: #x00004e9d
   4 symdef -------&gt; The symbol loc-fun
   5 code ---------&gt; simple code vector (288) = #(40419 49048 ...)
   6 formals ------&gt; (arg), a proper list with 1 element
   7 cframe-size --&gt; fixnum 0 [#x00000000]
   8 call-count ---&gt; fixnum 0 [#x00000000]
   9 locals -------&gt; simple t vector (4) = #(#(8 ...) ...)
   ...
   14 &lt;constant&gt; ---&gt; A simple-string (6) &quot;break3&quot;
</pre>

<p id="168">If we further inspect slot 9, we see how the compiler assigned
locals to registers:</p>

<pre id="169">
[1i] user(47): :i 9
A simple t vector (4) @ #x6cd032
   0-&gt; simple t vector (15) = #(8 ...)
   1-&gt; (y c), a proper list with 2 elements
   2-&gt; (x d b), a proper list with 3 elements
   3-&gt; (e a), a proper list with 2 elements
[1i] user(48): 
</pre>

<p id="170">Three registers are used. y and c share the first. x, d, and b
share the second. e and a share the third. If you examine the code
above, you will see that the live ranges of the locals sharing a
register are disjoint (that is what allows them to share the
register).  The important result of this is that at any particular
time, only the values of live locals are meaningful. On machines that
do not use registers to store locals, no sharing would take
place. Each local would have its own location on the stack.</p>



<hr><h2 id="171"><a name="locals-debug-one-2">6.9 The debug=1 behavior with locals</a></h2>

<p id="172">The <a href="tpl-commands/local.htm"><b>:local</b></a> debugging command
with the debug optimization quality less than 3 simply prints out the
information it has without any analysis. This usually means simply
printing the contents of the locations where the locals are stored,
regardless of whether the value in the location was the actual value
of a local. </p>

<pre id="173">
user(53): (loc-fun 22)
Break: break1
 
Restart actions (select using :continue):
  0: return from break.
[1c] user(54): :loc
Compiled lexical environment:
0(required): arg: 22
1(local): :unknown: 3
2(local): :unknown: 23
3(local): :unknown: 24
4(local): :unknown: 3
5(local): :unknown: #&lt;non-lisp object @ #x11&gt;
6(local): :unknown: 0
7(local): :unknown: 0
8(local): :unknown: 0
[1c] user(55):
</pre>

<p id="174">What does this information tell us? The system has not stored any
information about locals (including their names), so it simply prints
the contents of the eight registers (because this is a Sparc, locals
are saved in registers and all eight possible registers are displayed)
that might contain locals. Knowing the function and how it was called,
we can see that <em>a</em> is in 2 (the argument 22, plus 1) and
<em>b</em> is in 3 (arg plus 2). <em>c</em> might be in 1 or 4 (later,
we can determine it is in 1) but it is often hard to figure out what
is going on. Further, some of the registers contain garbage and the
printed representation may not possibly represent a Lisp object (5,
e.g.) or may be a Lisp object but simply left over from some earlier
call (the rest).</p>

<p id="175">In any case, it is not very useful for debugging but remember, that
is how the function was compiled. Debugging information takes up space
and reduces the efficiency of the code.
</p>



<hr><h2 id="176"><a name="locals-debug-two-2">6.10 The behavior with debug=2</a></h2>

<p id="177">When debug=2, local names are saved. If we recompile
<b>loc-fun</b> with debug=2, more information
is provided:</p>

<pre id="178">
USER(70): (loc-fun 22)
Break: break1
 
Restart actions (select using :continue):
  0: return from break.
[1c] USER(71): :loc
Compiled lexical environment:
0(REQUIRED): ARG: 22
1(LOCAL): (X C): 3
2(LOCAL): (Y D A): 23
3(LOCAL): (E B): 24
[1c] USER(72):
</pre>

<p id="179">All the local names are printed but the system has no knowledge of
which locals are alive. So it shows which locals share which registers
and gives the current value in each register used by locals. This
information is often helpful. There is a problem with this method. It
is illustrated under the next heading.</p>

<p id="180">This example is from a Sparc machine, so locals are stored in
registers. On a machine where locals are stored on the stack, there
would be no sharing. More information would be available, therefore,
but bogus information would still be displayed for locals that had not
yet been set.</p>



<hr><h2 id="181"><a name="locals-debug-one-two-problems-2">6.11 Problem with debug=1 and debug=2 behavior before a local has a value</a></h2>

<p id="182">In the examples above, there was less information than desirable
but otherwise things looked okay. This is particularly true in the
debug=2 case just above. At the point of the break, all the locations
used for locals had valid values. If, however, you examine the locals
before all the locations have valid values, you may get a lot of
garbage. Let us rewrite <strong>loc-fun</strong> slightly by putting a
break before the let form -- here are the revised first 3 lines:</p>

<pre id="183">
(defun loc-fun (arg)
  (break "before-let")
  (let ((a (+ arg 1)) ;; a alive but see text
    [etc. -- see above for the rest of the definition]
</pre>

<p id="184">We call <strong>loc-fun</strong> and examine the locals before any
have been assigned values. Whatever happens to be in the locations is
printed. Because the contents of locations may depend on earlier
computation, you may see something different if you try this
example.</p>

<pre id="185">
USER(74): (loc-fun 22)
Break: before-let
 
Restart actions (select using :continue):
  0: return from break.
[1c] USER(75): :loc
Compiled lexical environment:
0(REQUIRED): ARG: 22
1(LOCAL): (X C): 0
2(LOCAL): (Y D A): &quot;1(LOCAL): (X C): 0
'1(LOCAL): (X C): 0
\\'1(LOCAL): (X C): 0
\\\\\\'1(LOCAL): (X C): 0
\\\\\\\\\\\\\\'1(LOCAL): (X C): 0
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'1(LOCAL): (X C): 0
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'1(LOCAL): (X C): 0
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'1(LOCAL): (X C): 0
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'1(LOCAL)
: (X C): 0
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&quot;
3(LOCAL): (E B): #&lt;non-lisp object @ #x65&gt;
[1c] USER(76):
</pre>

<p id="186">Compiling with debug=3 provides correct information about locals
and only prints the values of locals that have valid values. We
describe the debug=3 behavior in most of the remainder of this
section.</p>



<hr><h2 id="187"><a name="why-debug-three-2">6.12 Why only have good behavior of locals at debug=3?</a></h2>

<p id="188">As we will show, examining locals in code compiled at debug=3 (so
the compiler switch <a href="variables/compiler/save-local-scopes-switch.htm"><code>save-local-scopes-switch</code></a> is true) is
cleaner and easier than in code compiled so the switch is false. The
improvement is achieved by only printing the values of locals which
are alive at the time of examination (equivalently, by suppressing the
printing of dead locals). Why not have the clean behavior at all
settings?</p>

<p id="189">The reason is that there is a downside in suppressing dead locals:
a fairly significant increase in the size of compiled code. This
increase comes about because a lot of information about when locals
become alive and become dead is saved. </p>

<p id="190">The space hit is why the switch is only true (in the default) when
debug is 3.</p>

<p id="191">We do not recommend that you compile large amounts of code with
debug 3. Instead, compile the code that you are currently working
on.</p>



<hr><h2 id="192"><a name="debug-three-behavior-2">6.13 The behavior with debug=3 (and speed &lt; 3)</a></h2>

<p id="193">We recompile <b>local-fun</b> with debug 3
and call it again with the same argument, 10. </p>

<pre id="194">
USER(10): (loc-fun 10)
Break: break1
 
Restart actions (select using :continue):
  0: return from break.
[1c] USER(11): :local
Compiled lexical environment:
0(REQUIRED): ARG: 10
1(LOCAL): C: 3
2(LOCAL): B: 12
3(LOCAL): A: 11
[1c] USER(12):
</pre>

<p id="195">The live locals are identified and displayed. The yet-to-be-born
locals are not shown.  If we continue to the next <a href="../ansicl/dictentr/break.htm"><b>break</b></a>, we get the following:</p>

<pre id="196">
[1c] USER(12): :cont
Break: break2
 
Restart actions (select using :continue):
  0: return from break.
[1c] USER(13): :local
Compiled lexical environment:
0(REQUIRED): ARG: 10
1(LOCAL): C: 36
2(LOCAL): D: 4
3(LOCAL): E: 5
[1c] USER(14):
</pre>

<p id="197"><em>a</em> and <em>b</em> have died and <em>d</em> and <em>e</em>
have appeared.  Continuing to the next <a href="../ansicl/dictentr/break.htm"><b>break</b></a>:</p>

<pre id="198">
[1c] USER(14): :cont
 
720
Break: break3
 
Restart actions (select using :continue):
  0: return from break.
[1c] USER(15): :local
Compiled lexical environment:
0(REQUIRED): ARG: 10
1(LOCAL): Y: 11
2(LOCAL): X: 10
[1c] USER(16):
</pre>

<p id="199">Note that the argument arg is displayed in all cases. Arguments
live throughout the function call, whether or not they are still
needed. (Arguments are also stored in a different location than
locals.)</p>



<hr><h2 id="200"><a name="locals-debug-three-speed-three-2">6.14 The behavior with debug=3 and speed=3</a></h2>

<p id="201">
Recall <a href="#live-range-example-2">above</a>
when we defined loc-fun, we pointed out that the live ranges of
variables bound in a let form may start sooner than expected:
</p>

<pre id="202">
(defun loc-fun (arg)
  (let ((a (+ arg 1)) ;; a alive but see text
        (b (+ arg 2)) ;; b alive but see text
        (c 3)) ;; c alive
  [...]
</pre>

<p id="203">As we said above, <em>a</em> and <em>b</em> should not be live (as
locals) until the end of the binding form. The compiler can, however,
see that they are not used and so may actually make the assignments as
it processes each form in the binding form. The compiler will do this
when the compiler switch <a href="variables/compiler/internal-optimize-switch.htm"><code>internal-optimize-switch</code></a> is true. This
happens (by default) when debug is less than 3 or when debug is 3 and
speed is 3. To illustrate this, let us define a new function that
places breaks in the binding forms:</p>

<pre id="204">
(defun loc-fun-2 (arg)
  (let ((a (+ 2 (bar arg)))
        (b (+ 3 (baz arg))))
    (break "break3")
    (print (+ a b))))
(defun bar (x) (break "break1") x)
(defun baz (x) (break "break2") x)
</pre>

<p id="205"><strong>bar</strong> and <strong>baz</strong> just break and return
their argument, allowing us to break while the binding form is being
evaluated. The question is, when do <em>a</em> and <em>b</em> become
alive? If <strong>loc-fun-2</strong> is compiled with speed=3 debug=3,
<em>a</em> becomes alive before the <em>b</em> binding form completes
(that is, before break2 in <strong>baz</strong> is reached). If
<strong>loc-fun-2</strong> is compiled with speed=1 debug=3 (or
speed=2 debug=3), <em>a</em> becomes alive when the whole binding form
completes. This is illustrated by the transcripts below. Since the
transcripts are the same except for the locals printed, we simply have
one transcript with two columns when locals are shown. On the left,
<strong>loc-fun-2</strong> is compiled with speed=3 debug=3; on the
right, with speed=1 debug=3:</p>

<pre id="206">
USER(28): (loc-fun-2 24)
Break: break1
 
Restart actions (select using :continue):
  0: return from break.
[1c] USER(29): :dn
Evaluation stack:
 
  (BREAK &quot;break1&quot;)
  (BAR 24)
-&gt;(LOC-FUN-2 24)
  (EVAL (LOC-FUN-2 24))
[1c] USER(30): :local
 
--------speed=3 debug=3---------------------speed=1 debug=3
Compiled lexical environment:     Compiled lexical environment:
0(REQUIRED): ARG: 24              0(REQUIRED): ARG: 24
 
[1c] USER(31): :cont
Break: break2
 
Restart actions (select using :continue):
  0: return from break.
[1c] USER(32): :dn
Evaluation stack:
 
  (BREAK &quot;break2&quot;)
  (BAZ 24)
-&gt;(LOC-FUN-2 24)
  (EVAL (LOC-FUN-2 24))
[1c] USER(33): :local
--------speed=3 debug=3---------------------speed=1 debug=3
Compiled lexical environment:      Compiled lexical environment:
0(REQUIRED): ARG: 24               0(REQUIRED): ARG: 24
1(LOCAL): A: 26
 
[1c] USER(34): :cont
Break: break3
 
Restart actions (select using :continue):
  0: return from break.
[1c] USER(35): :local
--------speed=3 debug=3---------------------speed=1 debug=3
Compiled lexical environment:      Compiled lexical environment:
0(REQUIRED): ARG: 26               0(REQUIRED): ARG: 24
1(LOCAL): A: 26                    1(LOCAL): B: 27
2(LOCAL): B: 27                    2(LOCAL): A: 26
 
[1c] USER(35):
</pre>

<p id="207">The difference appears at break2 (while in <strong>baz</strong>). a
is alive on the left and not on the right.</p>



<hr><h2 id="208"><a name="want-to-see-dead-locals-2">6.15 I compiled with debug=3 but I want to see dead locals anyway</a></h2>

<p id="209">This is possible but the interface is not optimal. There is an
internal (i.e. not exported) variable which we are about to define
that causes the debugger to print dead locals, either those that are
not yet alive and those that were alive but are now dead.</p>

<blockquote>
  <p id="210">[Variable]</p>
  <p id="211"><code>tpl::*print-dead-locals*</code></p>
  <blockquote>
    <p id="212">When <code>nil</code> (the initial value), the
    debugger will suppress the printing of dead local variables. This
    suppression will only happen in functions compiled with the switch
    <a href="variables/compiler/save-local-scopes-switch.htm"><code>save-local-scopes-switch</code></a> true, in the
    default when and only when debug = 3.</p> <p id="213">When true, dead
    locals are printed, regardless of how the function was
    compiled.</p>
  </blockquote>
</blockquote>

<p id="214">
As we said at the beginning, one problem with printing locals that
have never been alive is that wholly bogus and sometimes lengthy
values may be printed because such a value happens to be in the
location that will later hold the value of the live local. We are not
going to repeat that example (see the discussion above under the
heading 
<a href="#locals-debug-one-two-problems-2">Section 6.11 Problem with debug=1 and debug=2 behavior before a local has a value</a>).
</p>

<p id="215">
More interesting than bogus values is what happens when all the
locals associated with a register (on machines where registers are
used to store locals) that is used for locals are dead. In our
<strong>loc-fun</strong> example, this happens at break3. <em>a</em>,
<em>b</em>, <em>c</em>, <em>d</em>, and <em>e</em> are all dead and
<em>x</em> and <em>y</em> are alive. <em>x</em> uses register 1 and
<em>y</em> uses register 2 but both values that use register 3
(<em>a</em> and <em>e</em>) are dead. We compile
<strong>loc-fun</strong> at debug=3 and move to break3:
</p>

<pre id="216">
[1c] USER(93): :cont
 
1560
Break: break3
 
Restart actions (select using :continue):
  0: return from break.
[1c] USER(94): :local
Compiled lexical environment:
0(REQUIRED): ARG: 24
1(LOCAL): Y: 11
2(LOCAL): X: 10
[1c] USER(95): (setq tpl::*print-dead-locals* t)
T
[1c] USER(96): :local
Compiled lexical environment:
0(REQUIRED): ARG: 24
1(LOCAL): Y: 11
2(LOCAL): X: 10
3(LOCAL): (:DEAD (E A)): 5
[1c] USER(97):
</pre>

<p id="217">For registers that hold live locals, the live local name and value
are printed. For registers that hold only dead locals, the list of
possible locals is printed, along with the keyword
<code>:dead</code>, and the value in the register. The system
has no way of knowing which of the identified dead locals had the
indicated value (we know it is <em>e</em> by examining the code). The
value is always the value of the last local to have died (assuming
they were ever alive).</p>

<p id="218">On machines where locals are stored on the stack and locations are
not shared, each local has a location and the value associated with a
local that was alive but is now dead is the last value of that
local.</p>

<p id="219">Note that you can set the value of
<code>tpl::*print-dead-locals*</code> at any time and the
behavior will change accordingly.</p>



<hr><hr><h2 id="220"><a name="break-on-exit">7.0 Break on exit</a></h2>

<p id="221">The <a href="tpl-commands/boe.htm"><b>:boe</b></a> command allows you to
break on exit, that is to stop execution when a frame is returned
from.</p>

<p id="222">Here is an example of using the <a href="tpl-commands/boe.htm"><b>:boe</b></a> command.</p>

<pre id="223">
user(2): (defun foo (a b) (let ((c (bar a b))) c))
foo
user(3): (defun bar (a b) (break) (list a b))
bar
user(4): (compile 'foo)
foo
nil
nil
user(5): (compile 'bar)
bar
nil
nil
user(6): (foo 1 2)
Break: call to the `break' function.
 
Restart actions (select using :continue):
  0: return from break.
[1c] user(7): :zo
 
Evaluation stack:
 
  (break &quot;call to the `break' function.&quot;)
-&gt;(bar 1 2)
  (foo 1 2)
  (eval (foo 1 2))
  (tpl:top-level-read-eval-print-loop)
  (tpl:start-interactive-top-level
      #&lt;excl::bidirectional-terminal-stream @ #x2a1f5e&gt;
      #&lt;Function top-level-read-eval-print-loop @ #x2d437e&gt;
...)
[1c] user(8): :cont
(1 2)
user(9): (foo 1 2)
Break: call to the `break' function.
 
Restart actions (select using :continue):
  0: return from break.
[1c] user(10): :dn
 
Evaluation stack:
 
  (break &quot;call to the `break' function.&quot;)
  (bar 1 2)
-&gt;(foo 1 2)
  (eval (foo 1 2))
  (tpl:top-level-read-eval-print-loop)
  (tpl:start-interactive-top-level
       #&lt;excl::bidirectional-terminal-stream @
#x2a1f5e&gt;
       #&lt;Function top-level-read-eval-print-loop @
#x2d437e&gt; ...)
[1c] user(11): :boe
[1c] user(12): :zo
Evaluation stack:
 
   (break &quot;call to the `break' function.&quot;)
   (bar 1 2)
*-&gt;(foo 1 2)
   (eval (foo 1 2))
   (tpl:top-level-read-eval-print-loop)
   (tpl:start-interactive-top-level
         #&lt;excl::bidirectional-terminal-stream
@ #x2a1f5e&gt;
         #&lt;Function
top-level-read-eval-print-loop @ #x2d437e&gt; ...)
[1c] user(13): :cont
Break: just after returning from function
 
Restart actions (select using :continue):
  0: return from break.
[1c] user(14): :zo
Evaluation stack:
 
  (break &quot;just after returning from function&quot;)
-&gt;(foo (1 2) 2)
  (eval (foo 1 2))
  (tpl:top-level-read-eval-print-loop)
  (tpl:start-interactive-top-level
        #&lt;excl::bidirectional-terminal-stream @
#x2a1f5e&gt;
        #&lt;Function top-level-read-eval-print-loop @
#x2d437e&gt; ...)
[1c] user(15): :cont
(1 2)
</pre>

<hr><hr><h2 id="224"><a name="return-and-restart-1">8.0 :return and :restart</a></h2>

<p id="225">The top-level commands <a href="tpl-commands/return.htm"><b>:return</b></a>
and <a href="tpl-commands/restart.htm"><b>:restart</b></a> both attempt to
restart evaluation of a broken process from the current frame (see
<a href="tpl-commands/current.htm"><b>:current</b></a>). <a href="tpl-commands/return.htm"><b>:return</b></a> sequentially evaluates the
arguments provided and returns their values from the current stack
frame. The function associated with the current stack frame is not
executed, and its arguments are not again evaluated. </p>

<p id="226">The <a href="tpl-commands/return.htm"><b>:return</b></a> command is useful
in situations similar to the following. Suppose that in your code you
had taken the <a href="../ansicl/dictentr/log.htm"><b>log</b></a> of a value
when you meant to take the <a href="../ansicl/dictentr/expexpt.htm"><b>exp</b></a>
of the value. If you make the call to <a href="../ansicl/dictentr/log.htm"><b>log</b></a> be the current stack frame, then typing </p>

<pre id="227">
:return (exp value) 
</pre>

<p id="228">will cause the computation to continue as if the code were correct
to begin with, that is, <a href="../ansicl/dictentr/expexpt.htm"><b>exp</b></a> of
value will be calculated and returned from the current frame.  The
<a href="../ansicl/dictentr/log.htm"><b>log</b></a> function will not be
re-executed. </p>

<p id="229"><a href="tpl-commands/restart.htm"><b>:restart</b></a> works on frame
objects. A frame object is a list whose first element is a function
and whose remaining elements are the <i>evaluated</i> arguments to the
function. The top-level command <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> prints a backtrace of the current
execution stack. If <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> is
printing in moderate mode, it prints frame objects. (In brief mode, it
simply prints the function name. In verbose mode, more than the frame
object is printed.) <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> and
related commands (:find, :dn, :up, :top, etc.) all display the stack
and identify one stack frame as the current stack frame.  The value of
the lisp variable * is set to the identified frame as part of the
action of <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> or a related
command. Thus, if <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> is
printing in moderate mode, * will be set to a frame object after
<a href="tpl-commands/zoom.htm"><b>:zoom</b></a> or a related command
completes. </p>

<p id="230">The argument to the <a href="tpl-commands/restart.htm"><b>:restart</b></a>
command must evaluate to a frame object (or <code>nil</code>, indicating that the current frame object should
be used unchanged). Calling <a href="tpl-commands/restart.htm"><b>:restart</b></a> restarts computation, replacing
the current frame with the argument frame and continuing from
there. Contrast this with <a href="tpl-commands/return.htm"><b>:return</b></a>
which returns from a frame with a specified value (but does not
re-evaluate the current frame). The two commands, <a href="tpl-commands/return.htm"><b>:return</b></a> and <a href="tpl-commands/restart.htm"><b>:restart</b></a> can behave quite differently. We
will give an example below. </p>

<p id="231">As an example of <a href="tpl-commands/restart.htm"><b>:restart</b></a> called
with no arguments, suppose you define the following functions: </p>

<pre id="232">
(defun baz (n) (bar (+ n 3)))
  (defun bar (n) (+ (goo n) 5))
  (defun foo (x) (* x x)) 
</pre>

<p id="233">We have misspelled <em>foo</em> as <em>goo</em> in the definition
of bar. If we evaluate </p>

<pre id="234">
(baz 7)
</pre>

<p id="235">we get an error since <strong>goo</strong> is undefined. The stack
as printed by <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> contains the
frame </p>

<pre id="236">
(bar 10)
</pre>

<p id="237">We can then correct the definition of <strong>bar</strong> and load
in just the new definition using the Emacs-Lisp interface. Next, if we
make </p>

<pre id="238">
(bar 10) 
</pre>

<p id="239">the current frame (using <a href="tpl-commands/dn.htm"><b>:dn</b></a> or
<a href="tpl-commands/find.htm"><b>:find</b></a>), we can call <a href="tpl-commands/restart.htm"><b>:restart</b></a> without arguments (or with
<code>nil</code> as an argument) and the computation will
continue, returning the correct answer (105). </p>

<p id="240">As an example of calling <a href="tpl-commands/restart.htm"><b>:restart</b></a> with an argument, consider the
following. Suppose <strong>bar</strong> and <strong>foo</strong> are
defined as: </p>

<pre id="241">
(defun bar () (+ (hoo 1 2 3) (hoo 4 5 6)))
  (defun foo (a b c) (+ a b c)) 
</pre>

<p id="242">Here, the call to <strong>hoo</strong> in <strong>bar</strong> is a
misprint: it should be a call to <strong>foo</strong>. If we evaluate
<code>(bar)</code>, we again get an undefined function error. If we
call <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> (with its :all argument
specified as <code>t</code> so all frames are printed), we
see the following frame: </p>

<pre id="243">
(excl::%eval (+ (hoo 1 2 3) (hoo 4 5 6))) 
</pre>

<p id="244">(You may have to set the values of <a href="variables/tpl/s_zoom-print-level_s.htm"><code>*zoom-print-level*</code></a> and <a href="variables/tpl/s_zoom-print-length_s.htm"><code>*zoom-print-length*</code></a> to
<code>nil</code> to get the entire frame without # marks
or suspension points.) If we make that frame the current frame (so it
is the value of <code>cl:*</code>) and then evaluate </p>

<pre id="245">
:restart (subst 'foo 'hoo *) 
</pre>

<p id="246">the frame will be re-evaluated so that <strong>foo</strong> is
called rather than <strong>hoo</strong> and the correct result (21)
will be returned. </p>

<p id="247">The argument to <a href="tpl-commands/restart.htm"><b>:restart</b></a> must
evaluate to a frame object and the `arguments' in a frame object (the
elements of the cdr) will not be further evaluated. Thus the following
are not equivalent: </p>

<pre id="248">
(+ 1 2 3 5)
  (+ 1 2 3 (- 6 1)) 
</pre>

<p id="249">The first will evaluate correctly. The second will bomb since a
list is not a legal argument to +. </p>

<p id="250">One might think at first that <a href="tpl-commands/restart.htm"><b>:restart</b></a> called with a frame object and
<a href="tpl-commands/return.htm"><b>:return</b></a> called with a form which,
when the arguments are evaluated, is the same since the frame object
will have the same result. This is not, however, correct. </p>

<p id="251">The bindings set up on the stack are (in some cases) handled
differently by the two <a href="tpl-commands/restart.htm"><b>:restart</b></a>
and <a href="tpl-commands/return.htm"><b>:return</b></a>. Like many binding
issues in Lisp, the example is not immediately intuitive (at least to
Lisp beginners). Let us give an example and then discuss it. Consider
the following functions: </p>

<pre id="252">
(defun bar () 
  (let ((*special* 1))
    (declare (special *special*))
    (foo 5)))
(defun foo (x) 
  (let ((*special* (1+ *special*)))
    (declare (special *special*))
    (if (eq x 5) (break "sorry, bad number") *special*))) 
</pre>

<p id="253">When we evaluate <code>(bar)</code>, <strong>foo</strong>
will be called with argument 5 and break will put Lisp into a break
loop. We decide to go to the frame where <strong>foo</strong> is
called and recall <strong>foo</strong> with a different argument. Here
is the stack after the break. We go down two frames to reach the frame
where <strong>foo</strong> is called. </p>

<pre id="254">
;; Note: this manual is generic over several implementations.
;; The stack may differ from one implementation to another
;; so the stack you see may differ in detail from what is
;; reproduced here.
 
USER(4): (bar)
Break: sorry, bad number
 
Restart actions (select using :continue):
  0: return from break.
[1c] USER(5): :zoom
Evaluation stack:
 
  (BREAK &quot;sorry, bad number&quot;)
-&gt;(IF (EQ X 5) (BREAK &quot;sorry, bad number&quot;) ...)
  (LET (#) (DECLARE #) ...)
  (FOO 5)
  (LET (#) (DECLARE #) ...)
  (BAR)
  (EVAL (BAR))
  (TPL:TOP-LEVEL-READ-EVAL-PRINT-LOOP)
  (TPL:START-INTERACTIVE-TOP-LEVEL
      #&lt;EXCL::BIDIRECTIONAL-TERMINAL-STREAM @ #x162f5e&gt;
      #&lt;Function TOP-LEVEL-READ-EVAL-PRINT-LOOP @ #x282156&gt;
...)
 
... more older frames ...
[1c] USER(6): :dn 2
Evaluation stack:
 
  (BREAK &quot;sorry, bad number&quot;)
  (IF (EQ X 5) (BREAK &quot;sorry, bad number&quot;) ...)
  (LET (#) (DECLARE #) ...)
-&gt;(FOO 5)
  (LET (#) (DECLARE #) ...)
  (BAR)
  (EVAL (BAR))
  (TPL:TOP-LEVEL-READ-EVAL-PRINT-LOOP)
  (TPL:START-INTERACTIVE-TOP-LEVEL
      #&lt;EXCL::BIDIRECTIONAL-TERMINAL-STREAM @ #x162f5e&gt;
      #&lt;Function TOP-LEVEL-READ-EVAL-PRINT-LOOP @ #x282156&gt;
...)
 
... more older frames ...
[1c] USER(7): 
</pre>

<p id="255">Let us compare the following two commands that could be entered at
this point. We show the commands and what is returned and then we
explain why the returned values are different. </p>

<pre id="256">
:return (foo 6) -&gt; 3
  :restart '(foo 6) -&gt; 2
</pre>

<p id="257">Both avoid the call to <a href="../ansicl/dictentr/break.htm"><b>break</b></a> since the argument to <strong>foo</strong>
is not 5. However, the <a href="tpl-commands/return.htm"><b>:return</b></a>
command causes <strong>bar</strong> to return the value 3 while the
<a href="tpl-commands/restart.htm"><b>:restart</b></a> command causes
<strong>bar</strong> to return the value 2. The binding of
<code>*special*</code> which took place in <strong>foo</strong>
before the call to <strong>break</strong> is not undone by <a href="tpl-commands/return.htm"><b>:return</b></a>. It is undone by <a href="tpl-commands/restart.htm"><b>:restart</b></a>. </p>

<p id="258">The moral is that you can use <a href="tpl-commands/return.htm"><b>:return</b></a> with a form argument when you know
what value is expected and there are <i>no</i> side effects that you
care or are concerned about. You should use <a href="tpl-commands/restart.htm"><b>:restart</b></a> when side effects are
important. </p>

<p id="259">In the following example, we show <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> displaying the evaluation stack, and
show how to use some of the other stack manipulation commands. </p>

<pre id="260">
;; Note: this manual is generic over several implementations.
;; The stack may differ from one implementation to another
;; so the stack you see may differ in detail from what is
;; reproduced here.
user(2): (defun func (x) (* x (bar x)))
func
user(3): (defun bar (x) (car x))
bar
user(4): (func 10)
Error: Attempt to take the car of 10 which is not a cons.
  [condition type: simple-error]
[1] user(5): :zo
Evaluation stack:
 
  (error simple-error :format-control ...)
-&gt;(car 10)
  (bar 10)
  (func 10)
  (eval (func 10))
  (tpl:top-level-read-eval-print-loop)
  (tpl:start-interactive-top-level
      #&lt;excl::bidirectional-terminal-stream @ #x2a21de&gt;
      #&lt;Function top-level-read-eval-print-loop @ #x2d59c6&gt;
...)
[1] user(6): :find bar
Evaluation stack:
 
  (error simple-error :format-control ...)
  (car 10)
-&gt;(bar 10)
  (func 10)
  (eval (func 10))
  (tpl:top-level-read-eval-print-loop)
  (tpl:start-interactive-top-level
      #&lt;excl::bidirectional-terminal-stream @ #x2a21de&gt;
      #&lt;Function top-level-read-eval-print-loop @ #x2d59c6&gt;
...)
[1] user(7): :return 5
;; :RETURN simply returns 5 from the frame
;; resulting in FUNC returning 50.
50
user(8): (func 10)
Error: Attempt to take the car of 10 which is not a cons.
  [condition type: simple-error]
[1] user(9): :find func
Evaluation stack:
 
  (error simple-error :format-control ...)
  (car 10)
  (bar 10)
-&gt;(func 10)
  (eval (func 10))
  (tpl:top-level-read-eval-print-loop)
  (tpl:start-interactive-top-level
      #&lt;excl::bidirectional-terminal-stream @ #x2a21de&gt;
      #&lt;Function top-level-read-eval-print-loop @ #x2d59c6&gt;
...)
[1] user(10): (defun bar (x) (car (list x)))
;; BAR is now just the identity function, but it will work
bar
[1] user(11): :error
Attempt to take the car of 10 which is not a cons.
[1] user(12): :current
(func 10)
[1] user(13): :restart
100
user(14): (defun fact (n) 
           (cond ((= 1 n) 1) (t (* n
(fact (1- n))))))
fact
user(15): (fact nil)
Error: nil is an illegal argument to =
  [condition type: type-error]
[1] user(16): :zo
Evaluation stack:
 
  (error type-error :datum ...)
-&gt;(= 1 nil)
  (cond (# 1) (t #))
  (fact nil)
  (eval (fact nil))
  (tpl:top-level-read-eval-print-loop)
  (tpl:start-interactive-top-level
      #&lt;excl::bidirectional-terminal-stream @ #x2a21de&gt;
      #&lt;Function top-level-read-eval-print-loop @ #x2d59c6&gt;
...)
[1] user(17): :pop
user(18): 
</pre>

<hr><hr><h2 id="261"><a name="ghost-frames-1">9.0 Ghost frames in backtraces</a></h2>

<hr><h2 id="262"><a name="ghost-summary-2">9.1 Summary of the ghost frames section</a></h2>

<ul>
<li id="263">
When code compiled so that the tail-merge optimization is performed,
frames that should (according to the source code) appear on the stack
may not be there. Although such optimized code may run faster and use
less stack, debugging is made harder.
</li>
<li id="264">
The debugger will, where possible, display such missing frames by
identifying the function called within brackets ([]).
</li>
<li id="265">
Ghost frames do not correspond to any actual frames on the stack, and
therefore, they cannot become the current frame, or be restarted or
returned from.
</li>
<li id="266">
The disassembler must be loaded into the system for ghost frames to be
displayed. When the disassembler is loaded, the string
"disasm" appears on the <code>cl:*modules*</code>
list. The debugger will not load the disassembler if it is not
present. It will print a message at the end of the backtrace saying
that ghost frames are not displayed because the disassembler is not
loaded. The disassembler can be loaded by calling the function
disassemble function or by evaluating <code>(require
:disasm)</code>. It is not an error to evaluate that form when the
disassembler is already loaded.
</li>
<li id="267">
If a ghost frame includes suspension points (`...'), the debugger has
determined that additional frames have been optimized off the stack by
tail merging but that the functions called in these missing frames
cannot be determined.
</li>
<li id="268">
The debugger may or may not be able to discover all ghost frames. The
fact that no ghost frames appear does not mean that frames have not
been optimized off the stack. Similarly, the fact that suspension
points do not appear in a ghost frame does not mean that the function
in the ghost frame called the next frame up the stack.
</li>
</ul>

<p id="269">In the following backtrace, the frame `[... foo]' is a ghost
frame. It indicates that <strong>start-fun</strong> called
<strong>foo</strong> and that <strong>foo</strong> did not itself call
<a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a>, so
<strong>foo</strong> must have called something else before a call to
<a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a>:</p>

<pre id="270">
(error type-error :datum ...)
-&gt;(list-length 1)
  [... foo]
  (start-fun 1)
  (eval (start-fun 1))
</pre>

<p id="271">
The example that generated this backtrace is given in
<a href="#optimizations-causing-ghost-2">Section 9.3 What kinds of optimizations cause ghost frames?</a>
below. From the example, we know that <strong>start-fun</strong>
called <strong>foo</strong>, which called <strong>bar</strong>, which
called <strong>baz</strong>, which called <a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a>, and looking at the backtrace, we
know that calls to <strong>foo</strong>, <strong>bar</strong>, and
<strong>baz</strong> have been optimized out, but the system can still
detect that <strong>foo</strong> must have been called.
</p>

<p id="272">
The remainder of this section contains the following headings:
</p>

<blockquote>
  <p id="273">
  <a href="#what-is-ghost-2">Section 9.2 What is a ghost frame?</a>
  <br>
  <a href="#optimizations-causing-ghost-2">Section 9.3 What kinds of optimizations cause ghost frames?</a>
  <br>
  <a href="#how-does-debugger-know-about-ghost-2">Section 9.4 How does the debugger know about ghost frames?</a>
  <br>
  <a href="#displaying-ghost-2">Section 9.5 When will the debugger display ghost frames?</a>
  <br>
  <a href="#returning-from-ghost-2">Section 9.6 Can I return from or restart a ghost frame?</a>
  <br>
  <a href="#suspension-points-in-ghost-2">Section 9.7 What do the suspension points (`...') mean in a ghost frame?</a>
  <br>
  <a href="#no-suspension-points-in-ghost-2">Section 9.8 The ghost frame has no `...'s; are all possible frames displayed?</a>
  <br>
  <a href="#no-ghost-displayed-2">Section 9.9 No ghost frames are displayed. Do all functions appear on the stack?</a>
  <br>
  <a href="#ghost-in-brief-2">Section 9.10 Ghost frames in a brief backtrace</a>
  <br>
  <a href="#turn-off-printing-ghost-2">Section 9.11 Can I turn off printing of ghost frames?</a>
  <br>
  <a href="#system-functions-and-ghost-2">Section 9.12 Can backtraces involving system functions have ghost frames?</a>
  <br>
  <a href="#ghost-and-composer-2">Section 9.13 Ghost frames and Allegro Composer</a>
  </p>
</blockquote>



<hr><h2 id="274"><a name="what-is-ghost-2">9.2 What is a ghost frame?</a></h2>

<p id="275">Typically, Lisp executes a series of function calls. It maintains a
stack of function call frames that show the sequence of functions,
each calling the next, that resulted in the current state of
Lisp. However, compiled code may cause the frames associated with
functions actually called to be removed from the stack. Doing so makes
code run faster but means that a backtrace (displayed by the top-level
commands <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> and <a href="tpl-commands/bt.htm"><b>:bt</b></a>) does not show calls to some functions
actually called, thus making debugging more difficult. </p>

<p id="276">The debugger will where possible insert frames into a backtrace to
indicate either that a specific function was called but optimization
has removed the associated frame from the stack or that some function
was called and removed from the stack by optimization although the
debugger cannot determine exactly which function.</p>

<p id="277">These inserted frames are called <i><b>ghost frames</b></i>. They
are indicated in moderate or verbose printed backtraces by being
surrounded with brackets ([]). Consider the following backtraces. The
first shows the interpreted code. The second shows compiled code at
maximum optimization. The <code>[... foo]</code> frame in the
second backtrace is a ghost frame, indicating that there was a call to
<strong>foo</strong> whose associated frame is no longer on the
stack. The suspension points (`...') further indicate that other
functions were called whose associated frames have been removed from
the stack, although the debugger cannot determine which ones (we of
course know from the interpreted backtrace that the missing functions
are <strong>bar</strong> and <strong>baz</strong>):</p>

<pre id="278">
; Interpreted code backtrace:
  (error type-error :datum ...)
-&gt;(list-length 1)
  (baz 1)
  (bar 1)
  (foo 1)
  (start-fun 1)
  (eval (start-fun 1))
 
; Compiled code backtrace:
  (error type-error :datum ...)
-&gt;(list-length 1)
  [... foo]
  (start-fun 1)
  (eval (start-fun 1))
</pre>



<hr><h2 id="279"><a name="optimizations-causing-ghost-2">9.3 What kinds of optimizations cause ghost frames?</a></h2>

<p id="280">
Frames get removed from the stack by a compiler optimization called
non-self tail merging. Consider the following example (which generated
the backtraces shown above when compiled with speed 2, debug 1):
</p>

<pre id="281">
(defun start-fun (x) (foo x) nil)
(defun foo (x) (print x) (bar x))
(defun bar (x) (princ x) (baz x))
(defun baz (x) (pprint x) (list-length x))
</pre>

<p id="282">
The error for which the backtrace is displayed above occurs when
the form <code>(start-fun 1)</code> is evaluated. 1 is not a
legal argument to <a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a>
(which expects a list) and so an error is signaled.
</p>

<p id="283">This is a pretty trivial example but it is not uncharacteristic of
real code. <strong>foo</strong>, <strong>bar</strong>, and
<strong>baz</strong> each accepts an argument, does something with the
argument, and then passes the argument to the next
function. <strong>foo</strong>, <strong>bar</strong>, and
<strong>baz</strong> each has the property that once the system has
reached the last form, nothing further is required of the
function. </p>

<p id="284">Thus, <strong>foo</strong> calls <strong>print</strong> and then
calls <strong>bar</strong>.  <strong>foo</strong> is going to return
whatever <strong>bar</strong> returns and there are no possible side
effects that are not caused by <strong>bar</strong>. At the point
where <strong>foo</strong> calls <strong>bar</strong>, there is no
reason for a frame associated with <strong>foo</strong> to be on the
stack, except for debugging. Indeed, keeping the frame on the stack
causes the stack to grow more than is absolutely necessary and, when
<strong>bar</strong> returns, causes extra instructions (to exit from
<strong>foo</strong>) to be executed. Things would run faster if the
frame associated with <strong>foo</strong> were simply removed from
the stack and the system acted as if <strong>start-fun</strong> had
called <strong>bar</strong> directly (the print called for in
<strong>foo</strong> has already been completed by the time
<strong>bar</strong> is called). </p>

<p id="285">The compiler will optimize this code to remove frames as described
as long as the compiler optimization qualities safety, space, speed,
and debug have values such that the switch <a href="variables/compiler/tail-call-non-self-merge-switch.htm"><code>tail-call-non-self-merge-switch</code></a> is
true. In that case, the compiler will generate code which will make
the stack look as if the functions were defined as follows:</p>

<pre id="286">
(defun start-fun (x)
  (foo x)
  (bar x)
  (baz x)
  (list-length x))
(defun foo (x) (print x))
(defun bar (x) (princ x))
(defun baz (x) (pprint x))
</pre>

<p id="287">This code will run faster and suppress unnecessary stack growth but
the stack will not reflect the actual sequence of function
calls. Thus, when <strong>start-fun</strong> is called with the
argument 1, <a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a> will
signal an error because its argument is not a list and the backtraces
shown above will result.</p>

<p id="288">Compiler optimization switches in general and <a href="variables/compiler/tail-call-non-self-merge-switch.htm"><code>tail-call-non-self-merge-switch</code></a> in
particular are described in <a href="compiling.htm">compiling.htm</a>.</p>



<hr><h2 id="289"><a name="how-does-debugger-know-about-ghost-2">9.4 How does the debugger know about ghost frames?</a></h2>

<p id="290">Since all references to <strong>foo</strong>, <strong>bar</strong>,
and <strong>baz</strong> in our example have disappeared from the
stack by the time Lisp enters a break loop (when <a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a> signals an error), the information
on the stack is insufficient to print ghost frames. One piece of
information, is available, however: the location to which control
should return in <strong>start-fun</strong> when <a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a> has completed. The debugger can
access that return location and can (assuming the disassembler has
been loaded) disassemble the code for the function named by
<strong>start-fun</strong>. Looking at that disassembly, the debugger
can determine that the return location is just after a call to
<strong>foo</strong>. </p>

<p id="291">Therefore, it knows that <strong>foo</strong> was called but the
<strong>foo</strong> frame has been optimized off the stack. From that
information, the debugger generates the <strong>foo</strong> ghost
frame.</p>

<p id="292">The debugger also knows that some function must have called
<strong>list-length</strong> (since the <a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a> frame is still on the
stack). Examining the disassembly of <strong>foo</strong> shows that
<strong>foo</strong> could not have called <a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a> itself and so the debugger also
knows that at least one other function must have been called between
<strong>foo</strong> and <a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a> (we know that <strong>bar</strong>
and <strong>baz</strong> were called). Therefore, the debugger puts
the suspension points in the ghost frame to indicate the missing ghost
frames ([... foo]). However, the debugger is not able to tell which
function called by <strong>foo</strong> called <a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a>.</p>



<hr><h2 id="293"><a name="displaying-ghost-2">9.5 When will the debugger display ghost frames?</a></h2>

<p id="294">In order for the debugger to determine that frames have been
optimized off the stack, it must have access to the disassembler. The
disassembler in Allegro CL is not included as part of the base
system. Instead, it is loaded when needed, typically when the function
<a href="../ansicl/dictentr/disassem.htm"><b>disassemble</b></a> is called.</p>

<p id="295">When the disassembler is loaded, the system adds the string
"disasm" to the list that is the value of <a href="../ansicl/dictentr/modules.htm"><code>*modules*</code></a>. The debugger will not
load the disassembler just to print ghost frames. So, when the
disassembler is loaded, the debugger will print ghost frames in
backtraces. When the disassembler is not loaded, the debugger will not
print such frames. In that case, the following message will be printed
at the end of the backtrace:</p>

<pre id="296">
(to see any ghost frames, the disassembler must be loaded)
</pre>



<hr><h2 id="297"><a name="returning-from-ghost-2">9.6 Can I return from or restart a ghost frame?</a></h2>

<p id="298">The short answer is no. Various debugger commands in Allegro CL
operate on the current frame. These include <a href="tpl-commands/restart.htm"><b>:restart</b></a>, <a href="tpl-commands/return.htm"><b>:return</b></a>, <a href="tpl-commands/current.htm"><b>:current</b></a>, <a href="tpl-commands/local.htm"><b>:local</b></a>, etc. Since ghost frames are not
really on the stack, applying these commands to a ghost frame does not
make sense. In fact, it is not possible to make a ghost frame the
current frame. Here is the backtrace shown above:</p>

<pre id="299">
  (error type-error :datum ...)
-&gt;(list-length 1)
  [... foo]
  (start-fun 1)
  (eval (start-fun 1))
</pre>

<p id="300">The arrow (-&gt;) indicates the current frame is the <a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a> frame. If you call the
command <a href="tpl-commands/dn.htm"><b>:dn</b></a> (which moves the
current frame down one frame on the stack), the display changes as
follows:</p>

<pre id="301">
  (error type-error :datum ...)
  (list-length 1)
  [... foo]
-&gt;(start-fun 1)
  (eval (start-fun 1))  
</pre>

<p id="302">That is, the ghost frame is skipped and the next real frame, the
<strong>start-fun</strong> frame, becomes the current frame.</p>



<hr><h2 id="303"><a name="suspension-points-in-ghost-2">9.7 What do the suspension points (`...') mean in a ghost frame?</a></h2>

<p id="304">
The backtrace shown just above indicates the ghost frame
<code>[... foo]</code>. The suspension points indicate that
other functions were called between <strong>foo</strong> and <a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a>, although the debugger
does not know what these functions are.
</p>

<p id="305">
As described under the heading
<a href="#how-does-debugger-know-about-ghost-2">Section 9.4 How does the debugger know about ghost frames?</a>
above, the debugger can sometimes tell that a ghost frame belongs in
the stack and that the function associated with the ghost frame cannot
have called the function associated with the next real frame on the
stack. Thus, in our example, the debugger can tell that a
<strong>foo</strong> frame must have been on the stack (so it adds a
ghost frame) and can further tell <strong>foo</strong> did not call
<a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a> (and so adds
suspension points to the ghost frame).
</p>



<hr><h2 id="306"><a name="no-suspension-points-in-ghost-2">9.8 The ghost frame has no `...'s; are all possible frames displayed?</a></h2>

<p id="307">
We have already said that suspension points (`...') indicate that
other functions were called between the ghost frame and the next real
frame. However, if there are no suspension points, you cannot
immediately conclude that no other functions were called.
</p>

<p id="308">
Consider the following modification of our example above. Instead
of defining <strong>foo</strong> this way:
</p>

<pre id="309">
(defun foo (x) (print x) (bar x))
</pre>

<p id="310">we define it as follows:</p>

<pre id="311">
(defun foo (x) (let ((y (list-length (list x)))) (print y)) (bar x))
</pre>

<p id="312">(Again, a trivial example since y is obviously 1.) We compile
<strong>foo</strong> again and again evaluate <code>(start-fun
1)</code>. Again, we get an error (from the call to <a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a> in <strong>baz</strong>)
and the following backtrace is displayed:</p>

<pre id="313">
  (error type-error :datum ...)
-&gt;(list-length 1)
  [foo]
  (start-fun 1)
  (eval (start-fun 1))
</pre>

<p id="314">Here, the ghost frame for <strong>foo</strong> has no suspension
points even though we know that <strong>foo</strong> called
<strong>bar</strong> called <strong>baz</strong> called
<strong>list-length</strong>, where the error occurred. However,
because <strong>foo</strong> itself calls <a href="../ansicl/dictentr/list-len.htm"><b>list-length</b></a> (for a different purpose), the
debugger could not conclude that <strong>foo</strong> did not call
<strong>list-length</strong> with an argument which resulted in an
error.</p>

<p id="315">Therefore, suspension points indicate missing ghost frames for
sure. No suspension points does not by itself mean there are no
missing ghost frames.</p>



<hr><h2 id="316"><a name="no-ghost-displayed-2">9.9 No ghost frames are displayed. Do all functions appear on the stack?</a></h2>

<p id="317">
First, some functions are hidden by the system from backtraces to
avoid unnecessary clutter. These functions are printed when <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> is called with arguments
<code>:all t</code>.
</p>

<p id="318">
However, ghost frames may also be missing in cases similar to our
example. Suppose <strong>start-fun</strong>, which was originally
defined (in
<a href="#no-suspension-points-in-ghost-2">Section 9.8 The ghost frame has no `...'s; are all possible frames displayed?</a>) above:
</p>

<pre id="319">
  (defun start-fun (x) (foo x) nil)
</pre>

<p id="320">was instead defined as follows:</p>

<pre id="321">
  (defun start-fun (x) (funcall 'foo x) nil)
</pre>

<p id="322">Again, we evaluate <code>(start-fun 1)</code> and do a
<a href="tpl-commands/zoom.htm"><b>:zoom</b></a>. The following backtrace is
printed:</p>

<pre id="323">
  (error type-error :datum ...)
-&gt;(list-length 1)
  (start-fun 1)
  (eval (start-fun 1))
</pre>

<p id="324">The moral of this and the information under the previous heading,
therefore, is that printed information is always guaranteed but
missing information should not be depended upon to accurately reflect
the situation.</p>



<hr><h2 id="325"><a name="ghost-in-brief-2">9.10 Ghost frames in a brief backtrace</a></h2>

<p id="326">
Calling <a href="tpl-commands/zoom.htm"><b>:zoom</b></a> with arguments
<code>:brief t</code> or calling the <a href="tpl-commands/bt.htm"><b>:bt</b></a> command prints an abbreviated
backtrace. Here is roughly what is printed when <a href="tpl-commands/bt.htm"><b>:bt</b></a> is called after evaluating
<code>(start-fun 1)</code>. The original definitions of
<strong>foo</strong> and <b>start-fun</b> are in
<a href="#optimizations-causing-ghost-2">Section 9.3 What kinds of optimizations cause ghost frames?</a>
above. Note that you may see additional frames.
</p>

<pre id="327">
list-length &lt;-
[... foo] &lt;- start-fun &lt;- eval &lt;- tpl:top-level-read-eval-print-loop &lt;-
tpl:start-interactive-top-level
</pre>

<p id="328">(This backtrace includes frames for functions below
<strong>start-fun</strong> in the stack (such as <a href="../ansicl/dictentr/eval.htm"><b>eval</b></a>) that were left out in the backtraces
printed above.)</p>



<hr><h2 id="329"><a name="turn-off-printing-ghost-2">9.11 Can I turn off printing of ghost frames?</a></h2>

<p id="330">
If the disassembler is not loade and so "disasm" is not on the <code>cl:*modules*</code>
list, ghost frames will not
be printed. However, if that string is on <a href="../ansicl/dictentr/modules.htm"><code>*modules*</code></a>, ghost frames will be printed. The
debugger will always print ghost frames if it can. Load the
disassembler with </p>

<pre id="331">
(require :disasm)
</pre>

<p id="332">
There is no way to unload the disassembler. It is typically already
loaded at startup in development images. (See the discussion of the
<i>include-devel-env</i> keyword argument to <a href="operators/excl/build-lisp-image.htm"><b>build-lisp-image</b></a> in <a href="building-images.htm#arguments-with-inherited-defaults-1">Arguments to
build-lisp-image 1</a> in
<a href="building-images.htm">building-images.htm</a>.)
</p>



<hr><h2 id="333"><a name="system-functions-and-ghost-2">9.12 Can backtraces involving system functions have ghost frames?</a></h2>

<p id="334">Yes, they can. Many system (i.e. predefined) functions in Allegro
CL are compiled at a settings of speed and debug which cause <a href="variables/compiler/tail-call-non-self-merge-switch.htm"><code>tail-call-non-self-merge-switch</code></a> to be
true. Therefore, it is possible that ghost frames can appear
identified with symbols naming system functions.</p>



<hr><h2 id="335"><a name="ghost-and-composer-2">9.13 Ghost frames and Allegro Composer</a></h2>

<p id="336">Debugger windows in Allegro Composer do not display ghost frames.</p>



<hr><hr><h2 id="337"><a name="tracer-1">10.0 The tracer</a></h2>

<p id="338">
The tracer provides a way to track or trace when functions are
called. For example, when tracing a function, a message is printed
upon entering and exiting the function.
</p>

<p id="339">
The tracer is invoked at the top level using <a href="tpl-commands/trace.htm"><b>:trace</b></a> and turned off using <a href="tpl-commands/untrace.htm"><b>:untrace</b></a>. The tracer can also be invoked
and exited using the macros <a href="../ansicl/dictentr/traceunt.htm"><b>trace</b></a> and <a href="../ansicl/dictentr/traceunt.htm"><b>untrace</b></a>, which have the same argument syntax as
their top-level command counterparts.
</p>

<p id="340">
The output from <a href="tpl-commands/trace.htm"><b>:trace</b></a> is designed
to be readable - a function being traced may be called many times, and
the entrance and exit from each instance should be obvious, by the
numbers at the beginning of the lines and the indentation of the lines
printed by the traced function. Also printed at the beginning is a
number in brackets, such as [1]. This number indicates the process and
can be associated with an actual process by looking at the information
printed by the <a href="tpl-commands/processes.htm"><b>:processes</b></a> top-level
command, in the Bix (Bindstack Index) column.
</p>

<h4 id="341">
A couple of notes on tracing in the IDE
</h4>

<blockquote>
<ul>
<li id="342">
<b>Output normally goes to the trace dialog</b>: if you are using the
Integrated Development Environment (IDE) with Allegro CL on Windows,
trace output will go to the Trace dialog if that dialog is available,
whether or not it is visible or iconified. (Output will go to that
dialog if it exists and its state, as returned by <a href="operators/cg/s/state.htm"><b>state</b></a>, is <code>:normal</code>,
<code>:maximized</code>, or <code>:icon</code>. Output
will go to the Debug window if the Trace dialog does not exist or has
state <code>:shrunk</code>. Click on the close button of the
Trace dialog if you want output to go to the Debug window.
</li>

<li id="343">
<b>Tracing in event code can be suppressed for a specific
window</b>. If the generic function <a href="operators/cg/i/inhibit-trace-for-object.htm"><b>inhibit-trace-for-object</b></a> returns true for a
particular window, then tracing will be suppressed for code that runs
in event-handling callbacks for that window.  This could be useful for
eliminating extraneous trace output that would otherwise be generated
for tool windows that you are not testing.
</li>

</ul>
</blockquote>

<p id="344"><a href="tpl-commands/trace.htm"><b>:trace</b></a> prints function names
with a package qualifier for functions on symbols not accessible in
the current package. The full package name will be printed unless the
variable <a href="variables/excl/s_print-nickname_s.htm"><code>*print-nickname*</code></a> is <code>t</code>, in which case the package nickname is
printed. </p>

<p id="345">The following are valid options to <a href="tpl-commands/trace.htm"><b>:trace</b></a>:
</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="638">
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><b>Option</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Arguments</b></td>
    <td WIDTH="33%" VALIGN="TOP"><b>Description</b></td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><code>:condition</code></td>
    <td WIDTH="33%" VALIGN="TOP"><i>expr</i></td>
    <td WIDTH="33%" VALIGN="TOP">Trace this function if <i>expr</i> 
    evaluates to a true
    value.</td>
  </tr>
<tr>
<td WIDTH="33%" VALIGN="TOP">
<code>:break-before</code>
</td>
<td WIDTH="33%" VALIGN="TOP">
<i>val</i>
</td>
<td WIDTH="33%" VALIGN="TOP">
The expression <i>val</i> is evaluated just before entering a
function. If <i>val</i> evalates to a non-<code>nil</code>
value, then a new break level is entered. Otherwise, execution
continues. When used in combination with :inside and :not-inside,
breaks only occur when the :inside and :not-inside conditions are
satisfied.
</td>
</tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><code>:break-after</code></td>
    <td WIDTH="33%" VALIGN="TOP"><i>val</i></td>
    <td WIDTH="33%" VALIGN="TOP">The expression <i>val</i> is 
    evaluated just after exiting a
    function. If <i>val</i> is <code>t</code>, then a new 
    break level is entered. Otherwise, execution
    continues. When used in combination with :inside 
    and :not-inside, breaks only occur when the :inside 
    and :not-inside conditions are satisfied.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><code>:break-all</code></td>
    <td WIDTH="33%" VALIGN="TOP"><i>val</i></td>
    <td WIDTH="33%" VALIGN="TOP">The expression <i>val</i> is 
    evaluated just before entering a
    function and just after exiting a function. If <i>val</i> 
    is <code>t</code>, then a new break level is
    entered. Otherwise, execution continues. When used in 
    combination with :inside 
    and :not-inside, breaks only occur when the :inside 
    and :not-inside conditions are satisfied.</td>
</tr>
<tr>
<td WIDTH="33%" VALIGN="TOP">
<code>:inside</code>
</td>
<td WIDTH="33%" VALIGN="TOP">
func
</td>
<td WIDTH="33%" VALIGN="TOP">
Trace this function if Lisp is currently <i>inside</i> a call of the
function <i>func</i>.
<p id="346">
<i>func</i> may also be a list of functions, optionally starting with
the symbols <b>cl:and</b> or <b>cl:or</b>. If neither symbol or
<b>cl:and</b> starts the list (e.g. <code>(cl:and foo1 bar2)</code>
or <code>(foo1 bar2)</code>, tracing
is done when the function to be traced has been called
directly or indirectly by <b>all</b> the functions in the list
(by <b>foo1</b> and <b>bar2</b> in the example). If
<b>cl:or</b> starts the list (e.g. <code>(cl:or foo1 bar2)</code>)
tracing is done when the function to be traced has been called
directly or indirectly by <b>any</b> of the functions in the list
(by <b>foo1</b> or <b>bar2</b> in the example).
</p>
<p id="347">
<code>:inside</code> works in combination with 
<code>:not-inside</code>, described next. Both must be
satisified for tracing to occur.
</p>
<p id="348">
For example, <code>(trace (deeper :inside deep))</code>
would trace the function <b>deeper</b> only when called from 
within a call to <b>deep</b>.
<code>(trace 
(deeper :inside deep :not-inside (cl:or foo1 bar2)))</code>
would trace the function <b>deeper</b> only when called from 
within a call to <b>deep</b> but not within a call to <b>foo1</b>
or <b>bar2</b>. See <a href="#inside-not-inside">Note on inside 
and not inside</a> for a fuller description of a call being
inside another.
</p>
</td>
</tr>
<tr>
<td WIDTH="33%" VALIGN="TOP">
<code>:not-inside</code>
</td>
<td WIDTH="33%" VALIGN="TOP">
func
</td>
<td WIDTH="33%" VALIGN="TOP">
Trace this function if Lisp is not currently <i>inside</i> the
evaluation of the function <i>func</i>.
<p id="349">
<i>func</i> may also be a list of functions, optionally starting with
the symbols <b>cl:and</b> or <b>cl:or</b>. If neither symbol or
<b>cl:and</b> starts the list (e.g. <code>(cl:and foo1 bar2)</code>
or <code>(foo1 bar2)</code>, tracing
is done when the function to be traced has not been called
directly or indirectly by <b>all</b> the functions in the list
(by <b>foo1</b> and <b>bar2</b> in the example). If
<b>cl:or</b> starts the list (e.g. <code>(cl:or foo1 bar2)</code>)
tracing is done when the function to be traced has not been called
directly or indirectly by <b>any</b> of the functions in the list
(by <b>foo1</b> or <b>bar2</b> in the example).
</p>
<p id="350">
<code>:not-inside</code> works in combination with 
<code>:inside</code>, described above. Both must be
satisified for tracing to occur.
</p>
<p id="351">
For example, <code>(trace (deeper :not-inside deep))</code>
would trace the function <b>deeper</b> except when called from 
within a call to <b>deep</b>.
<code>(trace 
(deeper :not-inside deep :inside (cl:or foo1 bar2)))</code>
would trace the function <b>deeper</b> except when called from 
within a call to <b>deep</b> and within a call to <b>foo1</b>
or <b>bar2</b>. See <a href="#inside-not-inside">Note on inside 
and not inside</a> for a fuller description of a call being
inside another.
</p>
</td>
</tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><code>:print-before</code></td>
    <td WIDTH="33%" VALIGN="TOP"><i>expr</i></td>
    <td WIDTH="33%" VALIGN="TOP"><i>expr</i> should either be a single 
    object or a list of
    objects which will be evaluated. The results will be printed 
    before entering the function.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><code>:print-after</code></td>
    <td WIDTH="33%" VALIGN="TOP"><i>expr</i></td>
    <td WIDTH="33%" VALIGN="TOP"><i>expr</i> should either be a single 
    object or a list of
    objects which will be evaluated. The results will be printed 
    after leaving the function.</td>
  </tr>
  <tr>
    <td WIDTH="33%" VALIGN="TOP"><code>:print-all</code></td>
    <td WIDTH="33%" VALIGN="TOP"><i>expr</i></td>
    <td WIDTH="33%" VALIGN="TOP"><i>expr</i> should either be a single 
    object or a list of
    objects which will be evaluated. The results will be printed 
    before entering and after
    leaving the function.</td>
  </tr>

<tr>
<td WIDTH="33%" VALIGN="TOP"><code>:show-stack</code></td>
<td WIDTH="33%" VALIGN="TOP"><i>n</i></td>
<td WIDTH="33%" VALIGN="TOP">Causes stack frames (as printed by
<a href="tpl-commands/bt.htm"><b>:bt</b></a>) to be shown just before the
function being traced is entered. <i>n</i> should a positive
integer, <code>t</code>,
or <code>nil</code>. If a positive integer, that many
stack frames will be shown. <i>n</i> can also
be <code>t</code>, which requests all frames on the stack
to be printed; or <code>nil</code>, which turns off
showing the stack. See the example below.</td>
</tr>

</table>

<h3 id="352"><a name="inside-not-inside">Note on inside and not inside</a></h3>

<p id="353">
A call to function <b>foo</b> is <i>inside</i> a call to function
<b>bar</b> if <b>bar</b> appears on the stack when <b>foo</b> is
called. <b>bar</b> can call <b>foo</b> directly, meaning there is an
explicit call to <b>foo</b> in the code defining <b>bar</b>, or
indirectly, meaning <b>bar</b> calls another function which (perhaps
calls more itermediate functions) which calls <b>foo</b> directly.
</p>
<p id="354">
There are a few special cases. One is caused by tail-merging. Thus,
if <b>bar</b> calls <b>baz</b> which does a tail-merged call to
<b>foo</b>, then <b>foo</b> is considered inside <b>bar</b> but not
inside <b>baz</b>.
</p>
<p id="355">
The other special case is generic functions. If a method is on the
stack, its generic function is also considered to be on the stack,
even though it never will be seen there (meaning you can specify the
generic function rather than the specific method). Thus the following
all work for tracing <b>foo</b> inside a call to <a href="operators/excl/device-read.htm"><b>device-read</b></a> called on a
<code>terminal-simple-stream</code>, but the first will
catch calls to <b>foo</b> inside any <a href="operators/excl/device-read.htm"><b>device-read</b></a> method.
</p>
<pre id="356">
:trace (foo :inside device-read)
:trace (foo :inside #'(method device-read (terminal-simple-stream t t t t)))
:trace (foo :inside ((method device-read (terminal-simple-stream t t t t))))
</pre>

<h3 id="357">Stopping tracing and trace output</h3>

<p id="358">
Tracing of individual objects or all tracing can be stopped with the
<a href="tpl-commands/untrace.htm"><b>:untrace</b></a> command.
</p>

<p id="359">
The value of <a href="../ansicl/dictentr/debug-io.htm"><code>cl:*trace-output*</code></a> is the
where <a href="tpl-commands/trace.htm"><b>:trace</b></a> sends output, which
is normally <a href="../ansicl/dictentr/terminal.htm"><code>cl:*terminal-io*</code></a>.

<a href="../ansicl/dictentr/print-le.htm"><code>cl:*print-level*</code></a>,
<a href="../ansicl/dictentr/print-le.htm"><code>cl:*print-length*</code></a>, <a href="../ansicl/dictentr/print-ar.htm"><code>cl:*print-array*</code></a>, and <a href="../ansicl/dictentr/print-ci.htm"><code>cl:*print-circle*</code></a> are bound to <a href="variables/excl/s_trace-print-level_s.htm"><code>*trace-print-level*</code></a>,
<a href="variables/excl/s_trace-print-length_s.htm"><code>*trace-print-length*</code></a>, <a href="variables/excl/s_trace-print-array_s.htm"><code>*trace-print-array*</code></a>, and <a href="variables/excl/s_trace-print-circle_s.htm"><code>*trace-print-circle*</code></a>
during trace output.
</p>


<h3 id="360">
:show-stack example
</h3>

<pre id="361">
cl-user(1): :tr (car :show-stack 10)
(car)
cl-user(2): (car '(a b))
 0[2]: (car (a b))
 0^      &lt;- (system::..runtime-operation (a b))
 0^      &lt;- (eval (car '(a b)))
 0^      &lt;- (top-level::read-eval-print-one-command nil nil)
 0^      &lt;- (excl::read-eval-print-loop :level 0)
 0^      &lt;- (top-level::top-level-read-eval-print-loop1)
 0^      &lt;- (top-level:top-level-read-eval-print-loop)
 0^      &lt;- (system::..runtime-operation . :unknown-args)
 0^      &lt;- (top-level:start-interactive-top-level
               #&lt;terminal-simple-stream [initial terminal io] fd 0/1 @
                 #x4029b84a&gt;
               #&lt;Function top-level-read-eval-print-loop&gt; nil)
 0^      &lt;- (excl::start-lisp-execution t)
 0[2]: returned a
a
cl-user(3): 
</pre>


<hr><h2 id="362"><a name="tracing-function-objects-2">10.1 Tracing function objects</a></h2>

<p id="363">
<a href="../ansicl/dictentr/traceunt.htm"><b>trace</b></a> and <a href="tpl-commands/trace.htm"><b>:trace</b></a> may be passed function names but
not function objects.  Allegro CL allows specifying function objects
to be traced using the <a href="operators/excl/ftrace.htm"><b>ftrace</b></a> and <a href="operators/excl/funtrace.htm"><b>funtrace</b></a> functions.
</p>
<p id="364">
Each function takes a function specification as an argument. The
function specification can be a function name (as with <a href="../ansicl/dictentr/traceunt.htm"><b>trace</b></a> and <a href="../ansicl/dictentr/traceunt.htm"><b>untrace</b></a>) or a function object (which is not
accepted by <a href="../ansicl/dictentr/traceunt.htm"><b>trace</b></a> and <a href="../ansicl/dictentr/traceunt.htm"><b>untrace</b></a>).
</p>
<p id="365">
<a href="../ansicl/dictentr/traceunt.htm"><b>untrace</b></a> and <a href="tpl-commands/untrace.htm"><b>:untrace</b></a> called with no arguments stop all
tracing, including tracing started by <a href="operators/excl/ftrace.htm"><b>ftrace</b></a> with a function object as an argument,
but you should use <a href="operators/excl/funtrace.htm"><b>funtrace</b></a> to
stop tracing of a function object if you want some tracing to
continue.
</p>
<p id="366">
Here is an example:
</p>
<pre id="367">
cl-user(1): (defun foo () (break &quot;hello&quot;))
foo
cl-user(2): (foo)
Break: hello

Restart actions (select using :continue):
 0: return from break.
 1: Return to Top Level (an &quot;abort&quot; restart).
 2: Abort entirely from this process.
[1c] cl-user(3): :zo
Evaluation stack:

   (break &quot;hello&quot;)
 -&gt;(foo)
   (eval (foo))
   (tpl:top-level-read-eval-print-loop)
   (tpl:start-interactive-top-level
      #&lt;terminal-simple-stream [initial terminal io] fd 0/1 @
        #x7115d9da&gt;
      #&lt;Function top-level-read-eval-print-loop&gt; ...)
[1c] cl-user(4): :func
#&lt;Interpreted Function foo&gt;
[1c] cl-user(5): (ftrace *)
#&lt;Interpreted Function foo&gt;
[1c] cl-user(6): :prt
cl-user(7): (foo) ;; :prt evaluation
 0: (foo)
Break: hello

Restart actions (select using :continue):
 0: return from break.
 1: Return to Top Level (an &quot;abort&quot; restart).
 2: Abort entirely from this process.
[1c] cl-user(8): :cont
 0: returned nil
nil
cl-user(9): (funtrace #'foo)
#&lt;Interpreted Function foo&gt;
cl-user(10):
</pre>




<hr><h2 id="368"><a name="trace-example-2">10.2 Trace example</a></h2>

<p id="369">In the following example, we trace the factorial function and then
give an example of tracing one function inside another.</p>

<pre id="370">
;; Note: this manual is generic over several implementations.
;; The stack may differ from one implementation to another
;; so the output you see may differ in detail from what is
;; reproduced here.
cl-user(38): (defun fact (n)
               (cond ((= n 1) 1)
                     (t (* n (fact (1- n))))))
fact
cl-user(39): (fact 4)
24
cl-user(40): :trace fact
(fact)
cl-user(41): (fact 4)
 0[1]: (fact 4)
   1[1]: (fact 3)
     2[1]: (fact 2)
       3[1]: (fact 1)
       3[1]: returned 1
     2[1]: returned 2
   1[1]: returned 6
 0[1]: returned 24
24
cl-user(42): (defun deep (x) (deeper (list x)))
deep
cl-user(43): (defun deeper (x) (format t &quot;~&amp;~s~%&quot; x))
deeper
cl-user(44): (deep 10)
(10)
nil
cl-user(45): :tr (deeper :inside deep)
(deeper)
cl-user(46): (deeper 10)
10
nil
cl-user(47): (deep 10)
 0[1]: (deeper (10))
(10)
 0[1]: returned nil
nil
cl-user(48): :tr (deeper :break-before t)
(deeper)
cl-user(49): (deep 10)
 0[1]: (deeper (10))
Break: traced call to deeper

Restart actions (select using :continue):
 0: return from break.
 1: Return to Top Level (an &quot;abort&quot; restart).
 2: Abort entirely from this process.
[1c] cl-user(50): :zo
Evaluation stack:

   (break &quot;traced call to ~s&quot; deeper)
 -&gt;(deep 10)
   (eval (deep 10))
   (tpl:top-level-read-eval-print-loop)
   (tpl:start-interactive-top-level
      #&lt;terminal-simple-stream [initial terminal io] fd 0/1 @ #x4095faa&gt;
      #&lt;Function top-level-read-eval-print-loop&gt; ...)
[1c] cl-user(51): :cont
(10)
 0[1]: returned nil
nil

;;  The [1] that appears in the trace output identified the process
;;  being traced. It can be associated with an actual process
;;  by looking at the output of the :processes top-level
;;  command (nicknamed :proc), under the Bix (bindstack index)
;;  column. We see from the output it is the Initial 
;;  Lisp Listener.
cl-user(52): :proc
P Bix Dis   Sec  dSec  Priority  State   Process Name, Whostate, Arrest
*   1  16   279   4.5         0 runnable Initial Lisp Listener
*   3   0     0   0.0         0 waiting  Connect to Emacs daemon,
                                           waiting for input
*   4   0     0   0.0         0 inactive Run Bar Process
*   6   0     2   0.0         0 waiting  Editor Server, waiting for input
cl-user(53): 

;;  In the next example, we define functions that call other
;;  functions after printing messages about what they are calling
;;  what called them. This illustrates the :inside and :not-inside
;;  options.

cl-user(53): (defun foo ()
	      (progn (format t &quot;foo calling bar~%&quot;) (bar 'foo))
	      (progn (format t &quot;foo calling baz~%&quot;) (baz 'foo))
	      (progn (format t &quot;foo calling bzz~%&quot;) (bzz 'foo)))
foo
cl-user(54): (defun bar (from)
	      (progn (format t &quot;bar calling baz from ~S~%&quot; from)
		     (baz 'bar))
	      (progn (format t &quot;bar calling bzz from ~S~%&quot; from)
		     (bzz 'bar)))
bar
cl-user(55): (defun baz (from)
	      (progn (format t &quot;baz calling bzz from ~S~%&quot; from)
		     (bzz 'baz)))
baz
cl-user(56): (defun bzz (from)
	      (format t &quot;bzz called from ~S~%&quot; from))
bzz

;;  Here is an untraced call to FOO:
cl-user(57): (foo)
foo calling bar
bar calling baz from foo
baz calling bzz from bar
bzz called from baz
bar calling bzz from foo
bzz called from bar
foo calling baz
baz calling bzz from foo
bzz called from baz
foo calling bzz
bzz called from foo
nil

;;  Here we trace BZZ when called inside both FOO and BAZ (:inside
;;  followed by a list contains an implicit AND, so the call
;;  must be inside all listed functions):
cl-user(58): :trace (bzz :inside (foo baz))
(bzz)
cl-user(59): (foo)
foo calling bar
bar calling baz from foo
baz calling bzz from bar
 0[1]: (bzz baz)
bzz called from baz
 0[1]: returned nil
bar calling bzz from foo
bzz called from bar
foo calling baz
baz calling bzz from foo
 0[1]: (bzz baz)
bzz called from baz
 0[1]: returned nil
foo calling bzz
bzz called from foo
                     ;; this call to BZZ is not traced since
                     ;; it is not inside BAZ.
nil
cl-user(60): :untrace   ;;  We remove all tracing
nil

;;  Now tracing will happen when inside FOO but not inside BAR:
cl-user(61): :trace (bzz :inside foo :not-inside bar)
(bzz)
cl-user(62): (foo)
foo calling bar
bar calling baz from foo
baz calling bzz from bar
bzz called from baz           ;;  inside BAR so not traced.
bar calling bzz from foo
bzz called from bar
foo calling baz
baz calling bzz from foo      ;;  not inside BAR
 0[1]: (bzz baz)
bzz called from baz
 0[1]: returned nil
foo calling bzz
 0[1]: (bzz foo)
bzz called from foo           ;;  Again, not inside BAR
 0[1]: returned nil
nil
cl-user(63): 
</pre>

<p id="371">CLOS methods can be traced by name. Here is an example.</p>

<pre id="372">
user(16): (defmethod my-function ((x integer))
            (cons x :integer))
#&lt;standard-method my-function (integer)&gt;
user(17): (my-function 1)
(1 . :integer)
user(18): (trace ((method my-function (integer))))
(method my-function (integer)))
user(19): (my-function 1)
0: ((method my-function (integer)) 1)
0: returned (1 . :integer)
(1 . :integer)
user(20): (untrace (method my-function (integer)))
((method my-function (integer)))
user(21): (my-function 1)
(1 . :integer)
user(22):
</pre>



<hr><h2 id="373"><a name="tracing-methods-2">10.3 Tracing setf, :before, and :after methods and internal functions</a></h2>

<p id="374">
Methods and internal functions are typically named by function specs
(see <a href="implementation.htm#function-specs-1">Function specs (fspecs)</a> in
<a href="implementation.htm">implementation.htm</a>). This section describes how
to trace such things, concetrating on setf, :before and :after methods
and internal functions (such as those defined by <a href="../ansicl/dictentr/fletlabe.htm"><b>flet</b></a> or <a href="../ansicl/dictentr/fletlabe.htm"><b>labels</b></a>).
</p>
<p id="375">
Here is how to trace <b>setf</b>, :before and :after methods. Note
that the methods must be defined before they can be traced (we have
not done that -- the examples simply show the format of the calls to
<a href="../ansicl/dictentr/traceunt.htm"><b>trace</b></a> and <a href="../ansicl/dictentr/traceunt.htm"><b>untrace</b></a>):
</p>

<pre id="376">
(trace ((method (setf slot-1) (t baz))))
(trace ((method foo :before (integer))))
(trace ((method foo :after (integer))))
</pre>

<p id="377">The extra set of parentheses is required to avoid confusion with
specifying trace options (they are specified with a list whose car is
the function to be traced and whose cdr is a possibly empty list of
options). Note that the extra set of parentheses is not used with
<strong>untrace</strong>:</p>

<pre id="378">
(untrace (method (setf slot-1) (t baz)))
(untrace (method foo :before (integer)))
(untrace (method foo :after (integer)))
</pre>

<p id="379">
A generic function itself can be traced exactly like any other
function.
</p>

<p id="380">
Here is an example tracing an internal function, defined in a <a href="../ansicl/dictentr/fletlabe.htm"><b>labels</b></a> or <a href="../ansicl/dictentr/fletlabe.htm"><b>flet</b></a>. Note that the form containing the call to
<a href="../ansicl/dictentr/fletlabe.htm"><b>labels</b></a> or <a href="../ansicl/dictentr/fletlabe.htm"><b>flet</b></a> must be compiled.
</p>
<pre id="381">
cl-user(1): (defun myfunc (a b c)
              (labels ((cubit (arg) (expt arg 3)))
                (if (&gt; a b)
                    (+ (cubit a ) (cubit c))
                  (+ (cubit b) (cubit c)))))
myfunc
cl-user(2): (compile 'myfunc)
myfunc
nil
nil
cl-user(4): (trace ((labels myfunc cubit)))
((labels myfunc cubit))
cl-user(5): (myfunc 1 2 3)
 0: ((labels myfunc cubit) 2)
 0: returned 8
 0: ((labels myfunc cubit) 3)
 0: returned 27
35
cl-user(6):
</pre>

<p id="382">
Here is another example. Again, the form must be compiled.
</p>

<pre id="383">
;;; File foo.cl:

(in-package :cl-user)
(defclass thing ()
  ((s1 :initform 1 :initarg :s1 :accessor s1)
   (s2 :initform 2 :initarg :s2 :accessor s2)
   (s3 :initform 3 :initarg :s3 :accessor s3)))

(defmethod doit ((arg thing))
  (labels ((cubit (arg) (expt arg 3)))
             (if (&gt; (s1 arg) (s2 arg))
                 (+ (cubit (s1 arg) ) (cubit (s3 arg)))
              (+ (cubit (s2 arg)) (cubit (s2 arg))))))

;;; End of file foo.cl:

cl-user(1): :ld foo.cl
; loading /home/user1/foo.cl
cl-user(2): (trace ((labels (method doit (thing)) cubit)))
Error: `(labels (method doit (thing)) cubit)' is not fbound
 [condition type: undefined-function]

restart actions (select using :continue):
0: return to Top Level (an &quot;abort&quot; restart).
1: Abort entirely from this process.

        ;;;  The form must be compiled so that internal functions
        ;;;  can be traced.

[1] CL-USER(3): :res
cl-user(4) :cload foo.cl
;;; Compiling file foo.cl
;;; Writing fasl file foo.fasl
;;; Fasl write complete
cl-user(5): (trace ((labels (method doit (thing)) cubit)))
((labels (method doit (thing)) cubit))
cl-user(6): (setf thing1 (make-instance 'thing))
#&lt;thing @ #x7150fac2&gt;
cl-user(7): (doit thing1)
 0: ((labels (method doit (thing)) cubit) 2)
 0: returned 8
 0: ((labels (method doit (thing)) cubit) 2)
 0: returned 8
16
cl-user(8): 
</pre>




<hr><hr><h2 id="384"><a name="stepper-1">11.0 The stepper</a></h2>

<p id="385">
The stepper allows the user to watch and control the evaluation of
Lisp expressions, either inside certain functions or over certain
expressions. When stepping is turned on, evaluation of all expressions
is done in single-step mode - after evaluating one form, a step
read-eval-print loop is entered, from which the user may continue or
abort. 
</p>
<p id="386">
<em>Note</em>: starting in release 6.0, it is only useful to step
through <b>compiled code</b>. (In earlier release, it was only useful
to step through interpreted code.) Because of the changes that allow
stepping through, you cannot effectively step through interpreted
code. (Doing so results in stepping through the interpreter itself,
with hundreds of uninteresting steps). Further, see <a href="variables/compiler/verify-funcalls-switch.htm"><code>verify-funcalls-switch</code></a>. <a href="../ansicl/dictentr/funcall.htm"><b>funcall</b></a>'ed functions in certain
cases in compiled code will not be caught by the stepper if the call
was compiled with that compiler switch false.
</p>
<p id="387">
<strong>If you ever see the entry</strong>
</p>
<pre id="388">
&lt;excl::interpreted-funcall ...&gt;
</pre>
<p id="389">
<strong>immediately enter the command <a href="tpl-commands/sover.htm"><b>:sover</b></a>.</strong>
</p>
<p id="390">
If you instead take another step (by hitting Return, for example),
get out of stepping by entering
</p>
<pre id="391">
[step] cl-user(20): :step nil
[step] cl-user(21): :sover
</pre>
<p id="392">
and then you can start stepping afresh.
</p>

 

<p id="393">
The <a href="tpl-commands/step.htm"><b>:step</b></a> top-level command is
similar to the standard Common Lisp macro step. 
</p>

<p id="394">
With no arguments or an argument of <code>nil</code>,
<a href="tpl-commands/step.htm"><b>:step</b></a> turns off stepping. With an
argument of <code>t</code>, stepping is turned on
globally. Otherwise the arguments must be symbols naming functions,
and stepping is done only when inside one of the functions given to
:step.
</p>

<p id="395">Once stepping is turned on, the top level recognizes three more
commands: :scont, :sover, and carriage return (which is a
synonym for <a href="tpl-commands/scont.htm"><b>:scont</b></a> 1). Also, the
top-level prompt for read-eval-print loops when stepping is enabled is
prefixed with [step],
as a reminder that the above step commands are available. </p>

<hr><h2 id="396"><a name="turning-stepping-off-2">11.1 Turning stepping off</a></h2>

<p id="397">
Entering <code>:step nil</code> turns off stepping. You may have
to then enter <code>:sover</code> to end the current stepping
through a function. Turning off stepping is very useful when
you accidently start stepping through an interpreted function.
</p>

<pre id="398">
user(45): (defun fact (n) (if (= n 1) 1 (* n (fact (1- n)))))
fact
user(46): :step fact
user(47): (fact 3)
 1: (fact 3)

[step] user(48): 
  2: (excl::interpreted-funcall #&lt;Interpreted Function fact&gt; 1 32864546 0)

    ;; :sover here would get you out

[step] user(48): 
   3: (excl::extract-special-decls ((block fact (if # 1 #))))

    ;; it is now too late. Turn stepping off.

[step] user(48): :step nil
[step] user(49): :sover
   result 3: nil  ((block fact (if (= n 1) 1 (* n #))))
  result 2: 6
 result 1: 6
6
user(50): 
</pre>



<hr><h2 id="399"><a name="other-stepping-commands-2">11.2 Other stepping commands and variables</a></h2>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="529">
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><b>Command</b></td>
    <td WIDTH="21%" VALIGN="TOP"><b>Arguments</b></td>
    <td WIDTH="49%" VALIGN="TOP"><b>Description</b></td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><a href="tpl-commands/scont.htm"><b>:scont</b></a></td>
    <td WIDTH="21%" VALIGN="TOP"><i>n</i></td>
    <td WIDTH="49%" VALIGN="TOP">Continue stepping, for n expressions, beginning with the
    evaluation of the last expression printed by the stepper. If n is not provided, it
    defaults to 1.</td>
  </tr>
  <tr>
    <td WIDTH="30%" VALIGN="TOP"><a href="tpl-commands/sover.htm"><b>:sover</b></a></td>
    <td WIDTH="21%" VALIGN="TOP"> </td>
    <td WIDTH="49%" VALIGN="TOP">Evaluate the current expression in normal, non-stepping mode.</td>
  </tr>
</table>

<p id="400"><code>cl:*print-level*</code> and
<code>cl:*print-length*</code> are bound to <a href="variables/excl/s_step-print-level_s.htm"><code>*step-print-level*</code></a> and <a href="variables/excl/s_step-print-length_s.htm"><code>*step-print-length*</code></a> during
stepper output. </p>



<hr><h2 id="401"><a name="stepping-example-2">11.3 Stepping example</a></h2>

<p id="402">The example below demonstrates the use of the stepper. In it, we
define fact, the factorial function, and then step through it. We use
carriage returns for each single step. Notice particularly the
difference between stepping through fact when it runs interpreted and
when it runs compiled. </p>

<pre id="403">
;; Note: this manual is generic over several implementations.
;; The stack may differ from one implementation to another
;; so the output you see may differ in detail from what is
;; reproduced here.
 
user(3): (defun fact (n) 
           (if (= n 1) 1 (* n (fact (1- n)))))
fact
user(4): (fact 3)
6
user(5): (compile 'fact)
fact
user(6): :step nil
                      ;; we turn all stepping off
user(7): (step fact)
;; Here we use the function form of step.
;; It has the same effect as :step fact.

user(8): (fact 3)
 1: (fact 3)

[step] user(9): 
  2: (excl::*_2op 2 1)

[step] user(9): 
  result 2: 2
  2: (excl::*_2op 3 2)

[step] user(8): 
  result 2: 6
 result 1: 6
6
user(9): 

</pre>



<hr><hr><h2 id="404"><a name="ldb-stepper-1">12.0 The Lisp DeBug (ldb) stepper</a></h2>

<p id="405">The ldb stepping facility allows the user to place breakpoints at
various instruction-level locations. Note that the ldb-stepping
functionality may not be included in the running image. Evaluate
<code>(require :lldb)</code> to ensure that the functionality is
loaded before trying to use the facility.</p>

<p id="406">
The ldb stepper utilizes several top-level commands to create the
stepping environment.
</p>

<p id="407">They are:</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="638">
  <tr>
    <td WIDTH="18%" VALIGN="TOP"><a href="tpl-commands/ldb.htm"><b>:ldb</b></a></td>
    <td WIDTH="82%" VALIGN="TOP">Controls the installing (enabling) and
    uninstalling (disabling) of breakpoints, and the establishment of ldb mode.</td>
  </tr>
  <tr>
    <td WIDTH="18%" VALIGN="TOP"><a href="tpl-commands/break.htm"><b>:break</b></a></td>
    <td WIDTH="82%" VALIGN="TOP">Allows the user to add or delete breakpoints.</td>
  </tr>
  <tr>
    <td WIDTH="18%" VALIGN="TOP"><a href="tpl-commands/step.htm"><b>:step</b></a></td>
    <td WIDTH="82%" VALIGN="TOP">(Modified from earlier UNIX releases.) When in ldb-step mode,
    the step command recognizes several sub-commands as its first argument. See the full
    description for more information.</td>
  </tr>
  <tr>
    <td WIDTH="18%" VALIGN="TOP"><a href="tpl-commands/local.htm"><b>:local</b></a></td>
    <td WIDTH="82%" VALIGN="TOP">(Modified from earlier UNIX releases.) When a
    breakpoint is hit, the default current frame is the register context in which the
    breakpoint occurred (and thus ldb-step mode was entered). See the full description for
    more information.</td>
  </tr>
  <tr>
    <td WIDTH="18%" VALIGN="TOP"><code>[return]</code></td>
    <td WIDTH="82%" VALIGN="TOP">(Modified from earlier UNIX releases.) When in ldb-step mode,
    causes the previous step subcommand to be re-executed. If there was no previous step
    subcommand, a <a href="tpl-commands/step.htm"><b>:step</b></a> 
    &nbsp;<code>over</code> is assumed.</td>
  </tr>
</table>

<hr><h2 id="408"><a name="entering-ldb-stepper-2">12.1 Entering and Exiting the ldb stepper</a></h2>

<p id="409">Before starting ldb-mode stepping, be sure that the functionality
is loaded by evaluating:</p>

<pre id="410">
(require :lldb)
</pre>

<p id="411">Entering ldb-mode can then be done in one of two ways: </p>

<ol>
  <li id="412">Use the <code>:ldb t</code> command to start debugging</li>
  <li id="413">Use the <a href="operators/excl/with-breakpoints-installed.htm"><b>with-breakpoints-installed</b></a>
    macro around a form.</li>
</ol>

<p id="414">Either method allows breakpoints to be hit by installing them. If
the <a href="tpl-commands/break.htm"><b>:break</b></a> command is used after
the <a href="tpl-commands/ldb.htm"><b>:ldb</b></a> command, any new
breakpoints will be properly installed.</p>

<p id="415">Once a break is hit, a message is printed out, and ldb-step mode is
entered. In this mode, breakpoints are not installed, but the
top-level is primed to do fast installation/deinstallation/stepping of
the breakpoints with little keyboard input.</p>



<hr><h2 id="416"><a name="ldb-functional-interface-2">12.2 Ldb stepper functional interface</a></h2>

<p id="417">The ldb stepper provides the following functional interface. </p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="638">
  <tr>
    <td WIDTH="45%" VALIGN="TOP"><a href="operators/excl/add-breakpoint.htm"><b>add-breakpoint</b></a></td>
    <td WIDTH="55%" VALIGN="TOP">Adds a breakpoint.</td>
  </tr>
  <tr>
    <td WIDTH="45%" VALIGN="TOP"><a href="operators/excl/delete-breakpoint.htm"><b>delete-breakpoint</b></a></td>
    <td WIDTH="55%" VALIGN="TOP">Deletes an existing breakpoint.</td>
  </tr>
  <tr>
    <td WIDTH="45%" VALIGN="TOP"><a href="operators/excl/with-breakpoints-installed.htm"><b>with-breakpoints-installed</b></a></td>
    <td WIDTH="55%" VALIGN="TOP">Evaluates a body with breakpoints installed during the
    evaluation.</td>
  </tr>
</table>



<hr><h2 id="418"><a name="ldb-example-2">12.3 Ldb stepping example run</a></h2>

<p id="419">
This example run is on a linux x86 version. The output on different
platforms will be different.  Comments are added within ;[ ]:
</p>

<pre id="420">
cl-user(1): (require :lldb)
Fast loading lldb.fasl
cl-user(2): :br count 17 ;[add a breakpoint (but do not install)]
Adding #&lt;Function count&gt;: 17
17: 89 45 dc movl [ebp-36],eax ; item
cl-user(3): (count #\a &quot;abacad&quot;)
3 ;[no breakpoints had been installed]
cl-user(4): :ldb t ;[start things out]
[ldb] cl-user(4): (count #\a &quot;abacad&quot;)
Hit breakpoint at func = #&lt;Function count&gt;, pc=17
breakpoint-&gt; 17: 89 45 dc movl [ebp-36],eax ; item
[ldb-step] cl-user(5): 
Hit breakpoint at func = #&lt;Function count&gt;, pc=20
temp brkpt-&gt; 20: 89 55 cc movl [ebp-52],edx ; sequence
[ldb-step] cl-user(6): :br ;[ask to show current breakpoints]
#&lt;Function count&gt;: (17 (20 :temp))
[ldb-step] cl-user(7): :loc :%eax ;[eax is the first arg on x86]
#\a
[ldb-step] cl-user(8): :loc :%edx ;[edx is the second arg on x86]
&quot;abacad&quot;
[ldb-step] cl-user(9): :step into ;[this will have no effect until later]
Hit breakpoint at func = #&lt;Function count&gt;, pc=23
temp brkpt-&gt; 23: 8d 49 fe leal ecx,[ecx-2]
[ldb-step] cl-user(9): 
Hit breakpoint at func = #&lt;Function count&gt;, pc=26
temp brkpt-&gt; 26: 8d 45 10 leal eax,[ebp+16] ; (argument 2)
[ldb-step] cl-user(9): 
Hit breakpoint at func = #&lt;Function count&gt;, pc=29
temp brkpt-&gt; 29: 8d 95 5c ff leal edx,[ebp-164]
ff ff 
[ldb-step] cl-user(9): 
Hit breakpoint at func = #&lt;Function count&gt;, pc=35
temp brkpt-&gt; 35: 33 db xorl ebx,ebx
[ldb-step] cl-user(9): 
Hit breakpoint at func = #&lt;Function count&gt;, pc=37
temp brkpt-&gt; 37: b3 c8 movb bl,$200
[ldb-step] cl-user(9): 
Hit breakpoint at func = #&lt;Function count&gt;, pc=39
temp brkpt-&gt; 39: ff 57 4f call *[edi+79] ; kwdscan
[ldb-step] cl-user(9): ;[note that primcalls are _not_ stepped into]
Hit breakpoint at func = #&lt;Function count&gt;, pc=42
temp brkpt-&gt; 42: 8d 9d 5c ff leal ebx,[ebp-164]
ff ff 
[ldb-step] cl-user(9): 
[some stepping deleted here]
Hit breakpoint at func = #&lt;Function count&gt;, pc=155
temp brkpt-&gt; 155: 3b 7d e0 cmpl edi,[ebp-32] ; end
[ldb-step] cl-user(9): 
Hit breakpoint at func = #&lt;Function count&gt;, pc=158
temp brkpt-&gt; 158: 0f 85 93 00 jnz 311
00 00 
[ldb-step] cl-user(9): 
Hit breakpoint at func = #&lt;Function count&gt;, pc=164
temp brkpt-&gt; 164: 8b 45 cc movl eax,[ebp-52] ; sequence
[ldb-step] cl-user(9): 
Hit breakpoint at func = #&lt;Function count&gt;, pc=167
temp brkpt-&gt; 167: 8b 9f 9f fe movl ebx,[edi-353] ; length
ff ff 
[ldb-step] cl-user(9): 
Hit breakpoint at func = #&lt;Function count&gt;, pc=173
temp brkpt-&gt; 173: b1 01 movb cl,$1
[ldb-step] cl-user(9): :loc :%eax
&quot;abacad&quot;
[ldb-step] cl-user(10): :step into
Hit breakpoint at func = #&lt;Function count&gt;, pc=175
temp brkpt-&gt; 175: ff d7 call *edi
[ldb-step] cl-user(11): 
Hit breakpoint at func = #&lt;Function length&gt;, pc=0
temp brkpt-&gt; 0: 8b c8 movl ecx,eax
[ldb-step] cl-user(11): 
Hit breakpoint at func = #&lt;Function length&gt;, pc=2
temp brkpt-&gt; 2: 80 e1 03 andb cl,$3
[ldb-step] cl-user(11): :br ;[check breakpoints again]
#&lt;Function count&gt;: (17)
#&lt;Function length&gt;: ((2 :temp))
[ldb-step] cl-user(12): :br nil ;[turn off all breakpoints]
[ldb-step] cl-user(13): 
3 ;[get right answer]
[ldb] cl-user(13): 

</pre>




<hr><hr><h2 id="421"><a name="source-step-1">13.0 The source stepper</a></h2>


<p id="422">
<b>The source stepper is not available on Sparc or AIX platforms.</b>
</p>

<p id="423">
The source stepper displays source code while stepping through a
form. On platforms that support the IDE, the source stepper is
associated with the new <a href="ide-menus-and-dialogs/stepper-dialog.htm">Stepper Dialog</a>.
</p>
<p id="424">
In order for information to be available to the source stepper,
files must be compiled while the compiler
switch <a href="variables/compiler/save-source-level-debug-info-switch.htm"><code>save-source-level-debug-info-switch</code></a>
returns true, which it initially does whenever the debug optimization
quality is 3.
</p>
<p id="425">
When <a href="variables/compiler/save-source-level-debug-info-switch.htm"><code>save-source-level-debug-info-switch</code></a> is
true, the compiler writes annotation information to the fasl file it
produces. It does not produce different code: the same code is
produced regardless of the value of <a href="variables/compiler/save-source-level-debug-info-switch.htm"><code>save-source-level-debug-info-switch</code></a>. But
when the swicth is true, the annotations added to the fasl file make
the fasl file bigger.
</p>
<p id="426">
Annotated file should be loaded while the
variable <a href="variables/excl/s_load-source-file-info_s.htm"><code>*load-source-file-info*</code></a> is true, but teh
system will prompt for the name of the neseccary file if the
information is not loaded when the fasl file is loaded.
</p>
<p id="427">
We illustrate the interface with a simple example. The
function <b>foo</b> is defined in the file <b>step.cl</b>:
</p>

<pre id="428">
(in-package :user)

(defun foo (file) 
  (with-open-file (s file :direction :input)
    (let ((fm (read s)))
      (format t "~S~%" fm))))
</pre>

<p id="429">
As the transcript shows, we set the value of the debug optimize
quality to 3, then compile step.cl and load step.fasl. We then but a
breakpoint at foo and start the ldb debugger. Then we call foo. As we
step through, the form being executed is shown. Note that the
with-open-file macro is first shown unexpended nut is expanded when
entered.
</p>
<pre id="430">
cl-user(13): :opt

A response of ? gets help on possible answers.

compiler optimize safety setting (0 is fastest): [1] 
compiler optimize space setting: [1] 
compiler optimize speed setting (3 is fastest): [1] 
compiler optimize debug setting (3 is maximum): [2] 3
compiler optimize compilation-speed setting: [1] 

Compiler optimize setting is
     (declaim (optimize (safety 1) (space 1) (speed 1) (debug 3)
               (compilation-speed 1)))
cl-user(14): :cf step.cl
;;; Compiling file step.cl
;;; Writing fasl file step.fasl
;;; Fasl write complete
cl-user(15): :ld step.fasl
; Fast loading /net/gemini/home/dm/step.fasl
cl-user(16): :br foo
; Autoloading for excl::breakpoint-1:
; Fast loading from bundle code/lldb.fasl.
Adding #&lt;Function foo&gt;: 0
break: lev=0 pc=0 rec=0               form=(defun
                                            foo
                                            (file)
                                            (with-open-file
                                             (s file :direction :input)
                                             (let (#) (format t &quot;~S~%&quot; fm))))
Possible slide directions: (into over across)
Current step/slide type: over/into
cl-user(17): :ldb t
[ldb] cl-user(18): (foo &quot;sfile.cl&quot;)

Hit breakpoint at func = #&lt;Function foo&gt;, pc=0
break: lev=0 pc=0 rec=0               form=(defun
                                            foo
                                            (file)
                                            (with-open-file
                                             (s file :direction :input)
                                             (let (#) (format t &quot;~S~%&quot; fm))))
Possible slide directions: (into over across)
Current step/slide type: over/into
[ldb-step] cl-user(19): 

Hit breakpoint at func = #&lt;Function foo&gt;, pc=34
break: lev=1 pc=34 rec=1              form=(block
                                            foo
                                            (with-open-file
                                             (s file :direction :input)
                                             (let (#) (format t &quot;~S~%&quot; fm))))
Possible slide directions: (out over across)
Current step/slide type: over/into
[ldb-step] cl-user(19): 

Entering form from contour:
break: lev=1 pc=34 rec=2              form=(with-open-file
                                            (s file :direction :input)
                                            (let
                                             ((fm #))
                                             (format t &quot;~S~%&quot; fm)))
Possible slide directions: (into over across back)
Current step/slide type: over/into
[ldb-step] cl-user(19): 

Sliding to same pc at level=2
break: lev=2 pc=34 rec=3              form=(let
                                            ((s (open file :direction :input))
                                             (#:g9 t))
                                            (unwind-protect
                                             (multiple-value-prog1
                                              (progn #)
                                              (setq #:g9 nil))
                                             (when
                                              (streamp s)
                                              (close s :abort #:g9))))
Possible slide directions: (out over across)
Current step/slide type: over/into
[ldb-step] cl-user(19): 

Hit breakpoint at func = #&lt;Function foo&gt;, pc=50
break: lev=2 pc=50 rec=4              form=(open file :direction :input)
Possible slide directions: (across back)
Current step/slide type: over/into
[ldb-step] cl-user(19): 

Hit breakpoint at func = #&lt;Function foo&gt;, pc=55
break initializing s to the result of evaluating (open file :direction :input)

level=2 pc=55 rec=5                   subform: (let ((s
                                                      (open
                                                       file
                                                       :direction
                                                       :input))) ...)
Possible slide directions: (across back)
Current step/slide type: over/into
[ldb-step] cl-user(19): :step cont  ;; this goes to the next breakpoint
(in-package :user)
nil
[ldb] cl-user(20): :ldb nil  ;; this stops stepping
cl-user(21): 
</pre>

<h2 id="431">
slide options
</h2>
<p id="432">
At each step, you are given some slide options, such as <b>over</b>,
<b>into</b>, <b>across</b>, <b>out</b>, and <b>back</b>. Not all
options are available at every step. You can use
the <a href="tpl-commands/slide.htm"><b>:slide</b></a> top-level command with
the type of sliding or the <a href="tpl-commands/step.htm"><b>:step</b></a>
command at the prompt.
</p>
<p id="433">
In general, sliding is a conceptual way to navigate around a function,
in spite of the fact that there is no mouse to point to select the
form you want (with the <a href="ide-menus-and-dialogs/stepper-dialog.htm">Stepper Dialog</a> in the IDE, you can use
the moude to indicate what you wish to do). In the tty interface, the
<a href="tpl-commands/slide.htm"><b>:slide</b></a> command is the mechanism.
The :slide command does not after the state of computation (that is
down with actions like a carriage return or <code>:step cont</code>) but
rather affects what form is being examined.
</p>




<hr><hr><h2 id="434"><a name="gdb-support-1">Appendix A: gdb (or dbx or windbg) interface</a></h2>

<p id="435">
The Allegro CL <b>gdb</b> interface is a mixture of gdb <b>call</b>
commands and other low-level gdb commands to produce debugging output
useful for lisp debugging.  Some other debuggers, such as the
<b>dbx</b> that is available on Tru64 alpha system, and <b>windbg</b>
on XP systems, also provide a <b>call</b> command (it is called
<b>.call</b> on windbg) and can thus also be used with this interface.
</p>
<p id="436">
Note this interface is by no means complete, and is known to have
bugs. It has been tested on the following platforms:
</p>
<ul>
<li id="437">

linux (x86 and amd64)

</li>
<li id="438">

freebsd (x86)

</li>
<li id="439">

Tru64 (32 and 64-bit, dbx only)

</li>
<li id="440">

Windows XP/64 (windbg <b>.call</b> instruction)

</li>
<li id="441">

Solaris (sparc 32-bit only, dbx only)

</li>
<li id="442">

MacOSX (intel 32-bit only)

</li>
</ul>

<p id="443">
There are currently nine external functions and four variables in this
interface. Eight of the functions are paired, differing only in where
the output is directed.
</p>

<h3 id="444">
void lisp_output_object(LispVal obj)
</h3>

<blockquote>
<p id="445">
Output a printed representation of the object to file-descriptor 1.
<i>obj</i> is a tagged representation of a lisp value.
</p>
<p id="446">
Current limitations:  many, including:
</p>
<ol>
<li id="447">
Symbols are not qualified with their packages.

</li>
<li id="448">

Many objects are only described in a very high-level way, such as
&lt;struct: 0x12345&gt; rather than describing them in more detail, e.g.
like stating the name of the struct.

</li>
<li id="449">

Element types of vectors are not stated, except for strings, which are specially printed as strings. 

</li>
</ol>

<p id="450">
Such objects are printed with angle-brackets only, rather than in a
way that might confuse the reader into thinking that the printing was
being done in a lispy way (such as #&lt;...&gt; for unreadable
objects).
</p>

</blockquote>

<h2 id="451">
Notes about current frame functions
</h2>

<p id="452">
This interface has a notion of a "current" frame.  When
<b>lisp_zo()</b> (or <b>lisp_zo_aux()</b>) is successful, the frame it
first finds is remembered as the current frame.  Other functions can
operate on the current frame to move up or down in the stack.  Care
must be taken to call
<b>lisp_zo()</b> with a nonzero frame argument after a breakpoint, in
case the running program has removed the stack frames that had been
remembered by the debugger.
</p>
<p id="453">
The arguments are unsigned nats, which are defined formally in the
file <b>misc/lisp.h</b> (in the <b>misc/</b> subdirectory of the
Allegro directory), but which are typically positive integers. The
<b>out</b> argument to the <b>_aux</b> functions should be a pointer
to a C stream suitable for output.
</p>

<h3 id="454">
void lisp_zo(unsigned nat frame, unsigned nat n)
<br>
void lisp_zo_aux(unsigned nat frame, unsigned nat n, FILE * out)
</h3>
<blockquote>

<p id="455">
Print to file descriptor 1 a backtrace from the specified frame, for
<b><i>n</i></b> frames. <b>lisp_zo()</b> prints to
stdout, while <b>lisp_zo_aux()</b> prints to the location specified by
the <i>out</i> argument.
</p>
<p id="456">
Frames are printed in function call or funcall format when possible,
otherwise just the names of the functions are printed as function
objects.  When a frame represents a C function, its saved program
counter is printed in a C form.  If the frame is a "runtime system"
frame (linked in as C/asm, but lisp-savvy) it is annotated as "rs:".
</p>
<p id="457">
If <b><i>frame</i></b> is given as 0, then the current
frame is used to start the output.
</p>
<p id="458">
Current limitations include:
</p>
<ol>
<li id="459">

locals are not printed.

</li>
<li id="460">

Some architectures can't yet walk the stack.

</li>
<li id="461">

Some architectures don't support dladdr() functionality, and so the C frames
printed as &quot;&lt;unknown C name&gt;&quot;.

</li>
<li id="462">

If a frame appears to be a lisp frame, but doesn't have a valid function
object in the expected spot, then the frame is annotated as "incomplete:"
and an attempt to print it as a C frame is made.  This tends to happen at
the beginning of a function where the stack has not yet been completely built,
or at the end of a backtrace where the stack is a little ragged on some
architectures.
</li>
</ol>
</blockquote>

<h3 id="463">
void lisp_cur(void)
<br>
void lisp_cur_aux(FILE * out)
</h3>

<blockquote>
<p id="464">
Prints the current frame, if there is one.  May fail catastrophically if
no current frame exists.
</p>
</blockquote>

<h3 id="465">
void lisp_up(int n)
<br>
void lisp_up_aux(int n, FILE *out)
</h3>

<blockquote>
<p id="466">
Moves up <b><i>n</i></b> frames, where "up" is the
direction toward the top, or frontier, of the stack, then prints the
new current frame. Note that this is the same concept of "up" as
Allegro CL debugger has, and opposite of gdb.
</p>
</blockquote>

<h3 id="467">
void lisp_dn(int n)
<br>
void lisp_dn_aux(int n, FILE *out)
</h3>

<blockquote>
<p id="468">
Moves down <b><i>n</i></b> frames, where "down" is the
direction away from the top, or frontier, of the stack, then prints
the new current frame.  Note that this is the same concept of "down"
as Allegro CL debugger has, and opposite of gdb.
</p>
</blockquote>

<h3 id="469">
int lisp_print_level = 5
<br>

int lisp_print_length = 10
</h3>

<blockquote>
<p id="470">
These two variables form a parallel to <a href="../ansicl/dictentr/print-le.htm"><code>*print-level*</code></a> and <a href="../ansicl/dictentr/print-le.htm"><code>*print-length*</code></a> in lisp.  They must be integers,
though; do not set them to <code>nil</code>
(i.e. nilval). Currently, they only affect the printing of lists.
</p>
</blockquote>

<h3 id="471">
char *(*lisp_demangle_hook)(char *) = NULL
<br>

void(*lisp_demangle_deallocate_hook)(char *) = NULL
</h3>

<blockquote>
<p id="472">
If non-null, these variables hook into the printing of non-lisp names;
when in the gdb interface a frame is being printed which might be a
C++ name, the <code>lisp_demangle_hook</code> is called, which
should either return a non-null string which has been demangled, or a
NULL (which will result in the frame-printer using the original
string).  After the name is printed, if the original name was
demangled (i.e. the hook returned a non-null string) and if the
<code>lisp_demangle_deallocate_hook</code> is non-null, then
that hook is called in order to deallocate the string which might have
been allocated by the demangle hook.  Users should ensure that these
hooks match in their operation; e.g. deallocation should not occur if
there was never an allocation by the demangling functionality.
</p>
</blockquote>

<h2 id="473">
Example 1
</h2>

<p id="474">
At a prompt on a linux 32-bit lisp:
</p>
<p id="475">
Note here that:
</p>
<ol>
<li id="476">

The stack frame is denoted by $ebp.  Sometimes $fp can be used, but
be sure it truly does represent the current value of the frame (on
some architectures gdb makes a best guess as to what was "meant" by
the frame-pointer in specifying $fp, and it doesn't always match the
value of $ebp).

</li>
<li id="477">

The second arg is 0, asking for as many frames as possible.

</li>
</ol>

<pre id="478">      
(gdb) call lisp_zo($ebp,0)
0xbf83a538: &lt;unknown C name&gt;
0xbf83a870: (read-octets &lt;stream: 0x71208f92&gt; nil 0 4096 peek)
0xbf83a8d8: (funcall #'(((method) . device-read) terminal-simple-stream t t t t) &lt;stream: 0x71208f92&gt; nil 0 nil peek)
0xbf83a958: (funcall #'(((internal) (((#))) . t) . 0) &lt;stream: 0x71208f92&gt; nil 0 nil peek)
0xbf83a9a0: (erroring-device-read &lt;stream: 0x71208f92&gt; nil 0 nil peek)
0xbf83aa38: #'(((efft) . dc-read-char) . latin1-base)
0xbf83aa90: (simple-stream-peek-char nil &lt;stream: 0x71208f92&gt; nil eof)
0xbf83aae8: (peek-char nil &lt;stream: 0x71208f92&gt; nil eof)
0xbf83ab28: (peek-char-non-whitespace &lt;stream: 0x71208f92&gt;)
0xbf83ac68: (read-top-level-command &lt;stream: 0x71208f92&gt;)
0xbf83af40: (read-eval-print-one-command nil nil)
0xbf83b2a0: (read-eval-print-loop continue-error-string nil condition &lt;standard-instance: 0x71a9b802&gt;)
0xbf83b560: (internal-invoke-debugger &quot;Error&quot; &lt;standard-instance: 0x71a9b802&gt; t)
0xbf83b640: (error &lt;standard-instance: 0x71a9b802&gt;)
0xbf83b8b8: (unbound-variable-handler a)
0xbf83b900: (general-error-handler 5 a t t)
0xbf83b938: (cer-general-error-handler-one 5 a)
0xbf83ba08: rs: stopped at &quot;unbound+158&quot;
0xbf83bab0: (%eval a)
0xbf83bb20: (eval a)
0xbf83bdf8: (read-eval-print-one-command nil nil)
0xbf83c158: (read-eval-print-loop level 0)
0xbf83c1d0: (top-level-read-eval-print-loop1)
0xbf83c228: (top-level-read-eval-print-loop)
0xbf83c270: rs: stopped at &quot;apply+311&quot;
0xbf83c300: (start-interactive-top-level &lt;stream: 0x71208f92&gt; #'top-level-read-eval-print-loop nil)
0xbf83c5a0: (start-lisp-execution t)
0xbf83c5f0: rs: stopped at &quot;apply+311&quot;
0xbf83c6b8: (thread-reset-catcher)
0xbf83c7e8: (setup-required-thread-bindings)
0xbf83c8d8: (run-initial-thread t)
0xbf83c980: (lisp-thread-start #S(thread:0xa0001822 &lt;bad object: 0x845972&gt; &lt;bad object: 0x845972&gt; &quot;Initial Lisp Listener&quot; &lt;standard-instance: 0x71a6a1e2&gt; nil #'start-lisp-execution-0 (t) nil nil...) 1)
0xbf83c9d8: rs: stopped at &quot;start_reborn_lisp+76&quot;
0xbf83ca48: rs: stopped at &quot;startup_lisp+11&quot;
0xbf83ca68: stopped at &quot;cont_setstack+371&quot;
0xbf83cac0: rs: stopped at &quot;first_lisp_thread_init+274&quot;
0xbf83cb18: stopped at &quot;setupstack_within_xhandler+16&quot;
(gdb) 
</pre>

<p id="479">
We can move down a few frames:
</p>

<pre id="480">
(gdb) call lisp_dn(2)
0xbf83a8d8: (funcall #'(((method) . device-read) terminal-simple-stream t t t t) &lt;stream: 0x71208f92&gt; nil 0 nil peek)
(gdb) call lisp_dn(1)
0xbf83a958: (funcall #'(((internal) (((#))) . t) . 0) &lt;stream: 0x71208f92&gt; nil 0 nil peek)
(gdb) 

Here, we've selected a frame to print, and asked for two frames.
(gdb) call lisp_zo(0xbf83a958,2)
0xbf83a958: (funcall #'(((internal) (((#))) . t) . 0) &lt;stream: 0x71208f92&gt; nil 0 nil peek)
0xbf83a9a0: (erroring-device-read &lt;stream: 0x71208f92&gt; nil 0 nil peek)
(gdb) 
</pre>

<p id="481">
Note above that not all of the first frame's name is printed.  If we grab
the function object from the frame, print it, and then print it after
increasing the lisp_print_level, then we see the whole name:
</p>

<pre id="482">
(gdb) x/16x 0xbf83a958-16
0xbf83a948:	0xfffffffa	0x719ed7f2	0x00000570	0x711d0a42
0xbf83a958:	0xbf83a9a0	0x71259d71	0x71208f92	0x71000685
0xbf83a968:	0x00000000	0x71000685	0x711c48ff	0x00000040
0xbf83a978:	0x71208f92	0xa0001822	0x71000685	0xa0001822
(gdb) call lisp_output_object(0x711d0a42)
#'(((internal) (((#))) . t) . 0)
(gdb) p lisp_print_level
$1 = 5
(gdb) set lisp_print_level=10
(gdb) call lisp_output_object(0x711d0a42)
#'(((internal) (((((effective-method) . 5)))) . t) . 0)
(gdb) 
</pre>

<p id="483">
Note that the name is of an "internal" fspec form.  Note also that since
the symbols don't print their packages, calling the internal function to
externalize the name doesn't fix it:
</p>

<pre id="484">
cl-user(1): (excl::convert-to-external-fspec '(((internal) (((((effective-method) . 5)))) . t) . 0))
(((internal) (((#))) . t) . 0)
cl-user(2): 
</pre>

<p id="485">
However, adding package qualifiers does fix this (this nested fspec
happens to have two function specs in the keyword package):
</p>

<pre id="486">
cl-user(2): (excl::convert-to-external-fspec '(((:internal) (((((:effective-method) . 5)))) . t) . 0))
(:internal (:effective-method 5 nil nil nil t) 0)
cl-user(3): 
</pre>

<h2 id="487">
Example 2
</h2>

<p id="488">
Here is the backtrace for Linux/amd64.  Note
that we use $rsp for the stack frame, and that there are a couple of
anomalies at the end of the backtrace (the last frame is mistaken for
a Lisp frame, which makes it appear to be incomplete as a lisp frame,
and also that incompleteness causes a failure to find the next frame,
which is hard in general to do on any architecture which does not
store an explicit next-link into its stack frames).
</p>

<pre id="489">
(gdb) call lisp_zo($rsp,0)
0x7fff36d74968: stopped at &quot;cl_select_read+300&quot;
0x7fff36d769e0: (read-octets &lt;stream: 0x100032dfe2&gt; nil 0 nil peek)
0x7fff36d76e40: (funcall #'(((method) . device-read) terminal-simple-stream t t t t) &lt;stream: 0x100032dfe2&gt; nil 0 nil peek)
0x7fff36d76f30: (funcall #'(((internal) (((#))) . t) . 0) &lt;stream: 0x100032dfe2&gt; nil 0 nil peek)
0x7fff36d77040: (erroring-device-read &lt;stream: 0x100032dfe2&gt; nil 0 nil peek)
0x7fff36d770d0: #'(((efft) . dc-read-char) . latin1-base)
0x7fff36d771b0: (simple-stream-peek-char nil &lt;stream: 0x100032dfe2&gt; nil eof)
0x7fff36d77280: (peek-char-non-whitespace &lt;stream: 0x100032dfe2&gt;)
0x7fff36d77310: (read-top-level-command &lt;stream: 0x100032dfe2&gt;)
0x7fff36d77560: (read-eval-print-one-command nil nil)
0x7fff36d77ae0: (read-eval-print-loop continue-error-string nil condition &lt;standard-instance: 0x1001136932&gt;)
0x7fff36d78170: (internal-invoke-debugger &quot;Error&quot; &lt;standard-instance: 0x1001136932&gt; t)
0x7fff36d786e0: (error &lt;standard-instance: 0x1001136932&gt;)
0x7fff36d788a0: (unbound-variable-handler a)
0x7fff36d78d60: (general-error-handler 5 a t t)
0x7fff36d78e20: rs: stopped at &quot;unbound+355&quot;
0x7fff36d79240: (%eval a)
0x7fff36d79330: (eval a)
0x7fff36d79430: (read-eval-print-one-command nil nil)
0x7fff36d799b0: (read-eval-print-loop level 0)
0x7fff36d7a040: (top-level-read-eval-print-loop1)
0x7fff36d7a140: (top-level-read-eval-print-loop)
0x7fff36d7a200: rs: stopped at &quot;apply+479&quot;
0x7fff36d7a2b0: (start-interactive-top-level &lt;stream: 0x100032dfe2&gt; #'top-level-read-eval-print-loop nil)
0x7fff36d7a3d0: (start-lisp-execution t)
0x7fff36d7a8a0: rs: stopped at &quot;apply+479&quot;
0x7fff36d7a960: (thread-reset-catcher)
0x7fff36d7aae0: (setup-required-thread-bindings)
0x7fff36d7ad20: (run-initial-thread t)
0x7fff36d7aef0: (lisp-thread-start #S(thread:0x20000018b2 &lt;bad object: 0x2aaaaad3b392&gt; &lt;bad object: 0x2aaaaad3b392&gt; &quot;Initial Lisp Listener&quot; &lt;standard-instance: 0x1001106462&gt; nil #'start-lisp-execution-0 (t) nil nil...) 1)
0x7fff36d7b050: rs: stopped at &quot;first_lisp_thread+584&quot;
0x7fff36d7b110: rs: stopped at &quot;start_reborn_lisp+140&quot;
0x7fff36d7b1f0: 
Terminating frame 0x7fff36d7b1f0: can't find valid next frame
incomplete: stopped at &quot;startup_lisp+14&quot;

Terminating frame 0x7fff36d7b1f0: can't find valid next frame
(gdb) 
</pre>



</body><hr><p id="2"><small>Copyright (c) 1998-2010, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br><small>Documentation for Allegro CL version 8.2. This page was not revised from the 8.1 page.</small><br>
<small>Created 2010.1.21.</small>
<br></p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faqs/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 8.2</b><br><small><a href="introduction.htm#updates-s">Unrevised from 8.1 to 8.2.</a></small><br><a href="http://www.franz.com/support/documentation/8.1/doc/debugging.htm">8.1 version</a></td></tr></table></html>