<html>

<head>
<title>Prolog: Allegro Prolog</title>
</head>

<body>

<table border="0" width="100%" cellpadding="1" cellspacing="0">
  <tr>
    <td bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3">
      <tr>
        <td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td>
      </tr>
    </table>
    </td>
    <td align="right"><b>Allegro CL version 8.2</b><br>
    <small><a href="introduction.htm#updates-s">New in 7.0</a></small></td>
  </tr>
</table>

<h1>Allegro Prolog</h1>

<h2>Release 0.98b</h2>
<!--
<p><font size="-2">-[Thu Dec  8 13:24:26 2005 by smh]-</font>
-->

<p>Release 0.98b of <b>Allegro Prolog</b> continues a sequence of minor bugfix releases
from 0.98, but 0.98 and its accompanying documentation have significant changes and
enhancements from earlier releases.</p>

<p>The prolog module can be loaded with <tt>(require :prolog)</tt>. Symbols are exported
from the <tt>prolog</tt> package. If you intend to use Prolog interactively you will
probably find it convenient to execute <tt>(use-package :prolog)</tt> also.</p>

<p>It happens that both the <tt>prolog</tt> and <tt>cg</tt> packages export a symbol named
<tt>==</tt> which will signal a package conflict if there is an attempt to use both
packages. This will happen, for instance, if you try to use the <tt>prolog</tt> package in
the <tt>cg-user</tt> package without first shadowing one or the other symbol. Usually you
want <tt>==</tt> to refer to <tt>prolog:==</tt>. You will get that if you load the prolog
module and evaluate <code>(shadowing-import '(prolog:==))</code> and then <code>(use-package
:prolog)</code>. </p>

<h3>User Documentation </h3>

<p>This document is not intended as an introduction to programming in Prolog. It assumes
some programming knowledge of both Prolog and Common Lisp. </p>

<p><b>Allegro Prolog</b> is an implementation of Prolog in Common Lisp. It is based on the
implementation developed by Peter Norvig in <i>Paradigms of Artificial Intelligence
Programming</i>. The code has been further optimized and useful extensions provided,
making an industrial-strength Prolog programming environment with a flexible calling
interface in both directions between Common Lisp and Prolog. </p>

<p>Prolog functors are translated to compiled Common Lisp functions. A single Lisp
function combines all rules for each distinct functor/arity. Special treatment is given
for <i>facts</i>, that is, rules with no variables in the head and no clauses in the body.
The Lisp function automatically captures these as data instead of code. This allows
reasonably large collections of data to be specified as regular Prolog rules. Larger,
highly-scalable data sets can be implemented by extensions outlined below.</p>

<p><b>Allegro Prolog</b> does not intend to be an ISO-compliant Prolog, nor does it
implement the entire Prolog language. Its purpose is to provide Prolog logic programming
as an integrated extension to Common Lisp for use in Lisp programs, not as a separate
language. Many standard Prolog arithmetic, predicate operators, and I/O operators are not
implemented, as they are a subset of the standard Common Lisp operators available using <tt>lisp/2</tt>.
There is also no support for operator syntax (e.g. infix notation), as input notation is
subsumed by sexpr syntax. These choices may be reconsidered in the future if there is
reason to if there is motivation to make <b>Allegro Prolog</b> a self-standing Prolog
implementation. What <i>is</i> provided is the basic Prolog engine for logic programming. </p>

<p>Prolog source files may be loaded either compiled or interpreted, as Prolog functors
are automatically compiled upon first use. But since <b>Allegro Prolog</b> programs will
typically contain both Lisp and Prolog code intermixed, it is generally a good idea to
compile the files so that the Lisp code is compiled. </p>

<p>All public symbols are exported from the <tt>prolog</tt> package. The definitions
mostly follow Norvig. Lisp S-expression syntax is used rather than Edinburgh syntax,
although support for Edinburgh input may be provided in the future. Prolog variables are
Lisp symbols that have names that begin with the `<tt>?</tt>' character. The anonymous
variable is the symbol `<tt>?</tt>' (that is, `<tt>prolog:?</tt>'). Some symbols exported
from the <tt>prolog</tt> package are <tt>eq</tt> to symbols exported from the <tt>common-lisp</tt>
package, but there is never any ambiguity between use of a Prolog name and a Lisp name.
There is no implementation of the Prolog module system. Programmers should be aware that
there is a danger of collision with inherited symbols. For example, the symbol <tt>cl:list</tt>
is not defined by Prolog but would typically be inherited from the <tt>common-lisp</tt>
package by an application package. An attempt to make a Lisp function definition on <tt>cl:list</tt>
would be prevented by package locking, but definition as a Prolog functor is not
protected. If multiple application packages attempt to make such definitions, they would
collide on the inherited symbol.</p>

<p><b>Allegro Prolog</b> has no known dependencies on 8-bit vs. 16-bit character images or
on ANSI vs. Modern mode images.</p>

<h3>Built-in Prolog Functors</h3>

<p>The following Prolog functors are predefined in <b>Allegro Prolog</b> and generally
implement the standard Prolog functionality. The set of defined functors may be extended
in the future. A few functors in this implementation accept varying arity and are
indicated with a <tt>*</tt>, as in <tt>or/*</tt>.</p>

<blockquote>
  <tt><b><p>=/2</b></tt>&nbsp;&nbsp; <tt><b>==/2</b></tt>&nbsp;&nbsp; <tt><b>abolish/2</b></tt>&nbsp;&nbsp;
  <tt><b>and/*</b></tt>&nbsp;&nbsp; <tt><b>append/3</b></tt>&nbsp;&nbsp; <tt><b>arg/3</b></tt>&nbsp;&nbsp;
  <tt><b>assert/1</b></tt>&nbsp;&nbsp; <tt><b>asserta/1</b></tt>&nbsp;&nbsp; <tt><b>assertz/1</b></tt>&nbsp;&nbsp;
  <tt><b>atom/1</b></tt>&nbsp;&nbsp; <tt><b>atomic/1</b></tt>&nbsp;&nbsp; <tt><b>bagof/3</b></tt>&nbsp;&nbsp;
  <tt><b>call/1</b></tt>&nbsp;&nbsp; <tt><b>consult/1</b></tt>&nbsp;&nbsp; <tt><b>copy-term/2</b></tt>&nbsp;&nbsp;
  <tt><b>erase/1</b></tt>&nbsp;&nbsp; <tt><b>fail/0</b></tt>&nbsp;&nbsp; <tt><b>first/1</b></tt>&nbsp;&nbsp;
  <tt><b>functor/3</b></tt>&nbsp;&nbsp; <tt><b>ground/1</b></tt>&nbsp;&nbsp; <tt><b>if/2</b></tt>&nbsp;&nbsp;
  <tt><b>if/3</b></tt>&nbsp;&nbsp; <tt><b>is/2</b></tt>&nbsp;&nbsp; <tt><b>last/1</b></tt>&nbsp;&nbsp;
  <tt><b>leash/1</b></tt>&nbsp;&nbsp; <tt><b>length/1</b></tt>&nbsp;&nbsp; <tt><b>listing/1</b></tt>&nbsp;&nbsp;
  <tt><b>member/2</b></tt>&nbsp;&nbsp; <tt><b>memberp/2</b></tt> (<tt><b>member</b></tt>
  without backtracking)&nbsp;&nbsp; <tt><b>not/1</b></tt>&nbsp;&nbsp; <tt><b>number/1</b></tt>&nbsp;&nbsp;
  <tt><b>or/*</b></tt>&nbsp;&nbsp; <tt><b>princ/1</b></tt>&nbsp;&nbsp; <tt><b>read/1</b></tt>&nbsp;&nbsp;
  <tt><b>recorda/1</b></tt>&nbsp;&nbsp; <tt><b>recordz/1</b></tt>&nbsp;&nbsp; <tt><b>recorded/2</b></tt>&nbsp;&nbsp;
  <tt><b>repeat/0</b></tt>&nbsp;&nbsp; <tt><b>rest/1</b></tt>&nbsp;&nbsp; <tt><b>retract/1</b></tt>&nbsp;&nbsp;
  <tt><b>rev/2</b></tt>&nbsp;&nbsp; <tt><b>setof/3</b></tt>&nbsp;&nbsp; <tt><b>true/0</b></tt>&nbsp;&nbsp;
  <tt><b>var/1</b></tt>&nbsp;&nbsp; <tt><b>write/1</b></tt>&nbsp;&nbsp; </p>
</blockquote>

<p><tt><b>!</b></tt> is the Prolog cut. It may written as an atom <tt><b>!</b></tt> as
well as the 1-element list <tt><b>(!)</b></tt>. The Prolog <tt>atom</tt> predicate is
equivalent to Lisp's <tt>symbolp</tt>. The Prolog <tt>atomic</tt> predicate is equivalent
to Lisp's <tt>atom</tt>, true for any object that is not a <tt>cons</tt>. </p>

<h3>The Prolog Top Level</h3>

<p><b>Allegro Prolog</b> does not provide a top level listener loop other than the regular
lisp listener. Prolog computation may be invoked programmatically from Lisp using the <tt>prolog</tt>
macro described below, or interactively by executing the <b>?-</b> macro. Here is a simple
example interactive session using <b>?-</b>. </p>

<pre>
cl-user(2): (require :prolog)
nil
cl-user(3): (use-package :prolog)
t
cl-user(4): (?- (append ?x ?y (1 2 3)))
?x = ()
?y = (1 2 3) <i>&lt;ENTER&gt;</i>
?x = (1)
?y = (2 3) <i>&lt;ENTER&gt;</i>
?x = (1 2)
?y = (3) <i>&lt;ENTER&gt;</i>
?x = (1 2 3)
?y = () <i>&lt;ENTER&gt;</i>
No.
cl-user(5): 
</pre>

<p>The <b>?-</b> macro operates similarly to the top-level loop in interactive Prologs. A <b>?-</b>
expression takes zero or more subforms which are clauses and tries to solve them. When a
solution is found, it prints the values of all variables in the expression then reads a
character from <b>*standard-input*</b>. (If there are no variables it prints
&quot;Yes.&quot;). If the character is either <i>newline</i> (usually <i>enter</i> on a
keyboard) or semicolon, Prolog backtracks and attempts to find another solution. If the
character is a period, Prolog prints &quot;No.&quot; and returns. </p>

<h3>Defined Lisp Operators</h3>

<table cellpadding="4" frame="box&quot;" rules="all">
<thead>
  <tr>
    <th>Lisp Operator</th>
    <th>Description</th>
  </tr>
</thead>
<tbody valign="top">
  <tr>
    <td><pre>&lt;- <i>clause*</i></pre>
    </td>
    <td>Assert a fact or rule. A macro.</td>
  </tr>
  <tr>
    <td><pre>&lt;-- <i>clause*</i></pre>
    </td>
    <td>As above, but first retracts all rules for the functor with the same arity. This is
    similar to the action taken for <tt>&lt;-</tt> the first time a functor/arity is seen
    within a <tt>consult</tt>, but <tt>&lt;--</tt> is especially useful interactively. By
    retracting previous clauses it allows predicates to be changed and files to be loaded more
    than once. A useful convention (in a file that might be <tt>load</tt>ed rather than <tt>consult</tt>ed)
    is to use <tt>&lt;--</tt> in the first rule for a particular function/arity. An example of
    typical usage would be: <pre>
  (&lt;-- (member ?item (?item . ?)))
  (&lt;-  (member ?item (? . ?rest)) (member ?item ?rest))
</pre>
    </td>
  </tr>
  <tr>
    <td><pre>?- <i>clause*</i></pre>
    </td>
    <td>Interactively try to prove the concatenation of clauses, printing unified variables
    and then backtracking after each success. A macro. </td>
  </tr>
  <tr>
    <td><pre>consult &amp;rest <i>filename</i>*</pre>
    </td>
    <td>This function calls <tt>cl:load</tt> on its filename or pathname argument, with the
    additional functionality that the first time <tt>&lt;-</tt> is executed for a given
    predicate/arity, that predicate/arity is cleared before the new definition is established.
    <tt>consult/1</tt> is also available as a prolog functor, accepting a single filename or a
    list of filenames. </td>
  </tr>
  <tr>
    <td><pre>leash {<i>functor</i> <i>arity</i>}*</pre>
    </td>
    <td>A macro analogous to Lisp <tt>trace</tt> which causes printing at each of the four
    ports to the functor: call, exit, redo, and fail. This predicate is often called <tt>trace</tt>
    in other Prologs, but that name clashes with the standard <tt>cl:trace</tt> macro. <p>Leash
    output is printed to <tt>*trace-output*</tt>. </p>
    <p>If leash is called with no arguments it returns a list of the currently-leashed
    functor/aritys currently being leashed. </p>
    <p>When a functor/arity is leashed (or unleashed) it is automatically recompiled without
    (or with) tail-call optimization to make leash output conform to Prolog WAM model even for
    tail-recursive functors. The programmer does not normally need to be concerned with this. </p>
    <p>Some built in functors such as <tt>if</tt>, <tt>not</tt>, <tt>or</tt>, and <tt>and</tt>
    are normally rewritten by inline macro transformers so will usually not appear in leash
    output if leashed. </p>
    <p>Here is an example of leash. <tt>rev-member</tt> is like <tt>member</tt> but returns
    results starting from the tail of the list: </p>
    <pre>cl-user(2): (require :prolog)
t
cl-user(3): (use-package :prolog)
t
cl-user(4): (<-- (rev-member ?item (? . ?rest)) (rev-member ?item ?rest)) rev-member cl-user(5): (<- (rev-member ?item (?item . ?))) rev-member cl-user(6): (leash rev-member 2) t cl-user(7): (?- (rev-member ?animal (dog cat fish))) [1] Entering rev-member/2 {Unbound 1000fe7cb1} (dog cat fish) [2] Entering rev-member/2 {Unbound 1000fe7cb1} (cat fish) [3] Entering rev-member/2 {Unbound 1000fe7cb1} (fish) [4] Entering rev-member/2 {Unbound 1000fe7cb1} () [4] Failed rev-member/2 [3] Succeeded rev-member/2 fish (fish) [2] Succeeded rev-member/2 fish (cat fish) [1] Succeeded rev-member/2 fish (dog cat fish) ?animal="fish" <i>&lt;ENTER&gt;
[1] Backtracking into rev-member/2
 [2] Backtracking into rev-member/2
  [3] Backtracking into rev-member/2
  [3] Failed rev-member/2
 [2] Succeeded rev-member/2 cat (cat fish)
[1] Succeeded rev-member/2 cat (dog cat fish)
?animal = cat <i>&lt;ENTER&gt;</i>
[1] Backtracking into rev-member/2
 [2] Backtracking into rev-member/2
 [2] Failed rev-member/2
[1] Succeeded rev-member/2 dog (dog cat fish)
?animal = dog <i>&lt;ENTER&gt;</i>
[1] Backtracking into rev-member/2
[1] Failed rev-member/2
No.
cl-user(8): 
</pre>
    </td>
  </tr>
  <tr>
    <td><pre>leash-1 <i>functor</i> <i>arity</i></pre>
    </td>
    <td>Functional version of the above.</td>
  </tr>
  <tr>
    <td><pre>unleash {<i>functor</i> <i>arity</i>}*</pre>
    </td>
    <td>Analogous to Lisp <tt>untrace</tt>. If called with no arguments, every
    currently-leashed functor/arity is unleashed. </td>
  </tr>
  <tr>
    <td><pre>unleash-1 <i>functor</i> <i>arity</i></pre>
    </td>
    <td>Functional version of the above</td>
  </tr>
  <tr>
    <td><pre>*leash-limit*</pre>
    </td>
    <td>If variable this is an integer, the debugger will be entered if leash output exceeds
    the specified depth. This is intended as a convenience when debugging deep recursion.
    Initially nil.</td>
  </tr>
  <tr>
    <td><pre>*prolog-leash-indent-wrap*</pre>
    </td>
    <td>Leash output indents one space for each level of leashed functor. If leashing is
    deeply recursive this indentation may make the leash output unreadable, so the indentation
    is taken modulo the value of this variable. It must be a nonnegative integer, but may be
    set large. Initially 20.</td>
  </tr>
  <tr>
    <td><pre>prolog-compile-symbols <i>functor</i>*</pre>
    </td>
    <td>This may be called after new rules are asserted before making Prolog queries. Called
    with no arguments, it compiles all functors needing (re)compilation. Otherwise, a
    functor/arity will be compiled automatically the first time it is called. </td>
  </tr>
</tbody>
</table>

<p>Whether a rule is established by <tt>&lt;-</tt> or <tt>assert/2</tt>, a Lisp form
inside a prolog rule executed by the <tt>lisp/2</tt> and similar functors may <i>not</i>
refer to the Lisp lexical environment outside the rule definition. This restriction is
necessary because the code for the Prolog functor is not compiled until later, after all
functor/arity clauses have been combined to form its function body. </p>

<h3>The Programming Interface between Prolog and Common Lisp</h3>

<p>In addition to the interactive query and assertion macros (e.g. <tt>?-&gt;</tt> and <tt>&lt;-</tt>)
there are several operators to call in either direction between Prolog code and Lisp code.
</p>

<table cellpadding="4" frame="box&quot;" rules="all">
<thead>
  <tr>
    <th>Prolog Functor</th>
    <th>Description</th>
  </tr>
</thead>
<tbody valign="top">
  <tr>
    <td><pre>lisp <i>arg</i> <i>form</i></pre>
    </td>
    <td>Execute a Lisp form from Prolog. The Lisp form is compiled (at the same time the
    Prolog predicate is compiled) and may refer to variables in the surrounding dynamic Lisp
    environment. Lexical references cannot go beyond the rule boundary. Prolog variables may
    be referenced, but only in evaluated positions (i.e. not inside constants). Prolog
    variables are dereferenced as necessary into non-dynamic-extent copies. The clause fails
    and no Lisp code is executed if any Prolog variables in the form are unbound. The result
    of executing the Lisp form second argument is unified with the first argument.</td>
  </tr>
  <tr>
    <td><pre>lisp <i>form</i></pre>
    </td>
    <td>As above, but the Lisp form is executed for side effect only. Any value returned by
    the form is ignored. </td>
  </tr>
  <tr>
    <td><pre>lisp* <i>arg</i> <i>form</i>
lisp* <i>form</i></pre>
    </td>
    <td>As above, but unbound Prolog variables do not cause the clause to fail. If the Prolog
    variables referenced within the Lisp form are guaranteed to be bound, this functor is more
    efficient than the otherwise-equivalent <tt>lisp</tt> functor because it does not need to
    set up code to handle the unbound-variable failure case. It is often the case in numeric
    calculation that the variables are certain to be bound. In such situations it is faster to
    execute <tt>(lisp* ?x (1+ ?x))</tt> than <tt>(lisp ?x (1+ ?x))</tt>.</td>
  </tr>
  <tr>
    <td><pre>lispp <i>form</i></pre>
    </td>
    <td>A convenience functor similar to <strong>lisp</strong> but runs as a predicate and
    fails if execution of the form returns <tt>nil</tt>. The familiar Prolog numeric
    predicates can be obtained this way: <pre>  (lispp (&gt;= ?x 5))</pre>
    </td>
  </tr>
  <tr>
    <td><pre>lispp* <i>form</i></pre>
    </td>
    <td>As above, except that unbound Prolog variables do not cause the rule to fail. <tt>lispp*</tt>
    is more efficient than <tt>lispp</tt> if all referenced Prolog variables are bound.</td>
  </tr>
  <tr>
    <td><pre>lisp! <i>arg</i> <i>form</i>
lisp! <i>form</i>
lisp*! <i>arg</i> <i>form</i>
lisp*! <i>form</i>
lispp! <i>form</i>
lispp*! <i>form</i></pre>
    </td>
    <td>Similar to the above functors, with the provision that any dynamic-extent data bound
    to Prolog variables in the <i>form</i> are consed in the heap before being passed to Lisp.
    See the section below on <b>Prolog and Dynamic Extent</b>. </td>
  </tr>
  <tr>
    <td><i><pre></i>is <i>arg</i> <i>form</pre>
    </i></td>
    <td>This is an exact equivalent for the 2-argument <strong>lisp</strong> functor above. <strong>is</strong>
    is the traditional name for this functor. The <strong>lisp</strong> and <strong>is</strong>
    in this implementation are slightly more powerful than the Prolog <strong>is</strong>
    since they are capable of unifying (even destructuring) an arbitrary returned value
    returned by the Lisp form, while the Prolog functor is intended only for numerical
    calculations. <pre>  cl-user: (?- (is (?div ?rem) (multiple-value-list (truncate 11 3)))) 
  ?div = 3 
  ?rem = 2 
  No.</pre>
    </td>
  </tr>
</tbody>
</table>

<table cellpadding="4" frame="box&quot;" rules="all">
<thead>
  <tr>
    <th>Lisp Operator</th>
    <th>Description</th>
  </tr>
</thead>
<tbody valign="top">
  <tr>
    <td><pre>fail</pre>
    </td>
    <td>Lisp code running inside a call to one of the the Prolog <tt>lisp</tt> functors can
    call this Lisp function to cause the clause to fail immediately.</td>
  </tr>
  <tr>
    <td><pre>prolog <i>clause*</i></pre>
    </td>
    <td>A Lisp macro that invokes Prolog programmatically to solve the conjunction of the
    clauses. The surrounding Lisp environment (lexical as well as dynamic) can be accessed
    using the <tt>lisp</tt> functor. This example refers to the <tt>likes</tt> data in an
    example in a later section of this document: <pre>
  (defun human-friends-of (person)
    (let ((friends nil))
      (prolog (lisp ?person person)
              (likes ?person ?x)
	      (human ?x)
	      (lisp (pushnew ?x friends)))
      friends))</pre>
    <p>The expansion of the <tt>prolog</tt> macro wraps a <tt>block</tt> named <tt>prolog</tt>
    around the body so Lisp forms inside the body can easily return a value: </p>
    <pre>
  (defun human-friend-of (person)
    (prolog (lisp ?person person)
            (likes ?person ?x)
	    (human ?x)
	    (lisp (return-from prolog ?x))))</pre>
    <p>Unless there is some nonlocal exit, execution of the <tt>prolog</tt> macro silently
    finds all solutions to the clauses. </td>
  </tr>
</tbody>
</table>

<h3>Prolog and Dynamic Extent</h3>

<p>Computation in Prolog works by attempting to satisfy a clause and, if successful,
calling a continuation function. If that continuation fails control may return to any
previous choice point, undoing any intervening unifications, and trying a different
solution choice. Prolog unification data and continuation functions always have dynamic
extent. The implementation exploits this by allocating Prolog variables themselves, cons
structure created by unification, and continuation closure functions on the stack, that
is, with dynamic extent. This allows Prolog code to operate with essentially zero consing
and with a resulting improvement in speed.</p>

<p>There are, however, certain functors that typically cons data with indefinite extent.
Solutions collected by the <tt>bagof/3</tt> and <tt>setof/3</tt> functors are
automatically heap consed, as are any rules stored by the <tt>assert</tt>, <tt>asserta</tt>,
<tt>assertz</tt>, <tt>recorda</tt>, and <tt>recordz</tt> functors. </p>

<p>The family of <tt>lisp</tt> functors are special cases. When a call to the <tt>lisp</tt>
functor is performed, the values of any Prolog variables referenced in the Lisp form are
communicated efficiently to the Lisp code using symbol macros. But those variables may
contain nested unification with other Prolog variables, and the structure created by
unification may have been consed with dynamic extent. This is not normally a concern since
the Lisp code is of course running within the dynamic extent of the surrounding Prolog
code, but it would become an issue if the Lisp code stored the data somewhere with
indefinite extent.</p>

<p>Dynamic extent is only a concern for cons structures. Numeric data is generally not
stack consed. </p>

<p>Some examples will make this clear. Consider the following code: </p>

<pre>(defun ancestors-of (person)
  (let ((ancestors nil))
    (prolog (lisp ?person person)
            (ancestor ?x person)
            (lisp (push ?x ancestors)))
    ancestors))</pre>

<p>If the data returned by the <tt>ancestor</tt> predicate are atoms (e.g. symbols) there
is no problem since they cannot be stack consed. Similarly, there is no problem with
numbers and numeric calculation since the implementation generally does not stack cons
numbers. But suppose Prolog data passed to Lisp code was created by unification: </p>

<pre>(defun grandfather-pairs ()
  (let ((pairs nil))
    (prolog (grandfather ?gramp ?child)
            (lisp (push (?gramp ?child) pairs)))
    pairs))</pre>

<p>are atoms, but it would not work if the objects being passed back were conses created
by Prolog unification. But structure created by Prolog unification has only dynamic extent
-- that is, it may be consed on the stack. Stack-consed data must be copied to the heap if
it is passed outward to Lisp or otherwise preserved outside the dynamic contour where it
is created. As an example see the function <tt>zebra-benchmark</tt> in the zebra example
file. </p>

<p>A top-level list created by <tt>bagof</tt> and <tt>setof</tt> are automatically given
indefinite extent, as is any substructure created by unification and collected on these
lists. Therefore the programmer should not have to worry about dynamic extent when using
these predicates. </p>

<h3>Tail Call Elimination</h3>

<p>The ISO standard for Prolog apparently does not require tail-call elimination. However,
most implementations provide it to some degree. It is certainly a valuable feature. <b>Allegro
Prolog</b> functors usually do not perform tail-call elimination. The Prolog compiler
tries to stack cons Prolog variables, data structure, and continuations. Stack allocation
of these data enhances performance, but stack-consed data generally prohibits tail-call
elimination.</p>

<p>Since tail-call elimination can be important for particular functors in certain styles
of coding, a crude control over stack consing has been implemented at the level of an
individual functor/arity. This facility is experimental and is likely to change in future
releases.</p>

<p>The first clause of any rule may be a <tt>cl:declare</tt> which makes declarations
about the functor. Declarations may appear in any rule for a given functor/arity --
declarations in later rules (according to the ordering maintained by <tt>assert</tt> and
friends) override earlier declarations.</p>

<p>The only declarations currently supported are <tt>:tail-calls</tt> and <tt>:no-tail-calls</tt>.
The latter is the default.</p>

<pre>  (<-- (my-member ?item (?item . ?)) (declare :tail-calls)) (<- (my-member ?item (? . ?rest)) (my-member ?item ?rest))</pre>

The <tt>(declare :tail-calls)</tt> could have been included in either
or both of the two rules.

</pre>

<p>The built in <tt>member/2</tt> and <tt>length/2</tt> functors are written in a way that
consumes neither Prolog nor Lisp stack, but if they had not, the version of <tt>my-member</tt>
shown above implements heap-consing by the functor and allows tail recursion on the Lisp
stack. The functor still requires Prolog stack for the unifications performed on the <tt>?rest</tt>
Prolog variable, but this is small (one word per unified variable) compared to the
consumption of Lisp stack that recursion would require.</p>

<p>Tail call elimination is subject to the normal constraints imposed by the Lisp
compiler. These are platform dependent.</p.>The presence in a functor/arity of calls to the <tt>lisp</tt>,
<tt>lispp</tt> or <tt>lisp!</tt> functors will sometimes prevent tail call elimination.
Where possible, use <tt>lisp*</tt>, <tt>lispp*</tt> and <tt>lisp*!</tt> instead. </p>

<h3>The Prolog Stack</h3>

<table cellpadding="4" frame="box&quot;" rules="all">
<thead>
  <tr>
    <th>Lisp Name</th>
    <th>Description</th>
  </tr>
</thead>
<tbody valign="top">
  <tr>
    <td><tt>prolog-stack-overflow</tt></td>
    <td>Prolog maintains a stack of unifications as it tries to satisfy clauses recursively.
    This stack is separate from the regular Lisp execution stack. The initial stack length is
    determined by the implementation, but the stack will double in length when the current
    length is exceeded. This Lisp condition is signalled with <tt>cerror</tt> when automatic
    doubling will exceed the limit contained in the variable <tt>*prolog-stack-limit*</tt>.
    Continuing (e.g. with the standard Lisp <tt>continue</tt> function) will continue Prolog
    computation with the stack length doubled. <p>The only superclass of this condition is <tt>cl:condition</tt>
    itself. In particular, it is not a subclass of <tt>error</tt> so extraneous error handlers
    don't try to handle it. </td>
  </tr>
  <tr>
    <td><tt>prolog-stack-overflow-length</tt></td>
    <td>This reader on the above condition returns the current stack length. </td>
  </tr>
  <tr>
    <td><tt>*prolog-stack-limit*</tt></td>
    <td>A special variable containing a positive integer that specifies the size above which a
    <tt>prolog-stack-overflow-length</tt> will be signalled. The initial value is 4096. </td>
  </tr>
</tbody>
</table>
<!--
<p>
Ignore the following for now...

prolog-compile
prolog-compiler-macro
def-prolog-compiler-macro

</p>
-->

<h3>I/O Functors</h3>

<p>The set of built-in Prolog I/O functors is intentionally limited because most input and
output would naturally be done by Lisp code. A few functors are provided for convenience. </p>

<table cellpadding="4" frame="box&quot;" rules="all">
<thead>
  <tr>
    <th>Lisp Name</th>
    <th>Description</th>
  </tr>
</thead>
<tbody valign="top">
  <tr>
    <td><pre>read <i>value</i> [<i>stream</i> [<i>stream</i> [<i>stream</i>] ] ]</pre>
    </td>
    <td>The <i>value</i> argument is unified with a single datum read from <tt>*standard-input*</tt>.
    This is just a simple wrapper for the Lisp <tt>read</tt> function. The input syntax is
    Lisp syntax, not Edinburgh. <p>The functors <tt>read/2</tt>, <tt>read/3</tt>, and <tt>read/4</tt>
    are also defined, providing the <i>stream</i>, <i>eof-error</i>, and <i>eof-value</i>
    optional arguments to <tt>read</tt>. If supplied, the values of these arguments must be
    grounded.</td>
  </tr>
  <tr>
    <td><pre>write <i>value</i> [<i>stream</i>]</pre>
    </td>
    <td>The <i>value</i> argument is written to <tt>*standard-output*</tt>. This is just a
    simple wrapper for the Lisp <tt>write</tt> function. The output syntax is Lisp syntax, not
    Edinburgh. <p>The functor <tt>write/2</tt> is also defined, providing the <i>stream</i>, <tt>write</tt>.
    If supplied, the value must be grounded.</td>
  </tr>
  <tr>
    <td><pre>princ <i>value</i> [<i>stream</i>]</pre>
    </td>
    <td>Like <tt>write</tt> but uses the Lisp <tt>princ</tt> function. </td>
  </tr>
  <tr>
    <td><pre>nl [<i>stream</i>]</pre>
    </td>
    <td>A wrapper for the Lisp <tt>terpri</tt> function. </td>
  </tr>
</tbody>
</table>

<h3>Unification with standard-objects. </h3>

<table cellpadding="4" frame="box&quot;" rules="all">
<thead>
  <tr>
    <th>Prolog Functor</th>
    <th>Description</th>
  </tr>
</thead>
<tbody valign="top">
  <tr>
    <td><pre>slot= <i>inst</i> <i>slot-name</i> <i>slot-value</i></pre>
    </td>
    <td>This Prolog functor unifies the value of a slot of a standard instance. The instance
    and slot-name arguments must be bound, otherwise the predicate silently fails. The
    slot-value argument is unified against the content of the slot. A Lisp error is signalled
    if the slot does not exist or is not bound. The implementation is: <pre>
  (&lt;-- (slot= ?instance ?slot-name ?slot-value)
       (lisp ?slot-value
             (slot-value ?instance ?slot-name)))
</pre>
    <p>When it is only necessary to read a slot, this functor is faster than the two that
    follow. </td>
  </tr>
  <tr>
    <td><pre>slot=* <i>inst</i> <i>slot-name</i> <i>slot-value</i></pre>
    </td>
    <td>Like <tt>lisp*</tt> except that this functor fails silently if the slot does not exist
    or is unbound.</td>
  </tr>
  <tr>
    <td><pre>slot-value <i>inst</i> <i>slot-name</i> <i>slot-value</i></pre>
    </td>
    <td>As above, this Prolog functor unifies the value of a slot in a standard instance.
    However, if the slot is unbound it is bound dynamically as if by <tt>letf</tt> to the
    value of <i>slot-value</i>, and the clause succeeds. (If <i>slot-value</i> is unbound or
    contains any unbound Prolog variables, the clause fails.) The slot is again made unbound
    when execution returns out of the continuation (by backtracking, or by Lisp nonlocal
    exit). While the slot is bound it is visible to other threads. Example: <pre>
  cl-user(38): (defparameter *inst* (make-instance 'foo))
  *inst*
  cl-user(39): (?- (lisp ?i *inst*)
                   (slot-value ?i a ?sv))
  No.
  cl-user(40): (?- (lisp ?i *inst*)
                   (slot-value ?i a 123)
                   (slot-value ?i a ?sv))
  ?i = #&lt;foo&gt;
  ?sv = 123
  No.
  cl-user(41): (?- (lisp ?i *inst*)
                   (slot-value ?i a ?sv))
  No.
</pre>
    </td>
  </tr>
  <tr>
    <td><pre>slot-value! <i>inst</i> <i>slot-name</i> <i>slot-value</i></pre>
    </td>
    <td>As above, except that if the slot is set it is <i>not</i> made unbound when execution
    backtracks. The side effect of setting the slot persists. Example: <pre>
  cl-user(42): (defparameter *inst* (make-instance 'foo))
  *inst*
  cl-user(43): (?- (lisp ?i *inst*)
                   (slot-value! ?i a ?sv))
  No.
  cl-user(44): (?- (lisp ?i *inst*)
                   (slot-value! ?i a 123)
                   (slot-value! ?i a ?sv))
  ?i = #&lt;foo&gt;
  ?sv = 123
  No.
  cl-user(45): (?- (lisp ?i *inst*)
                   (slot-value! ?i a ?sv))
  ?i = #&lt;foo&gt;
  ?sv = 123
  No.
</pre>
    </td>
  </tr>
</tbody>
</table>

<h3>The Prolog `Database' and Generators.</h3>

<p>In its simplest model, Prolog needs only to remember <i>rules</i>. (A <i>fact</i> is
simply a rule with no trailing clauses and no variables in its head.) All rules for a
particular functor/arity are remembered in the order they were asserted and the Prolog
implementation somehow references these when that functor/arity is invoked. Under this
simple model, there is no firm distinction between that portion of a system which the
programmer considers program, that part which he considers internal data and tables, and
(sometimes) that part which he would consider external data. </p>

<p>But the scaling requirements and operating characteristics of Prolog data sets vary
over enormous ranges. Many standard functors have only one or two rules: </p>

<pre>
  (&lt;-- (first ?x (?x . ?)))

  (&lt;-- (member ?item (?item . ?)))
  (&lt;-  (member ?item (? . ?rest)) (member ?item ?rest))
</pre>

<p>Functors like these are naturally represented as compiled code, or may even be inlined.
Rules which are conceptually implemented by compiled program code are managed by the
Prolog assert/abolish mechanism. </p>

<p>Now consider a different example (from Norvig) where a functor is defined partly by
algorithm (nontrivial rules) and partly by data (facts): </p>

<pre>
  (&lt;-- (likes Kim Robin))
  (&lt;-  (likes Sandy Lee))
  (&lt;-  (likes Sandy Kim))
  (&lt;-  (likes Robin cats))
  (&lt;-  (likes Sandy ?x) (likes ?x cats))
  (&lt;-  (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))
  (&lt;-  (likes ?x ?x))
</pre>

<p>The <tt>likes/2</tt> predicate has seven rules, four of which are facts. Despite the
combination of programmatic rules and facts, this combined data is still small enough to
be represented directly by the code implementing the functor/arity predicate. (This is
true especially for <b>Allegro Prolog</b> since compiled functors capture facts as
constant data, rather that expanding them into volumous Lisp code.) However, this
representation would become unwieldy if the number of individuals represented in the data
were a few orders of magnitude larger, and especially if more of the individuals had
idiosyncratic affinities. The factual data would better be represented in tabular form,
usually called <i>recorded databases</i> in Prolog. These are managed by functors such as <tt>recorda</tt>.
Prolog stores recorded facts in an <tt>equal</tt>-key hashtable. </p>

<p>Note that details of the following functors differ in some ways from those of other
Prolog implementations, and the API may change in the future. The predicates <tt>assert/1</tt>,
<tt>asserta/1</tt>, <tt>assertz/1</tt> and <tt>abolish/2</tt> pertain to the compiled
predicate database. The predicates <tt>recorda/2</tt>, <tt>recordz/2</tt>, <tt>retract/1</tt>,
and <tt>retractall/1</tt> pertain to the hashtable database of facts. The hashtable
database is <i>not</i> automatically referenced by compiled functors; it is consulted only
by the <tt>recorded/2</tt> predicate. </p>

<p>There is a separate interface to the AllegroCache object database described <a
href="#db">below</a>.</p>

<table cellpadding="4" frame="box&quot;" rules="all">
<thead>
  <tr>
    <th>Prolog Functor</th>
    <th>Description</th>
  </tr>
</thead>
<tbody valign="top">
  <tr>
    <td><pre>assertz <i>rule</i></pre>
    </td>
    <td>Asserts a single rule into the database. The new rule is placed after all existing
    rules for that functor/arity. <p>Note that <tt>assert/1</tt> takes a single <i>list</i> of
    clauses, therefore one would write </p>
    <pre>
... (assert ((likes ?name Lisp))) ...
</pre>
    <p>and not </p>
    <pre>
... (assert (likes ?name Lisp)) ...
</pre>
    </td>
  </tr>
  <tr>
    <td><pre>assert<i> rule</i></pre>
    </td>
    <td>Same as <tt>assertz</tt>.</td>
  </tr>
  <tr>
    <td><pre>asserta <i>rule</i></pre>
    </td>
    <td>Like <tt>assertz</tt> except the new rule is placed <i>before</i> all existing rules..</td>
  </tr>
  <tr>
    <td><pre>abolish <i>functor</i> <i>arity</i></pre>
    </td>
    <td>All rules for the functor/arity are removed.</td>
  </tr>
</tbody>
</table>

<p>A typical Prolog application will reason over sets of data. In small programming
examples, the data is simply included as `facts' that are part of the program source
itself. Reading facts from an external source and <tt>assert</tt>ing them into the program
is not much different. While a clever Prolog implementation can optimize collections of
facts, this approach cannot scale indefinitely. First, it requires the facts be captured
as data belonging to the function. Second, efficient reasoning over large data sets
requires knowledge about how the data will be accessed. Often this is really an indexing
problem, and the application programmer must guide the system by describing (or
implementing) how the data is indexed. It is no coincidence that this concern is similar
to database implementation. </p>

<p>A Prolog functor/arity is compiled automatically the first time it is called. Any
assert or retract to that functor/arity automatically invalidates the compiled function
such that it will be recompiled the next time it is called. While the Allegro compiler is
reasonably fast, performance may be poor if dynamic fact/rule management is performed
using assert and retract with high bandwidth, interspersed with calls to the
functor/arity. In such applications it would be better to use the <tt>recorded</tt>
interface or some other custom fact maintenance code, perhaps using <tt>generator</tt>. </p>

<table cellpadding="4" frame="box&quot;" rules="all">
<thead>
  <tr>
    <th>Prolog Functor</th>
    <th>Description</th>
  </tr>
</thead>
<tbody valign="top">
  <tr>
    <td><pre>recordz <i>rule</i></pre>
    </td>
    <td>Asserts a single new <i>rule</i> into the recorded database, keyed on the key which is
    the head of the rule. Only the functor and arity are considered in matching the key. The
    new rule is placed after all existing rules for that key. See the example below under <tt>generator</tt>.</td>
  </tr>
  <tr>
    <td><pre>recorda <i>rule</i></pre>
    </td>
    <td>Same as <tt>recordz</tt> except that the new rule is placed before all current rules
    for key.</td>
  </tr>
  <tr>
    <td><pre>recorded <i>key</i> <i>rule</i></pre>
    </td>
    <td>Finds the list of rules matching <i>key</i> in the recorded database and unifies <i>rule</i>
    successively to each rule. Only the functor and arity are considered in matching the key.</td>
  </tr>
  <tr>
    <td><pre>retract <i>key</i></pre>
    </td>
    <td>All rules for the <i>key</i> are removed from the recorded database. Succeeds only if
    something is deleted.</td>
  </tr>
</tbody>
</table>

<p>A common idiom for solving the data set issue is to construct a Lisp closure that
iteratively generates the data items to be returned. The following functors support this
use. </p>

<table cellpadding="4" frame="box&quot;" rules="all">
<thead>
  <tr>
    <th>Prolog Functor</th>
    <th>Description</th>
  </tr>
</thead>
<tbody valign="top">
  <tr>
    <td><pre>generator <i>item</i> <i>generator</i></pre>
    </td>
    <td>The <i>generator</i> argument should be a Lisp closure that returns an item each time
    it is called. When there are no more items, it should return <tt>nil</tt>. This protocol
    cannot be used with generators that may return <tt>nil</tt>; see <tt>generator*</tt>
    below. The <i>item</i> argument is unified with the returned item. <p>Example: </p>
    <pre>
  ;; This asserts facts into the record database all the package
  ;; inheritances in the running Lisp. 
  cl-user(40): (?- (lisp ?gen (let ((packages (list-all-packages)))
                                (lambda () (pop packages))))
                   (generator ?package ?gen)
                   (lisp ?used-list (package-use-list ?package))
                   (member ?used ?used-list)
                   (recordz (use ?package ?used))
                   (fail))
  No.
  ;; This queries which packages are used by the current package.
  cl-user(41): (?- (lisp ?package *package*)
                   (recorded (use ?package ?) (? ? ?used)))
  ?package = #&lt;The common-lisp-user package&gt;
  ?t = #&lt;The prolog package&gt;
  ?package = #&lt;The common-lisp-user package&gt;
  ?t = #&lt;The common-lisp package&gt;
  ?package = #&lt;The common-lisp-user package&gt;
  ?t = #&lt;The excl package&gt;
  No.
</pre>
    </td>
  </tr>
  <tr>
    <td><pre>generator* <i>item</i> <i>generator</i></pre>
    </td>
    <td>Similar to <tt>generator</tt> but suitable when generated items may include <tt>nil</tt>.
    The <i>generator</i> should return two values: the item, and a boolean indicating that an
    item was returned. When there are no more items the second value should be <tt>nil</tt>. </td>
  </tr>
  <tr>
    <td><pre>generating <i>item</i> <i>lisp-generator</i></pre>
    </td>
    <td>This is a convenience shortcut for typical use of the <i>generator</i> functor. The
    second argument is a lisp form that returns the generator closure. The values it generates
    are unified against the first argument. The example above could be written more
    conveniently this way: <pre>
  cl-user(40): (?- (generating ?package (let ((packages (list-all-packages)))
                                          (lambda () (pop packages))))
                   (lisp ?used-list (package-use-list ?package))
                   (member ?used ?used-list)
                   (recordz (use ?package ?used))
                   (fail))
  No.
</pre>
    </td>
  </tr>
  <tr>
    <td><pre>generating* <i>item</i> <i>lisp-generator</i></pre>
    </td>
    <td>As above for <tt>generator*</tt>. </td>
  </tr>
</tbody>
</table>

<p>A Prolog program that walks a lattice of linked objects is naturally implemented using
the <tt>lisp</tt> operator to follow links using standard Lisp accessors. </p>

<pre>
  (&lt;-- (class-subclass-gen ?gen ?class)
       (lisp ?gen
             (let ((class-stack (list
                                 (if (symbolp ?class)
                                     (find-class ?class)
                                   ?class))))
               (lambda ()
                 (let ((class (pop class-stack)))
                   (when class
                     (loop for subclass in (clos:class-direct-subclasses class)
                            do (push subclass class-stack))
                     class))))))

  (&lt;-- (has-initarg-p ?class ?slot-name ?initarg)
       (lisp t (typep ?class 'standard-class))
       (lisp ?dslotds (clos:class-direct-slots ?class))
       (member ?dslotd ?dslotds)
       (lisp ?initargs (clos:slot-definition-initargs ?dslotd))
       (member ?initarg ?initargs)
       (lisp ?slot-name (clos:slot-definition-name ?dslotd)))

  (&lt;-- (class-initarg ?root-class ?class ?slot-name ?initarg)
       (class-subclass-gen ?gen ?root-class)
       (generator ?class ?gen)
       (has-initarg-p ?class ?slot-name ?initarg))

  ;; This query will unify to each standard-class and slot that has a
  ;; :documentation initialization argument.
  ;;   (?- (class-initarg t ?class ?slot :documentation))

</pre>

<p>But querying large collections of relational data may require the programmer to inform
the system how the data should be stored and indexed. <b>Allegro Prolog</b> has under
development some general mechanisms for indexing data sets, or else an application
programmer may implement his own custom mechanisms. For example, the application
programmer might back end the Prolog program with a full relational or object database.
These possibilities are under active exploration as extensions.</p>
<a name="db" />

<h3>The Interface to AllegroCache</h3>

<p>Prolog code can reason directly over data stored in an AllegroCache database. The
interface is contained in the <tt>pcache</tt> module which can be loaded with <tt>(require&nbsp;:pcache)</tt>.
The module is currently distributed as part of the AllegroCache distribution.</p>

<p>The interface consists of the single <tt>prolog:db</tt> functor. This functor has
variable arity.</p>

<table cellpadding="4" frame="box&quot;" rules="all">
<thead>
  <tr>
    <th>Prolog Functor</th>
    <th>Description</th>
  </tr>
</thead>
<tbody valign="top">
  <tr>
    <td><pre>db <i>class</i> <i>?instance</i> <i>{ slot-name slot-value }*</i></pre>
    </td>
    <td>The <tt>db</tt> functor should only be executed in a dynamic (Lisp) environment in
    which the <tt>*allegrocache*</tt> variable is bound to an open AllegroCache database. The <i>class</i>
    argument must be grounded and have the value of a <tt>persistent-metaclasss</tt> class or
    the name of such a class. <i>?instance</i> is a variable that will be unified with a
    succession of instances of that class. If there are no additional arguments, the clause
    succeeds once for each instance of that class in the database.<p>If there are additional
    arguments, they are pairs of <i>slot-name</i>s and <i>slot-value</i>s. Each <i>slot-name</i>
    must be grounded and be a symbol naming a slot. If ungrounded, the functor silently fails.
    The value of that slot is unified against the <i>slot-value</i> which may be grounded or
    not.</p>
    <p>If the first slot is indexed and the first value is fully grounded, retrieval uses
    AllegroCache's indexing and is fast. Otherwise retrieval may need to iterate over all
    instances of the class. Improvements in this simple indexing strategy may be explored in
    future releases.</td>
  </tr>
</tbody>
</table>

<p>This is an example of a Roman numeral database that can do arithmetic by database
lookup. The objects in the database store Roman numeral and English representations. The
example retrieves the integer and English representation of numbers that are half the
value of perfect squares that are multiples of 100. </p>

<pre>
(defclass roman ()
  ((int     :accessor int     :index :any-unique :initarg :int)
   (roman   :accessor roman   :index :any-unique :initarg :roman)
   (english :accessor english :index :any-unique :initarg :english)
   (0mod100 :accessor 0mod100 :index :any        :initarg :0mod100)
   (square  :accessor square  :initarg :square))
  (:metaclass db.allegrocache:persistent-class))

(defun test-populate ()
  (with-file-database (&quot;roman.db&quot; :if-exists :supersede :if-does-not-exist :create)
    (loop for i from 1 to 500
        do (make-instance 'roman
             :int i
             :roman   (intern (format nil &quot;~@r&quot; i) (load-time-value (find-package :keyword)))
             :english (mapcar (lambda (string)
                                (intern string
                                        (load-time-value (find-package :keyword))))
                              (split-re &quot;[ -]&quot; (format nil &quot;~r&quot; i)))
             :0mod100 (zerop (mod i 100))
             :square (* i i)))))

(defmacro with-file-database ((name
                               &amp;key (if-exists nil if-exists-p)
                                    (if-does-not-exist nil if-does-not-exist-p)
                                    read-only)
                              &amp;body body)
  `(let ((db.allegrocache:*allegrocache* nil))
     (unwind-protect
         (multiple-value-prog1
             (progn
               (db.allegrocache:open-file-database
                ,name
                ,@(and if-exists-p
                       `(:if-exists ,if-exists))
                ,@(and if-does-not-exist-p
                       `(:if-does-not-exist ,if-does-not-exist)))
               ,@body)
           (unless ,read-only
             (db.allegrocache:commit)))
       (when db.allegrocache:*allegrocache*
         (db.allegrocache:close-database db.allegrocache:*allegrocache*)))))

cl-user(15): (test-populate)
nil
cl-user(16): (with-file-database (&quot;roman.db&quot;)
               (?- (bagof (?half ?english)
                          (and
                           (db roman ?r 0mod100 t int ?int english ?english square ?square)
                           (lisp ?half (truncate ?int 2))
                           (db roman ?r2 int ?half english ?english-half))
                          ?bag)))
?r = 
?english = 
?square = 
?int = 
?r2 = 
?half = 
?english-half = 
?bag = ((100 (two hundred)) (150 (three hundred)) (200 (four hundred)) (250 (five hundred))
        (50 (one hundred)))
No.
</pre>

<h3>Known Issues.</h3>

<p><b>Allegro Prolog</b> is a new product and rough edges can be expected while experience
is gained supporting large programs. More attention is needed on smooth integration into
the Allegro program development and debugging environment. These are some other known
issues: </p>

<p>The interface to and capabilities of <tt>leash</tt> deserve extension better to support
debugging. A mechanism such as the Allegro CL <tt>:inside</tt> trace option would be
especially useful, as would the ability to select individually which of a functor's four
WAM ports to leash. In some cases immediately recursive invocation of a functor will not
be intercepted by leash. (The issue is essentially the same as tracing lisp self calls.)</p>

<p>It might be worthwhile to make public the Prolog compiler-macro interface if it allows
better optimization of user code. However, the API and conventions for a compiler macro
are complex and need review and some convenience macros before the machinery can be
exported.</p>

<p>A more powerful solution to the tail-jump elimination problem is pending.</p>

<p>Performance could be improved in some kinds of programs by a capability to control
indexing of rule terms. This is available as the <tt>index/1</tt> in some Prolog
implementations.</p>

<p>Definition of Prolog functors should be integrated into the Allegro CL source file
recording machinery. This would provide warnings about multiple definitions, particularly
in definitions on inherited symbols.</p>

<p>An etags extension for <tt>&lt;-</tt> and <tt>&lt;--</tt> would be helpful.</p>

<p>Franz Inc is interested in bugs and the experience of programmers using <b>Allegro
Prolog</b>. Contact </a><a href="mailto:support@franz.com"><tt>support@franz.com</tt></a>.</p>

<h3>Example: the zebra problem</h3>

<p>Here is the Lisp code and the Prolog code for the zebra problem, a well known example
of a puzzle with a set of facts about the attributes of people who live in adjacent
houses. First here is the Lisp code:</p>

<pre>;;;========== zebra.cl</pre>

<pre>;;;; -*- Mode: common-lisp; Syntax: Common-Lisp -*-</pre>

<pre>(in-package :user)
(eval-when (compile load eval)
  (use-package :prolog))</pre>

<pre>(eval-when (compile) (setf excl:*load-xref-info* nil))</pre>

<pre>(&lt;-- (nextto ?x ?y ?list) (iright ?x ?y ?list))
(&lt;-  (nextto ?x ?y ?list) (iright ?y ?x ?list))
(&lt;-- (iright ?left ?right (?left ?right . ?rest)))
(&lt;-  (iright ?left ?right (?x . ?rest))
     (iright ?left ?right ?rest))</pre>

<pre>(&lt;-- (zebra ?h ?w ?z)
     ;; Each house is of the form:
     ;; (house nationality pet cigarette drink house-color)
     (= ?h ((house norwegian ? ? ? ?)   ;1,10
            ?
            (house ? ? ? milk ?) ? ?))  ; 9
     (member (house englishman ? ? ? red) ?h) ; 2
     (member (house spaniard dog ? ? ?) ?h) ; 3
     (member (house ? ? ? coffee green) ?h) ; 4
     (member (house ukrainian ? ? tea ?) ?h) ; 5
     (iright (house ? ? ? ? ivory)      ; 6
             (house ? ? ? ? green) ?h)
     (member (house ? snails winston ? ?) ?h) ; 7
     (member (house ? ? kools ? yellow) ?h) ; 8
     (nextto (house ? ? chesterfield ? ?) ;11
             (house ? fox ? ? ?) ?h)
     (nextto (house ? ? kools ? ?)      ;12
             (house ? horse ? ? ?) ?h)
     (member (house ? ? luckystrike oj ?) ?h) ;13
     (member (house japanese ? parliaments ? ?) ?h) ;14
     (nextto (house norwegian ? ? ? ?)  ;15
             (house ? ? ? ? blue) ?h)
     (member (house ?w ? ? water ?) ?h) ;Q1
     (member (house ?z zebra ? ? ?) ?h) ;Q2
     )</pre>

<pre>;; This runs the query:</pre>

<pre>(?- (zebra ?houses ?water-drinker ?zebra-owner))</pre>

<pre>;; These are benchmarking and profiling functions.  
;; It is believed that solving zebra a
;; single time requires 12825 inferences.</pre>

<pre>(defun zebra-benchmark (&amp;optional (n 1000))
  (declare (optimize (speed 3) (safety 0)))
  (let (rt0 rt1)
    (time (loop initially (setf rt0 (get-internal-run-time))
              repeat n do (prolog (zebra ?houses ?water-drinker ?zebra-owner)
                                  !     ; Stop once answer is found.  
                                        ; This appears to be
                                        ; what other implementations do, 
                                        ; e.g. time/1 in
                                        ; SWI Prolog.
                                  )
              finally (setf rt1 (get-internal-run-time))))
    (let (zebra-owner water-drinker houses)
      (prolog (zebra ?houses ?water-drinker ?zebra-owner)
              ;; Nearly any cons structure created by Prolog 
              ;; unification will be consed with
              ;; dynamic extent.  It isn't safe to return such 
              ;; structure outside the contour
              ;; that created it.  Prolog doesn't need to worry, 
              ;; since unification always
              ;; has dynamic extent, but arbitrary Lisp 
              ;; code needs to be careful.  The first
              ;; two values this function will return are 
              ;; symbols, but the third is a cons
              ;; tree created by Prolog unification.  In order 
              ;; to return it, the tree needs
              ;; to be copied with indefinite extent.
              (lisp (setf zebra-owner ?zebra-owner
                          water-drinker ?water-drinker
                          houses (copy-tree ?houses)))
              !)
      (values (/ (* n 12825) (/ (- rt1 rt0) 1000.0)) ; real time 
                                                     ; is milliseconds
              zebra-owner water-drinker houses))))</pre>

<pre>;;;  zebra.cl end</pre>

<p>Here is Prolog code:</p>

<pre>========== zebra.pl</pre>

<pre>/* -*- Mode: prolog -*-
 *
 * This file for benchmarking against SWI Prolog.
 */</pre>

<pre>nextto(X, Y, List) :- iright(X, Y, List).
nextto(X, Y, List) :- iright(Y, X, List).
iright(Left, Right, [Left, Right | _]).
iright(Left, Right, [_ | Rest]) :- iright(Left, Right, Rest).</pre>

<pre>zebra(H, W, Z) :-
    H = [house(norwegian, _, _, _, _), _, house(_, _, _, milk, _), _, _],
     member(house(englishman, _, _, _, red), H),
     member(house(spaniard, dog, _, _, _), H),
     member(house(_, _, _, coffee, green), H),
     member(house(ukrainian, _,  _, tea, _), H),
     iright(house(_, _, _, _, ivory), house(_, _, _, _, green), H),
     member(house(_, snails, winston, _, _), H),
     member(house(_, _, kools, _, yellow), H),
     nextto(house(_, _, chesterfield, _, _), house(_, fox, _, _, _), H),
     nextto(house(_, _, kools, _, _), house(_, horse, _, _, _), H),
     member(house(_, _, luckystrike, oj, _), H),
     member(house(japanese, _, parliaments, _, _), H),
     nextto(house(norwegian, _, _, _, _), house(_, _, _, _, blue), H),
     member(house(W, _, _, water, _), H),
     member(house(Z, zebra, _, _, _), H).</pre>

<pre>/* This runs the query a single time:
 *  ?- zebra(Houses, WaterDrinker, ZebraOwner).
 */</pre>

<pre>zebra1(Houses, WaterDrinker, ZebraOwner) :-
        zebra(Houses, WaterDrinker, ZebraOwner), !.</pre>

<pre>benchmark1 :-
        flag(benchmark,_,0),
        repeat,
        zebra1(Houses, WaterDrinker, ZebraOwner),
        flag(benchmark,N,N+1),
        N = 1000,
        !.</pre>

<pre>benchmark :- time(benchmark1).</pre>

<pre>========== end</pre>

<h4>Copyright (c) 2004,2005 Franz Inc, Oakland, CA - All Rights Reserved.</h4>
</body>
</html>
