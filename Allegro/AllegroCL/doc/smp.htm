<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"> <title>Symmetric Multiprocessing in Allegro CL</title></head><link rel="stylesheet" href="acldoc-styles.css" type="text/css"><body><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faqs/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 8.2</b><br><small><a href="introduction.htm#updates-s">Unrevised from 8.1 to 8.2.</a></small><br><a href="http://www.franz.com/support/documentation/8.1/doc/smp.htm">8.1 version</a></td></tr></table><h1 id="2">Symmetric Multiprocessing in Allegro CL</h1><p id="3">This document contains the following sections:</p><a href="#smp-intro-1">1.0 Symmetric Multiprocessing introduction</a><br>&nbsp;&nbsp;&nbsp;<a href="#smp-example-2">1.1 An example of the difference between SMP Lisp and non-SMP Lisp</a><br>&nbsp;&nbsp;&nbsp;<a href="#non-smp-avail-2">1.2 Non-SMP images on platforms that support SMP</a><br><a href="#depr-macs-1">2.0 Deprecated macros</a><br>&nbsp;&nbsp;&nbsp;<a href="#atomically-2">2.1 Deprecated macro: excl::atomically</a><br>&nbsp;&nbsp;&nbsp;<a href="#without-interrupts-2">2.2 Deprecated macro: without-interrupts</a><br>&nbsp;&nbsp;&nbsp;<a href="#without-scheduling-2">2.3 Deprecated macro: sys:without-scheduling</a><br><a href="#new-macs-1">3.0 New macros and related functionality</a><br>&nbsp;&nbsp;&nbsp;<a href="#non-sync-2">3.1 Non-synchronizing usages</a><br>&nbsp;&nbsp;&nbsp;<a href="#read-write-2">3.2 Atomic read-modify-write primitives</a><br>&nbsp;&nbsp;&nbsp;<a href="#concur-2">3.3 Concurrency control for shared objects</a><br><a href="#safe-ops-1">4.0 Safe and unsafe operators</a><br><a href="#patch-1">5.0 The 8.1 SMP-macros patch</a><br><hr><hr><h2 id="4"><a name="smp-intro-1">1.0 Symmetric Multiprocessing introduction</a></h2>

<p id="5">
Starting in Allegro CL 9.0 (not released at this
time), Allegro CL on certain platforms will have images that
will allow using multiple independent processors. This may result in
dramatic speedups in applications as the additional processor
resources are used.
</p>
<p id="6">
But there is a downside. Using multiple processors simultaneously can
make programs that run correctly on a single processor fail, either by
producing incorrect results or by signalling enexpected errors or even
by failing altogether. Here are three areas where such failures can
occur:
</p>
<ol>
<li id="7">
There is no automatic way to make code being executed in one process
run to completion while all other processes do nothing. In a Lisp
using one processor only to execute Lisp code, wrapping a section of
code with <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a>
meant that when that code was run, it would run to completion while
all other processes waited. Using multiple processors means that other
processes run at the same time. (The code will still not process
interrupts, but that no longer means other Lisp code is not running.)
See <a href="#smp-example-2">Section 1.1 An example of the difference between SMP Lisp and non-SMP Lisp</a> for more information
on this point.
</li>
<li id="8">
When an object is modified by one process and simultaneously accessed
by another, the accessing process can get an incorrect result or can
even fail, perhaps causing Lisp itself to fail. By 'incorrect result'
we do not just mean an out of date result; we mean there is a
possibility of getting a result that was never
correct. See <a href="#safe-ops-1">Section 4.0 Safe and unsafe operators</a> for more
information.
</li>
<li id="9">
Certain operators that are supposed to guarantee certain results can
no longer be guaranteed to work as advertised. <a href="../ansicl/dictentr/pushnew.htm"><b>pushnew</b></a>, for example, if called without some
process-locking protection in two separate processes, can push the
same value onto a list from each process resulting a a duplicate in
the list. (Each process completes the test for whether the object is
new before the other has added the item to the list, and so each then
adds the item.)
</li>
</ol>
<p id="10">
Some of these problems (but not number 1 so long as the Lisp heap was
not modified by foreign code) actually already exist in a non-SMP
multiprocessing Lisp, as Allegro CL has been for many years. But
because the system-initiated process-switch latency was so slow (on
the order of a second) compared to the execution speed, the errors
either never occured or were so rare that the problem was never
properly idenified or even noticed. But in an SMP Lisp, where
processes are just running simultaneously and there is no system
process swicth latency, the rare or never happening events are
suddenly much, much more likely and subtle coding errors which could
be ignored before will become unignorable.
</p>
<p id="11">
Please realize first that essentially all problems arise from object
modification: although the failure can come from the process reading a
value (because the modification process can result in
inconsistencies); and second that tools such as locks
(see <a href="multiprocessing.htm#process-locks-1">Process
locks</a> in <a href="multiprocessing.htm">multiprocessing.htm</a>) and gates
(see <a href="multiprocessing.htm#gates-1">Gates</a>
in <a href="multiprocessing.htm">multiprocessing.htm</a>) are available to ensure
that processes do not interfere with each other. If you use SMP, it is
your programs responsibility to ensure that modifications are
consistent and do not cause problems.
</p>
<p id="12">
The important point is that programs which ran without error (or had
such a small chance of error that they for all practical purposes ran
without error) may fail in an SMP environment, either because of
mysterious and unexpected errors or (and this is likely worse) by not
erroring and instead producing very incorrect results.
<p id="13">
</p>
This document describes the problems and also the new tools which will
assist in making your program SMP-safe.  It discusses the general
problem and the macros and data elements introduced in Allegro CL 9.0
to control concurrent access. Many of the macros have keyword
arguments that can be used to control how the macro expands in a
non-SMP Lisp. This makes it easier to write souce code that works
efficiently whether it is compiled for running in an SMP Lisp or a
non-SMP Lisp.
</p>
<p id="14">
In a non-SMP Lisp only one thread of control at a time is ever
running Lisp code. Lisp execution is gated by a mutex
and low-level runtime code selects one lisp process to execute at a time.
A Lisp process can voluntarily yield control, either explicitly
or by waiting on some event. A running Lisp process can also be
preempted, temporarily ceding control to another process in response
to some event.
</p>
<p id="15">
In a non-SMP Lisp interleaved execution of multiple processes is
coarse-grained. A process can not lose control at arbitrary points
in its execution. Running Lisp code checks periodically, at what might
be called safe points, to see if an interruption in the normal flow of
sequence has been requested. If so, the state of the running process
is saved, the state of the preempting process restored, and that second
process allowed to execute.
</p>
<p id="16">
Lisp-level handling of asynchronous signals is restricted to happen at
these same safe points. This is true in SMP-enabled Lisps as well as
in non-SMP Lisps. Low-level, non-Lisp support code keeps a record
of signals seen but not yet processed. This code responds to asynchronous
signals like SIGALRM by recording the event in an unprocessed-signals
buffer and setting a global flag to show that a signal has been seen,
and then returning to the lisp processing that was happening when
the signal was recognized. At the next safe point, the state of the global
flag will be seen and Lisp-level processing of the signal will occur.
In a non-SMP Lisp this could result in a process switch.
</p>
<p id="17">
In a non-SMP Lisp, controlling concurrent access to shared objects
often reduces to controlling when these process-switch and
signal-handling events can occur. By ensuring that a block of Lisp
code will execute without interruption, an application running in a
non-SMP Lisp can provide arbitrarily complex operations that will look
atomic to multiple processes. This is obviously inadequate in an SMP
Lisp, where multiple threads of control are running Lisp code
simultaneously.
</p>

<hr><h2 id="18"><a name="smp-example-2">1.1 An example of the difference between SMP Lisp and non-SMP Lisp</a></h2>


<p id="19">
Consider the following example. We have a variable VAR whose initial
value is the fixnum 8. Various processes are running in Lisp and
independently incrementing or decrementing the value of VAR with calls
to <a href="../ansicl/dictentr/incfdecf.htm"><b>incf</b></a> and <a href="../ansicl/dictentr/incfdecf.htm"><b>decf</b></a>. Our first attempt is:
</p>

<pre id="20">
;; In process-1:
(incf var)

;; In process-2:
(incf var)

;; In process-3:
(decf var)
</pre>

<p id="21">
But this might cause us trouble, because <code>(incf var)</code>
macroexpands to <code>(setq var (+ var 1))</code>. It is
possible that <code>(+ 1 var)</code> is evaluated and then there
is a process switch, before that value is stored as the value of VAR,
so when the process gets control again, it might store what has become
the wrong value.
</p>
<p id="22">
But in a non-SMP Lisp, we can prevent a process switch
with <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a>, so
we recode as follows:
</p>

<pre id="23">
;; In process-1:
(without-interrupts (incf var))

;; In process-2:
(without-interrupts (incf var))

;; In process-3:
(without-interrupts (decf var))
</pre>

<p id="24">
In non-SMP Lisp, once process-1, process-2, and process-3 have
completed (or at least executed the forms shown), the value of VAR
will be 9 (8 + 1 + 1 - 1). We do not actually know in what order the
additions and subtraction will occur, but the <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a> guarantees that each will
complete once it has started without any process switch and so we can
be confident of the final result.
</p>
<p id="25">
In an SMP Lisp, the <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a> macro does not have the
effect of preventing a process switch because all processes can be
running simultaneously on different processors, and so the whole
notion of 'process switch' is problematic. So the following can
happen:
</p>

<pre id="26">
1. process-1 reads the value 8 from VAR and places that value in one
of its registers.

2. Before process-1 does its calculation and stores a new value in
VAR, process-2 reads the value (still 8) from VAR and places it in one
of its registers.

3. process-1 adds 1 to 8 and stores the result (9) in VAR.

4. After process-1 stores its new value but before process-2 stores a
new value, process-3 reads the value (9) from VAR and places it in one
of its registers.

5. process-2 adds 1 to 8 and stores the result (9) as the value of
VAR.

6. process-3 subtracts 1 from 9 and stores the result (8) as the value
of VAR.
</pre>

<p id="27">
When all this completes, the value of VAR is 8, not 9. The value could
indeed end up as 7 (process-3 reads first and stores last), 8 (as
shown), 9 or 10 (left as an excercise to the reader).
</p>
<p id="28">
So code which depended on <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a> to ensure that certain
operations will not be interfered with and that therefore certain
final results could be depended upon will no longer work as expected.
</p>
<p id="29">
The fundamental issue is that on a non-SMP Lisp, process locking
(ensuring that code in a single Lisp process is guaranteed to execute
to completion without interruption) gave you object locking (ensuring
that only one process could read or set a value) as a side effect. In
an SMP Lisp, that is no longer true.
</p>
<p id="30">
New macros (see <a href="#new-macs-1">Section 3.0 New macros and related functionality</a>) provide
object locking to allow the example here and related examples to run
as desired. The macros <a href="operators/excl/incf-atomic.htm"><b>incf-atomic</b></a> and <a href="operators/excl/decf-atomic.htm"><b>decf-atomic</b></a> are specific to this example and
others to related examples. Of course, programmers can also use more
complex mechanisms to lock objects and processes and avoid undesired
concurrency, although these techniques often have a significant
overhead.
</p>
<p id="31">
Here is the code that guarantees that all the incf's and decf's will
run as desired (but in an undefined order). This works in SMP and
non-SMP Lisps.
</p>
<pre id="32">
;; In process-1:
(incf-atomic var)

;; In process-2:
(incf-atomic var)

;; In process-3:
(decf-atomic var)
</pre>



<hr><h2 id="33"><a name="non-smp-avail-2">1.2 Non-SMP images on platforms that support SMP</a></h2>

<p id="34">
All platforms that will support SMP Lisp will also have non-SMP images
available. Current programs that depend on the fact that Lisp code is
run on a single processors will thus continue to work using the
non-SMP images without any changes relating to SMP (beyond trivial
supression of compiler warnings, done by evaluating <code>(setq
excl::*warn-smp-usage* nil)</code>).
</p>
<p id="35">
Therefore there is no need for users who do not wish to use SMP to
make any changes to their programs. The rest of this document is
directed at users who do wish to use SMP. They will have to determine
whether their code must be modified (usally, some changes must be
made) using the information in this document.
</p>




<hr><hr><h2 id="36"><a name="depr-macs-1">2.0 Deprecated macros</a></h2>

<p id="37">
Three macros are used in non-SMP Lisps to provide concurrancy control:
<b>excl::atomically</b>, <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a>, and
<a href="operators/system/without-scheduling.htm"><b>without-scheduling</b></a>. (The
symbol <b>excl::atomically</b> was not exported and the associated
macro never documented, but some users were aware of it; if you are
unfamiliar with <b>excl::atomically</b>, you need not worry about it
as its use is now deprecated. You just have less code to modify). 
</p>
<p id="38">
These macros are all very light-weight in processing overhead and are
much cheaper than using a process-lock. They have the additional
advantage that they do not require the multiprocessing package be
loaded. This allows a programmer to write code that runs correctly in
a multi-process application, but still runs efficiently in a
single-process appliction. All three rely on the coarse-grained
scheduling of non-SMP multiprocessing. All three represent problem
situations for multiprocessing under SMP. They are all deprecated in
8.2 and later Lisps (and also in 8.1 after the relevant patch -- see
<a href="#patch-1">Section 5.0 The 8.1 SMP-macros patch</a> -- is loaded), although they
are still available and still perform the same functions in a non-SMP
lisp as they did before 8.2.
</p>
<p id="39">
New macros have been introduced in 8.2 to provide the same functions
as the deprecated macros, in ways that are compatible with an smp
environment. The new macros are described
in <a href="#new-macs-1">Section 3.0 New macros and related functionality</a>. Starting in 8.2 and in
8.1 with the relevant patch loaded, the deprecated macros generate
compile-time warnings (which can be globally muffled by
evaluating <code>(setq excl::*warn-smp-usage* nil)</code>).
</p>
<p id="40">
A patch for 8.1 acl (see <a href="#patch-1">Section 5.0 The 8.1 SMP-macros patch</a>)
redefines the deprecated macros to give the same compile-time warning,
and also defines the new macros designed to replace them in 8.2 and
later Lisps. This makes it feasible to write code that will compile
and run correctly in an SMP-enabled 9.0 Lisp, in 8.2, and in a patched
8.1 lisp.
</p>

<hr><h2 id="41"><a name="atomically-2">2.1 Deprecated macro: excl::atomically</a></h2>

<p id="42">
The <b>excl::atomically</b> macro was never documented and the symbol
naming it was never exported. However, some users made use of
it. Users who never used atomically can skip this section.
</p>
<p id="43">
<b>excl::atomically</b> is wrapped around a sequence of forms:
</p>

<pre id="44">
(excl::atomically . BODY)
</pre>

<p id="45">
This acted exactly like
</p>

<pre id="46">
(progn . BODY)
</pre>

<p id="47">
as far as code generation was concerned, but the compiler would produce
a diagnostic if BODY involved any operations that might result in a
process switch or a garbage collection. Such opportunities are inherent
in almost any out-of-line call, in object allocation, in anything that
might signal an error, and in several other low-level actions. If BODY
contained none of these, then the compiler would accept the form and the
programmer could be confident that BODY would execute atomically as far
as Lisp processes were concerned.
</p>
<p id="48">
A major use of <b>excl::atomically</b> was to wrap a section of code
in which it was required that garbage collection not relocate some
object or objects. This requirement was independent of
multiprocessing concerns, and happened most often in low level code
that was trying to process an array's elements very efficiently.
</p>
<p id="49">
In some cases, the <b>excl::atomically</b> form was used not to assure
atomicity, or to guarantee gc-free running, but to wrap a section of
code that needed to be as fast as possible. If some infelicitous
change to the compiler caused it to start generating out-of-line calls
where in-line code was expected, the presence of
the <b>excl::atomically</b> wrapper made sure there would be a
compile-time warning.
</p>
<p id="50">
The new macro <a href="operators/excl/fast-and-clean.htm"><b>fast-and-clean</b></a>
replaces <b>excl::atomically</b>. In an SMP
Lisp, <code>(fast-and-clean ...)</code>, which is the functional
equialent of <code>(excl::atomically ...)</code>, cannot be
guaranteed to be atomic because of the nature of SMP and atomicity. It
will, however, prevent a gc from happening while the form is
executing, because gc's can only happen when a process allocates
something or at one of the same "safe-point"s that allow interrupts
(described below
in <a href="#without-interrupts-2">Section 2.2 Deprecated macro: without-interrupts</a>). The
<a href="operators/excl/fast-and-clean.htm"><b>fast-and-clean</b></a> form assures
us we have neither of these. Even so, if control of garbage collection
is the issue, using the <a href="operators/excl/with-pinned-objects.htm"><b>with-pinned-objects</b></a> macro is preferred.
</p>



<hr><h2 id="51"><a name="without-interrupts-2">2.2 Deprecated macro: without-interrupts</a></h2>

<p id="52">
The <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a> macro
works as follows:
</p>

<pre id="53">
(without-interrupts . BODY)
</pre>

<p id="54">
acts almost exactly like
</p>

<pre id="55">
(let ((excl::*without-interrupts* t)) BODY)
</pre>

<p id="56">
<b><code>excl::*without-interrupts*</code></b> is a special
variable (named by an unexported symbol and so not documented) which
gates the processing of asynchronous signals. When an asynchronous
signal triggers Lisp's low-level signal handler, the signal is queued
and a flag is set to indicate the situation. This happens without any
Lisp code executing, and does not interrupt the running Lisp
code. While executing, Lisp code polls the flag periodically, checking
for the signal-has-happened situation.
</p>
<p id="57">
These checks are made at safe-points in the code, where the Lisp
system is ready to allow execution of arbitrary signal-handling code
in an interrupt-the-application mode; handling the signals at the Lisp
level could result in a process-interrupt, or cause a process switch
in a non-SMP Lisp.
If <b><code>excl::*without-interrupts*</code></b>
is <code>nil</code>, then the safe-point check happens
normally, and any queued signals get
handled. If <b><code>excl::*without-interrupts*</code></b> is
non-<code>nil</code>, then queued signals are ignored. No
process-interrupt will be handled, and in a non-SMP Lisp, no automatic
process switch can happen
when <b><code>excl::*without-interrupts*</code></b> is
non-<code>nil</code>, although an explicit process-wait or
other scheduling operation would break through this barrier.
</p>
<p id="58">
Ignored signals are not discarded, and signals caught while
<b><code>excl::*without-interrupts*</code></b> is
non-<code>nil</code> will still be added to the queue of
pending signals, to be processed at some safe-point after leaving the
without-interrupts regime. The way in which without-interrupts differs
from the simple <b>let</b> form shown above has to do with details of
safe and efficient processing, ensuring that we pay as little as
possible in computation overhead to ignore the pending signals and
that when <b><code>excl::*without-interrupts*</code></b> returns
to a <code>nil</code> value, we handle any pending signals
at the next safe-point.
</p>
<p id="59">
However, even though interrupts are delayed and process switches from
the code running within a <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a> are also inhibited, object
locking, a side effect in a non-SMP Lisp is no longer guaranteed and
gc's may occur even if the code within the <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a> form does no consing and so
does not itself trigger a gc.
</p>
<p id="60">
The new macro <a href="operators/excl/with-delayed-interrupts.htm"><b>with-delayed-interrupts</b></a> replaces
<a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a>. In a
non-SMP Lisp, <a href="operators/excl/with-delayed-interrupts.htm"><b>with-delayed-interrupts</b></a> expands to the same
code as <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a>
(but does not produce a compiler warning). In an SMP Lisp, interrupts
are delayed, so the code within the macro runs to completion once it
is started, but objects are not locked as other processes can run.
</p>



<hr><h2 id="61"><a name="without-scheduling-2">2.3 Deprecated macro: sys:without-scheduling</a></h2>

<p id="62">
<a href="operators/system/without-scheduling.htm"><b>sys:without-scheduling</b></a>
worked as follows:
</p>

<pre id="63">
(without-scheduling . BODY)
</pre>

<p id="64">
worked like
</p>

<pre id="65">
(let ((*disallow-scheduling* t))
  (progn . BODY))
</pre>

<p id="66">
<a href="variables/system/s_disallow-scheduling_s.htm"><code>*disallow-scheduling*</code></a> is a special variable
that gates automatic process switches in non-SMP Lisps. It is checked
when other factors indicate it is time to stop the currently running
process and let another one have control for a while. If it
is <code>nil</code>, then the switch will happen; if
non-<code>nil</code>, the switch will be prohibited and
the current process will continue running. <a href="variables/system/s_disallow-scheduling_s.htm"><code>sys:*disallow-scheduling*</code></a> finds some
specialized uses, as when it is important to honor <a href="operators/system/with-timeout.htm"><b>sys:with-timeout</b></a> requests (which require
handling timer signals, which would be ignored by <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a>) without allowing a process
switch to occur.
</p>
<p id="67">
There is no exact replacement for sys:without-scheduling since the
model for processes is changed and the concept of process switching is
nearly without meaning. If you use sys:without-scheduling, the
question is why? If the purpose was object locking (ensuring that
values are not read or written by other processes while code runs),
you have to use the new object locking routines. If the purpose was to
ensure that the process ran to completion but also allowed for signal
processing (for <a href="operators/system/with-timeout.htm"><b>sys:with-timeout</b></a>, for example), that is not
longer supported.
</p>



<hr><hr><h2 id="68"><a name="new-macs-1">3.0 New macros and related functionality</a></h2>

<p id="69">
We provide new macros for efficient object-level synchronization.
Some of these involve locking objects, and others are atomic
read-modify-write primitives. We also provide a set of macros to perform
those functions of the deprecated macros that did not serve to synchronize
access to specific objects. These new macros appear in 8.2 and later lisps.
A patch makes the macros available in 8.1, with certain limits, as
described with specific macro descriptions.
</p>
<p id="70">
A Lisp that actually supports SMP has <code>:smp</code> on its
<a href="../ansicl/dictentr/features.htm"><code>*features*</code></a> list. A lisp
that supports these new macros has <code>:smp-macros</code> on
its <a href="../ansicl/dictentr/features.htm"><code>*features*</code></a>
list. Thus a 9.0 smp-enabled Lisp has both <code>:smp</code> and
<code>:smp-macros</code> on its <a href="../ansicl/dictentr/features.htm"><code>*features*</code></a> list, while an 8.2 Lisp, a patched
8.1 Lisp, or a non-SMP 9.0 Lisp have the
feature <code>:smp-macros</code> but
not <code>:smp</code>.
</p>
<p id="71">
All the symbols naming the functions, macros, classes and structure types
added as part of SMP are exported from the excl package.
</p>

<hr><h2 id="72"><a name="non-sync-2">3.1 Non-synchronizing usages</a></h2>

<p id="73">
The first three new macros provide the non-concurrent-access-related
uses of the old <b>excl::atomically</b> and <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a> macros.
</p>
<ul>
<li id="74">
<a href="operators/excl/fast-and-clean.htm"><b>fast-and-clean</b></a>: replaces
<b>excl::atomically</b>. It provides compile-time information about the
code it wraps.
</li>
<li id="75">
<a href="operators/excl/with-pinned-objects.htm"><b>with-pinned-objects</b></a>: this
replaces another use of <b>excl::atomically</b>, which was to ensure
that objects did not move because of a gc. <b>excl::atomically</b>
could ensure a gc did not happen. Gc's only happen when all processes
permit it, and the process running <a href="operators/excl/with-pinned-objects.htm"><b>with-pinned-objects</b></a> will not permit a gc and
will not fail because it does not allocate.
</li>
<li id="76">
<a href="operators/excl/with-delayed-interrupts.htm"><b>with-delayed-interrupts</b></a>:
this replaces <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a>. It evaluates and compiles
exactly as <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a> did. In an SMP Lisp it
provides no cross-process protection of shared objects. Its entire
purpose in that environment is to protect blocks of code that need to
run to completion even in the face of timeouts and possible
process-interrupt calls from other processes.
</li>
</ul>



<hr><h2 id="77"><a name="read-write-2">3.2 Atomic read-modify-write primitives</a></h2>

<p id="78">
When an atomic operation fits the pattern
</p>

<pre id="79">
(setf [place] (foo [place]))
</pre>

<p id="80">
and [place] is one of several inline-accessible 'slots' like (car x),
the compiler can generate code to ensure that the value in [place]
doesn't change between the initial read and the subsequent write.
There are several macros that provide special cases of this operation,
and a general conditional-update form on which all of them are based.
[place] can be any of the following <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a>-places:
</p>
<ul>
<li id="81">
(global-symbol-value symbol-form)
</li>
<li id="82">
symbol (iff the symbol has been declared with <a href="operators/excl/defvar-nonbindable.htm"><b>defvar-nonbindable</b></a>)
</li>
<li id="83">
(car cons-form)
</li>
<li id="84">
(cdr cons-form)
</li>
<li id="85">
(memref object-form offset-form pos-form size-form)
</li>
<li id="86">
(memref-int address-form offset-form pos-form size-form)
</li>
<li id="87">
(svref array-form index-form)
</li>
<li id="88">
(structure-slot-ref structure-form)
</li>
</ul>
<p id="89">
These places are a subset of places legal for <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a>. In particlar, they do not include local or
special bound variables. Local places that cannot be shared between
multiple processes, but the actual reason is really one of
hardware/system limits on where can be done a low-level atomic
read-modify-write.
</p>
<p id="90">
The relevant macros are:
</p>
<ul>
<li id="91">
<a href="operators/excl/incf-atomic.htm"><b>incf-atomic</b></a>
and <a href="operators/excl/decf-atomic.htm"><b>decf-atomic</b></a>: these
expand into code that acts like <a href="../ansicl/dictentr/incfdecf.htm"><b>incf</b></a> or <a href="../ansicl/dictentr/incfdecf.htm"><b>decf</b></a> with the same arguments except that the
update is atomic with respect to any other processes looking at the
same [place]. That is, if several processes simultaneously try to
<a href="operators/excl/incf-atomic.htm"><b>incf-atomic</b></a> and/or
<a href="operators/excl/decf-atomic.htm"><b>decf-atomic</b></a> the same
location, all operations occur sequentially in some unspecified order.
</li>
<li id="92">
<a href="operators/excl/push-atomic.htm"><b>push-atomic</b></a>
and <a href="operators/excl/pop-atomic.htm"><b>pop-atomic</b></a>: these expand
into code that acts like <a href="../ansicl/dictentr/push.htm"><b>push</b></a>
or <a href="../ansicl/dictentr/pop.htm"><b>pop</b></a> with the same
arguments except that the update to [place] is atomic with respect to
all other processes looking at the same [place]. That is, any number
of simultaneous <a href="operators/excl/push-atomic.htm"><b>push-atomic</b></a>
and <a href="operators/excl/pop-atomic.htm"><b>pop-atomic</b></a> operations on
the same location will act as if they occured sequentially in some
unspecified order.
</li>
<li id="93">
<a href="operators/excl/atomic-conditional-setf.htm"><b>atomic-conditional-setf</b></a>:
this is the primitive form on which the previous atomic operations are
based. It acts very much like <code>(when (eq [place] oldval-form)
(setf [place] newval-form) t)</code> except that the subforms of
[place] are evaluated just once, and the whole operation is atomic
with respect to other operations looking at or modifying [place].
</li>
<li id="94">
<a href="operators/excl/update-atomic.htm"><b>update-atomic</b></a>: this macro
expands into code that does a read-modify-write operation that is
atomic with respect to the value in a place.
</li>
<li id="95">
<a href="operators/excl/globalq.htm"><b>globalq</b></a>: <code>(globalq
x)</code> is a macro shorthand
for <code>(system:global-symbol-value 'x)</code>.
</li>
<li id="96">
<a href="operators/excl/defvar-nonbindable.htm"><b>defvar-nonbindable</b></a>: this
acts like a <a href="../ansicl/dictentr/defparam.htm"><b>defvar</b></a>, with the
additional function of flagging symbol so that it cannot be
lambda-bound. 
</li>
<li id="97">
<a href="operators/excl/get-atomic-modify-expansion.htm"><b>get-atomic-modify-expansion</b></a>:
this function is called by the atomic-modify macro expanders to find
out how to treat place-form. It returns six values.
</li>
</ul>




<hr><h2 id="98"><a name="concur-2">3.3 Concurrency control for shared objects</a></h2>

<p id="99">
None of the deprecated macros provide effective concurrency control in
an smp lisp. New macros are provided to give the programmer tools for
controlling concurrent access. There is no way to make the change to
smp automatic and painless. The crux of the problem is that in the
absence of smp, one-sided concurrency control works. That is, a
process modifying a shared object could wrap a series of modifications
with pre-8.2 forms like those using <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a>, and be assured that all
processes would see those changes as an atomic transaction. The forms
themselves assured that no other process would see the object until
all the changes were in place.
</p>
<p id="100">
A confounding factor is that pre-8.2 concurrency was very
coarse-grained. Processes were preempted at a very low frequency,
typically once in 2 seconds, unless they explicitly waited on some
condition. Even with no attempt at concurrency control, it was rare to
see an inconveniently-timed process switch break a transaction that
should have been atomic.
</p>
<p id="101">
In an SMP Lisp, concurrency is as fine-grained as it could possibly be.
Writers and readers must all cooperate to ensure that access to shared
structures is legitimate.
</p>
<p id="102">
Allegro CL has a set of object-locking macros. These are lighter weight
and less flexible than the <a href="operators/mp/process-lock.htm"><b>mp:process-lock</b></a> features, and do not rely on
the mp package. They must be used with care to avoid deadlocks.
</p>
<p id="103">
The macros and related functionality are:
</p>

<ul>
<li id="104">
<a href="operators/excl/with-locked-structure.htm"><b>with-locked-structure</b></a>:
expands into code that waits until the executing process acquires
control of its argument structure object, then evaluates the forms in
the body as an implicit <a href="../ansicl/dictentr/progn.htm"><b>progn</b></a>. It then releases control of the object
and returns whatever values the last form in the body returned.
</li>
<li id="105">
<a href="classes/excl/synchronizing-structure.htm"><code>synchronizing-structure</code></a>:
this structure class is used as a base structure when instances of a
structure class are to be locked with the <a href="operators/excl/with-locked-structure.htm"><b>with-locked-structure</b></a> macro.
</li>
<li id="106">
<a href="classes/excl/basic-lock.htm"><code>basic-lock</code></a>: this
structure class is a simple extension of synchronizing-structure,
adding a name slot.
</li>
<li id="107">
<a href="operators/excl/with-locked-object.htm"><b>with-locked-object</b></a>: this
macro expands into code that waits until the executing process
acquires control of the object, then evaluates the forms in the body
as an implicit progn. It then releases control of the object and
returns whatever values the last form in the body returned.
</li>
<li id="108">
<a href="operators/excl/with-object-lock-released.htm"><b>with-object-lock-released</b></a>:
this macro can only appear lexically inside the body of
a <a href="operators/excl/with-locked-object.htm"><b>with-locked-object</b></a>
macro. The lock obtained in the immediately enclosing
<a href="operators/excl/with-locked-object.htm"><b>with-locked-object</b></a> macro is
released, body is executed, and then the lock is reobtained.
</li>
<li id="109">
<a href="classes/excl/lockable-object.htm"><code>lockable-object</code></a>: this is
a mixin class that allows subclasses to be used in the
with-locked-object macro.
</li>
<li id="110">
<a href="operators/excl/with-locked-stream.htm"><b>with-locked-stream</b></a>: like
<a href="operators/excl/with-locked-object.htm"><b>with-locked-object</b></a>, but
applies to objects that are streams.
</li>
<li id="111">
<a href="operators/excl/critical-section.htm"><b>critical-section</b></a>: this macro
expands into code that uses a unique basic-lock associated with the
expansion to control execution of the body code. Only one process at a
time can acquire ownership of the lock and execute the forms in body.
Ownership of the lock is relinquished when control leaves body by
falling through or by non-local exit. The result of evaluating
the <a href="operators/excl/critical-section.htm"><b>critical-section</b></a> code is
the result of the last form in body.
</li>
</ul>



<hr><hr><h2 id="112"><a name="safe-ops-1">4.0 Safe and unsafe operators</a></h2>

<p id="113">
An operator which accesses or sets the value stored in an object is
<b>safe</b> when it can be called in a number of processes, otherwise
unsynchronized by user code, and the result is the same as if the
operations were done sequentially in a single process though in an
unspecified order. Therefore, safe operations will not error and will
not produce bogus results (results that could never have occured no
matter in what order the operations were done). But safe operations
will not necessarily produce the same results in repeated runs.
</p>
<p id="114">
Unsafe operators are those which could unexpectedly error or could
produce results which are bogus according to the definition above.
</p>
<p id="115">
Operators that do not make any changes (i.e. do not set value), safety
means that the result will be meaningful and correct for some
instantaneous state of the data structure. Each thread will see a data
structure in a consistent state. In operators that modify data are
safe if they see data structures in some instantaneous consistent
state, and leave the data structure in a consistent state.
</p>
<p id="116">
It is important to emphasize, so we will say it again, that safe
operators are not guaranteed to produce the same result in repeated
runs, just a result that is consistent with some possible sequence of
evaluation, produced by some interleaving of the operations from the
multiple processes.
</p>
<h3 id="117">
Safe operators and operations
</h3>
<ul>
<li id="118">
<a href="../ansicl/dictentr/gethash.htm"><b>gethash</b></a> and <a href="../ansicl/dictentr/gethash.htm"><b>(setf gethash)</b></a>: these are safe
operations. You will always get a result that could have arisen from
the operations done in some possible sequence in a single process. (A
possible sequence is one that interleaves the sequences from each
individual process, preserving the order of calls in each specific
process.)
</li>
<li id="119">
Property list functions <a href="../ansicl/dictentr/get.htm"><b>get</b></a>,
<a href="../ansicl/dictentr/get.htm"><b>(setf
get)</b></a>, <a href="../ansicl/dictentr/getf.htm"><b>getf</b></a>, <a href="../ansicl/dictentr/getf.htm"><b>(setf getf)</b></a>, <a href="../ansicl/dictentr/remf.htm"><b>remf</b></a>, <a href="../ansicl/dictentr/remprop.htm"><b>remprop</b></a>: these are safe so long as all processes
modifying the property list use these operators. If a process modifies
the property list using other operator (such a <a href="../ansicl/dictentr/carcdrca.htm"><b>(setf car)</b></a> or <a href="../ansicl/dictentr/nth.htm"><b>(setf nth)</b></a>), then the listed
functions are not safe.
</li>
</ul>

<h3 id="120">
Unsafe operators
</h3>
<p id="121">
Basically any operator that modifies a value is unsafe except those
listed above and the atomic operators described elsewhere in this
document. In particular sequence functions and their <a href="../ansicl/dictentr/setfpset.htm"><b>setf</b></a>'s are unsafe. Operators
like <a href="../ansicl/dictentr/pushnew.htm"><b>pushnew</b></a>, which is
supposed to guarantee that duplicates are not added is unsafe and may
produce results that have unexpected duplicates.
</p>


<hr><hr><h2 id="122"><a name="patch-1">5.0 The 8.1 SMP-macros patch</a></h2>

<p id="123">
A patch for Allegro CL 8.1 released in July, 2009 allows the SMP
funcionality to be used in verion 8.1. This patch can only be loaded
into an 8.1 Lisp.  Applying it gives access to those smp-related
macros described in this document that will be available in all 8.2
and later Lisps. Specifically, applying the patch to an 8.1 Lisp has
the following effects:
</p>
<ul>
<li id="124">
It adds the feature <code>:smp-macros</code>, which can be
tested for with <code>(featurep :smp-macros)</code>
(see <a href="operators/excl/featurep.htm"><b>featurep</b></a>),
<code>#+smp-macros</code>, and <code>#-smp-macros</code>.
</li>
<li id="125">
It redefines the macros <b>excl::atomically</b>, <a href="operators/excl/without-interrupts.htm"><b>without-interrupts</b></a>, and <a href="operators/system/without-scheduling.htm"><b>system:without-scheduling</b></a> to give a warning
when used. This warning can be turned off by evaluating <code>(setq
excl::*warn-smp-usage* nil)</code>.
</li>
<li id="126">
It defines the macro <a href="operators/excl/with-delayed-interrupts.htm"><b>with-delayed-interrupts</b></a>.
</li>
<li id="127">
It defines the macro <a href="operators/excl/with-pinned-objects.htm"><b>with-pinned-objects</b></a>.
</li>
<li id="128">
It defines the macro <a href="operators/excl/fast-and-clean.htm"><b>fast-and-clean</b></a>.
</li>
<li id="129">
It defines the macro <a href="operators/excl/defvar-nonbindable.htm"><b>defvar-nonbindable</b></a>, so that the variable can
be used as a place for atomic-update
macros. (<b>Note</b>: <a href="operators/excl/defvar-nonbindable.htm"><b>defvar-nonbindable</b></a> in 8.1 does not protect the
variable from being bound, as it does in 8.2 and later Lisps. This
allows a patched 8.1 Lisp to accept the same source code as the later
Lisps. Correct code will work the same way in 8.1 as in later
lisps. Incorrect code (attempting to bind a no-bind variable) will not
be caught in the patched 8.1 Lisp.)
</li>
<li id="130">
It defines the macro globalq.
</li>
<li id="131">
It defines the structure classes <a href="classes/excl/synchronizing-structure.htm"><code>synchronizing-structure</code></a>
and <a href="classes/excl/basic-lock.htm"><code>basic-lock</code></a>.
</li>
<li id="132">
It defines the macro <a href="operators/excl/with-locked-structure.htm"><b>with-locked-structure</b></a>, but with this
difference: a value must be specified for
the <code>non-smp</code> keyword argument.
</li>
<li id="133">
It defines the macro <a href="operators/excl/with-locked-object.htm"><b>with-locked-object</b></a>, but with
this difference: a value must be specified for
the <i>non-smp</i> keyword argument.
</li>
<li id="134">
It defines the macro <a href="operators/excl/with-object-lock-released.htm"><b>with-object-lock-released</b></a>.
</li>
<li id="135">
It defines the macro <a href="operators/excl/with-locked-stream.htm"><b>with-locked-stream</b></a>, but with this difference:
a value must be specified for the <i>non-smp</i> keyword
argument.
</li>
<li id="136">
It defines the macro <a href="operators/excl/critical-section.htm"><b>critical-section</b></a>, but with this difference: a
value must be specified for the <i>non-smp</i> keyword
argument.
</li>
<li id="137">
It defines the function <a href="operators/excl/get-atomic-modify-expansion.htm"><b>get-atomic-modify-expansion</b></a>.
</li>
<li id="138">
It defines the macros for conditional-atomic-update:
<ul>
<li id="139">
<a href="operators/excl/atomic-conditional-setf.htm"><b>atomic-conditional-setf</b></a>
</li>
<li id="140">
<a href="operators/excl/update-atomic.htm"><b>update-atomic</b></a>
</li>
<li id="141">
<a href="operators/excl/incf-atomic.htm"><b>incf-atomic</b></a>
</li>
<li id="142">
<a href="operators/excl/decf-atomic.htm"><b>decf-atomic</b></a>
</li>
<li id="143">
<a href="operators/excl/push-atomic.htm"><b>push-atomic</b></a>
</li>
<li id="144">
<a href="operators/excl/pop-atomic.htm"><b>pop-atomic</b></a>
</li>
</ul>
</li>
</ul>
</body><hr><p id="2"><small>Copyright (c) 1998-2010, Franz Inc. Oakland, CA., USA. All rights reserved.</small><br><small>Documentation for Allegro CL version 8.2. This page was not revised from the 8.1 page.</small><br>
<small>Created 2010.1.21.</small>
<br></p><table border="0" width="100%" cellpadding="1" cellspacing="0"><tr><td colspan="2" bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3"><tr><td align="left" bgcolor="#00FFFF"><a href="contents.htm"><b>ToC</b></a></td><td align="left" bgcolor="#00FFFF"><a href="introduction.htm"><b>DocOverview</b></a></td><td align="left" bgcolor="#00FFFF"><a href="cgide.htm"><b>CGDoc</b></a></td><td align="left" bgcolor="#00FFFF"><a href="release-notes.htm"><b>RelNotes</b></a></td><td align="left" bgcolor="#00FFFF"><a href="http://www.franz.com/support/faqs/"><b>FAQ</b></a></td><td align="left" bgcolor="#00FFFF"><a href="index.htm"><b>Index</b></a></td><td align="left" bgcolor="#00FFFF"><a href="permuted-index.htm"><b>PermutedIndex</b></a></td></tr></table></td><td align="right"><b>Allegro CL version 8.2</b><br><small><a href="introduction.htm#updates-s">Unrevised from 8.1 to 8.2.</a></small><br><a href="http://www.franz.com/support/documentation/8.1/doc/smp.htm">8.1 version</a></td></tr></table></html>