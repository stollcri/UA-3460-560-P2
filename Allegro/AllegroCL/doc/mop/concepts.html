<html>

<head>
<title>MOP: Concepts</title>
</head>
<a HREF="contents.html">

<body>

<table border="0" width="100%" cellpadding="1" cellspacing="0">
  <tr>
    <td bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3">
      <tr>
        <td align="left" bgcolor="#00FFFF"><a href="../contents.htm"><b>ToC</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../introduction.htm"><b>DocOverview</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../cgide.htm"><b>CGDoc</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../release-notes.htm"><b>RelNotes</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../index.htm"><b>Index</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../permuted-index.htm"><b>PermutedIndex</b></a></td>
      </tr>
    </table>
    </td>
    <td align="right"><b>Allegro CL</b>
    </td>
  </tr>
</table>


<p><img ALT="[Contents]" SRC="Contents.gif" ALIGN="Bottom" width="80" height="40"></a> <a
REL="PREV" HREF="contents.html"><img ALT="[Previous]" SRC="Prev.gif" ALIGN="Bottom"
width="40" height="40"></a> <a REL="UP" HREF="index.html"><img ALT="[Up]" SRC="Up.gif"
ALIGN="Bottom" width="40" height="40"></a> <a REL="NEXT" HREF="dictionary.html"><img
ALT="[Next]" SRC="Next.gif" ALIGN="Bottom" width="40" height="40"></a> </p>

<hr>

<h1><a name="spec1"></a>Concepts</h1>

<h2><a name="introduction">Introduction</a></h2>

<p>The CLOS Specification describes the standard Programmer Interface for the Common Lisp
Object System (CLOS). This document extends that specification by defining a metaobject
protocol for CLOS---that is, a description of CLOS itself as an extensible CLOS program.
In this description, the fundamental elements of CLOS programs (classes, slot definitions,
generic functions, methods, specializers and method combinations) are represented by
first-class objects. The behavior of CLOS is provided by these objects, or, more
precisely, by methods specialized to the classes of these objects. </p>

<p>Because these objects represent pieces of CLOS programs, and because their behavior
provides the behavior of the CLOS language itself, they are considered meta-level objects
or metaobjects. The protocol followed by the metaobjects to provide the behavior of CLOS
is called the CLOS Metaobject Protocol (MOP). </p>

<h2><a name="metaobjects">Metaobjects</a></h2>

<p>For each kind of program element there is a corresponding <em>basic metaobject class</em>.
These are the classes: <b>class</b>, <b>slot-definition</b>, <b>generic-function</b>, <b>method</b>
and <b>method-combination</b>. A <em>metaobject class</em> is a subclass of exactly one of
these classes. The results are undefined if an attempt is made to define a class that is a
subclass of more than one basic metaobject class. A <em>metaobject</em> is an instance of
a metaobject class. </p>

<p>Each metaobject represents one program element. Associated with each metaobject is the
information required to serve its role. This includes information that might be provided
directly in a user interface macro such as <b>defclass</b> or <b>defmethod</b>. It also
includes information computed indirectly from other metaobjects such as that computed from
class inheritance or the full set of methods associated with a generic function. </p>

<p>Much of the information associated with a metaobject is in the form of connections to
other metaobjects. This interconnection means that the role of a metaobject is always
based on that of other metaobjects. As an introduction to this interconnected structure,
this section presents a partial enumeration of the kinds of information associated with
each kind of metaobject. More detailed information is presented later. </p>

<h3><a name="classes">Classes</a></h3>

<p>A <em>class metaobject</em> determines the structure and the default behavior of its
instances. The following information is associated with class metaobjects: 

<ul>
  <li>The name, if there is one, is available as an object. </li>
  <li>The direct subclasses, direct superclasses and class precedence list are available as
    lists of class metaobjects. </li>
  <li>The slots defined directly in the class are available as a list of direct slot
    definition metaobjects. The slots which are accessible in instances of the class are
    available as a list of effective slot definition metaobjects. </li>
  <li>The documentation is available as a string or <b>nil</b>. </li>
  <li>The methods which use the class as a specializer, and the generic functions associated
    with those methods are available as lists of method and generic function metaobjects
    respectively. </li>
</ul>

<h3><a name="slot-definitions">Slot Definitions</a></h3>

<p>A <em>slot definition metaobject</em> contains information about the definition of a
slot. There are two kinds of slot definition metaobjects. A direct slot definition
metaobject is used to represent the direct definition of a slot in a class. This
corresponds roughly to the slot specifiers found in <b>defclass</b> forms. An effective
slot definition metaobject is used to represent information, including inherited
information, about a slot which is accessible in instances of a particular class. </p>

<p>Associated with each class metaobject is a list of direct slot definition metaobjects
representing the slots defined directly in the class. Also associated with each class
metaobject is a list of effective slot definition metaobjects representing the set of
slots accessible in instances of that class. </p>

<p>The following information is associated with both direct and effective slot definitions
metaobjects: 

<ul>
  <li>The name, allocation, and type are available as forms that could appear in a <b>defclass</b>
    form. </li>
  <li>The initialization form, if there is one, is available as a form that could appear in a <b>defclass</b>
    form. The initialization form together with its lexical environment is available as a
    function of no arguments which, when called, returns the result of evaluating the
    initialization form in its lexical environment. This is called the <em>initfunction</em>
    of the slot. </li>
  <li>The slot filling initialization arguments are available as a list of symbols. </li>
  <li>The documentation is available as a string or <b>nil</b>. </li>
</ul>

<p>Certain other information is only associated with direct slot definition metaobjects.
This information applies only to the direct definition of the slot in the class (it is not
inherited). 

<ul>
  <li>The function names of those generic functions for which there are automatically
    generated reader and writer methods. This information is available as lists of function
    names. Any accessors specified in the <b>defclass</b> form are broken down into their
    equivalent readers and writers in the direct slot definition. </li>
</ul>

<p>Information, including inherited information, which applies to the definition of a slot
in a particular class in which it is accessible is associated only with effective slot
definition metaobjects. 

<ul>
  <li>For certain slots, the location of the slot in instances of the class is available. </li>
</ul>

<h3><a name="generic-functions">Generic Functions</a></h3>

<p>A <em>generic function metaobject</em> contains information about a generic function
over and above the information associated with each of the generic function's methods. 

<ul>
  <li>The name is available as a function name. </li>
  <li>The methods associated with the generic function are available as a list of method
    metaobjects. </li>
  <li>The default class for this generic function's method metaobjects is available as a class
    metaobject. </li>
  <li>The lambda list is available as a list. </li>
  <li>The method combination is available as a method combination metaobject. </li>
  <li>The documentation is available as a string or <b>nil</b>. </li>
  <li>The argument precedence order is available as a permutation of those symbols from the
    lambda list which name the required arguments of the generic function. </li>
  <li>The declarations are available as a list of declarations. <blockquote>
      <b><p>Terminology Note:</b> There is some ambiguity in Common Lisp about the terms used to
      identify the various parts of <b>declare</b> special forms. In this document, the term <em>declaration</em>
      is used to refer to an object that could be an argument to a <b>declare</b> special form.
      For example, in the special form <b>(declare (special *g1*))</b>, the list <b>(special
      *g1*)</b> is a declaration. </p>
    </blockquote>
  </li>
</ul>

<h3><a name="methods">Methods</a></h3>

<p>A <em>method metaobject</em> contains information about a specific method. 

<ul>
  <li>The qualifiers are available as a list of of non-null atoms. </li>
  <li>The lambda list is available as a list. </li>
  <li>The specializers are available as a list of specializer metaobjects. </li>
  <li>The function is available as a function. This function can be applied to arguments and a
    list of next methods using <b>apply</b> or <b>funcall</b>. </li>
  <li>When the method is associated with a generic function, that generic function metaobject
    is available. A method can be associated with at most one generic function at a time. </li>
  <li>The documentation is available as a string or <b>nil</b>. </li>
</ul>

<h3><a name="specializers">Specializers</a></h3>

<p>A specializer metaobject represents the specializers of a method. Class metaobjects are
themselves specializer metaobjects. A special kind of specializer metaobject is used for <b>eql</b>
specializers. </p>

<h3><a name="method-combination">Method Combinations</a></h3>

<p>A <em>method combination metaobject</em> represents the information about the method
combination being used by a generic function. </p>

<blockquote>
  <b><p>Note:</b> This document does not specify the structure of method combination
  metaobjects. </p>
</blockquote>

<h2><a name="inheritance">Inheritance Structure of Metaobject Classes</a></h2>

<p>The inheritance structure of the specified metaobject classes is shown in the <a
href="#inherit-struct-figure">Table: MOP CLASSES</a>. </p>

<table border="yes">
  <caption><a name="inherit-struct-figure"><b>Table: MOP CLASES</b></a> Direct superclass
  relationships among the specified metaobject classes.<br>
  The class of every class shown is <b>standard-class</b> except for the class <b>t</b>
  which is an instance of the class <b>built-in-class</b> and the classes <b>generic-function</b>
  and <b>standard-generic-function</b> which are instances of the class <b>funcallable-standard-class</b>.
  </caption>
  <tr>
    <th></th>
    <th>Metaobject Class</th>
    <th>Direct Superclasses</th>
  </tr>
  <tr>
    <td></td>
    <td>standard-object</td>
    <td>(t)</td>
  </tr>
  <tr>
    <td></td>
    <td><a name="funcallable-standard-object">funcallable-standard-object</a> </td>
    <td>(standard-object function)</td>
  </tr>
  <tr>
    <td>*</td>
    <td><a name="metaobject">metaobject</a> </td>
    <td>(standard-object)</td>
  </tr>
  <tr>
    <td>*</td>
    <td>generic-function </td>
    <td>(metaobject funcallable-standard-object)</td>
  </tr>
  <tr>
    <td></td>
    <td>standard-generic-function </td>
    <td>(generic-function)</td>
  </tr>
  <tr>
    <td>*</td>
    <td>method </td>
    <td>(metaobject)</td>
  </tr>
  <tr>
    <td></td>
    <td>standard-method </td>
    <td>(method)</td>
  </tr>
  <tr>
    <td>*</td>
    <td><a name="standard-accessor-method">standard-accessor-method</a> </td>
    <td>(standard-method)</td>
  </tr>
  <tr>
    <td></td>
    <td><a name="standard-reader-method">standard-reader-method</a> </td>
    <td>(standard-accessor-method)</td>
  </tr>
  <tr>
    <td></td>
    <td><a name="standard-writer-method">standard-writer-method</a> </td>
    <td>(standard-accessor-method)</td>
  </tr>
  <tr>
    <td>*</td>
    <td>method-combination </td>
    <td>(metaobject)</td>
  </tr>
  <tr>
    <td>*</td>
    <td><a name="slot-definition">slot-definition</a> </td>
    <td>(metaobject)</td>
  </tr>
  <tr>
    <td>*</td>
    <td><a name="direct-slot-definition">direct-slot-definition</a> </td>
    <td>(slot-definition)</td>
  </tr>
  <tr>
    <td>*</td>
    <td><a name="effective-slot-definition">effective-slot-definition</a> </td>
    <td>(slot-definition)</td>
  </tr>
  <tr>
    <td>*</td>
    <td><a name="standard-slot-definition">standard-slot-definition</a> </td>
    <td>(slot-definition)</td>
  </tr>
  <tr>
    <td></td>
    <td><a name="standard-direct-slot-definition">standard-direct-slot-definition</a> </td>
    <td>(standard-slot-definition direct-slot-definition)</td>
  </tr>
  <tr>
    <td></td>
    <td><a name="standard-effective-slot-definition">standard-effective-slot-definition</a> </td>
    <td>(standard-slot-definition effective-slot-definition)</td>
  </tr>
  <tr>
    <td>*</td>
    <td><a name="specializer">specializer</a> </td>
    <td>(metaobject)</td>
  </tr>
  <tr>
    <td></td>
    <td><a name="eql-specializer">eql-specializer</a> </td>
    <td>(specializer)</td>
  </tr>
  <tr>
    <td>*</td>
    <td>class </td>
    <td>(specializer)</td>
  </tr>
  <tr>
    <td></td>
    <td>built-in-class </td>
    <td>(class)</td>
  </tr>
  <tr>
    <td></td>
    <td><a name="forward-referenced-class">forward-referenced-class</a> </td>
    <td>(class)</td>
  </tr>
  <tr>
    <td></td>
    <td>standard-class </td>
    <td>(class)</td>
  </tr>
  <tr>
    <td></td>
    <td><a name="funcallable-standard-class">funcallable-standard-class</a> </td>
    <td>(class)</td>
  </tr>
</table>

<p>Each class marked with a ``*'' is an <em>abstract class</em> and is not intended to be
instantiated. The results are undefined if an attempt is made to make an instance of one
of these classes with <a href="dictionary.html#make-instance"><b>make-instance</b></a>. </p>

<p>The classes <b>standard-class</b>, <b>standard-direct-slot-definition</b>, <b>standard-effective-slot-definition</b>,
<b>standard-method</b>, <b>standard-reader-method</b>, <b>standard-writer-method</b> and <b>standard-generic-function</b>
are called <em>standard metaobject classes</em>. For each kind of metaobject, this is the
class the user interface macros presented in the CLOS Specification use by default. These
are also the classes on which user specializations are normally based. </p>

<p>The classes <b>built-in-class</b>, <b>funcallable-standard-class</b> and <b>forward-referenced-class</b>
are special-purpose class metaobject classes. Built-in classes are instances of the class <b>built-in-class</b>.
The class <b>funcallable-standard-class</b> provides a special kind of instances described
in the section called <a href="#funcallable-instances">``Funcallable Instances.''</a> When
the definition of a class references another class which has not yet been defined, an
instance of <b>forward-referenced-class</b> is used as a stand-in until the class is
actually defined. </p>

<p>The class <b>standard-object</b> is the <em>default direct superclass</em> of the class
<b>standard-class</b>. When an instance of the class <b>standard-class</b> is created, and
no direct superclasses are explicitly specified, it defaults to the class <b>standard-object</b>.
In this way, any behavior associated with the class <b>standard-object</b> will be
inherited, directly or indirectly, by all instances of the class <b>standard-class</b>. A
subclass of <b>standard-class</b> may have a different class as its default direct
superclass, but that class must be a subclass of the class <b>standard-object</b>. </p>

<p>The same is true for <b>funcallable-standard-class</b> and <b>funcallable-standard-object</b>.
</p>

<p>The class <b>specializer</b> captures only the most basic behavior of method
specializers, and is not itself intended to be instantiated. The class <b>class</b> is a
direct subclass of <b>specializer</b> reflecting the property that classes by themselves
can be used as method specializers. The class <b>eql-specializer</b> is used for <b>eql</b>
specializers. </p>

<h3><a name="implementation-and-users">Implementation and User Specialization</a></h3>

<p>The purpose of the Metaobject Protocol is to provide users with a powerful mechanism
for extending and customizing the basic behavior of the Common Lisp Object System. As an
object-oriented description of the basic CLOS behavior, the Metaobject Protocol makes it
possible to create these extensions by defining specialized subclasses of existing
metaobject classes. </p>

<p>The Metaobject Protocol provides this capability without interfering with the
implementor's ability to develop high-performance implementations. This balance between
user extensibility and implementor freedom is mediated by placing explicit restrictions on
each. Some of these restrictions are general---they apply to the entire class graph and
the applicability of all methods. These are presented in this section. </p>

<p>The following additional terminology is used to present these restrictions:<a
name="specialization-terminology"></a> 

<ul>
  <li>Metaobjects are divided into three categories. Those defined in this document are called
    <em>specified</em>; those defined by an implementation but not mentioned in this document
    are called <em>implementation-specific</em>; and those defined by a portable program are
    called <em>portable</em>. </li>
  <li>A class I is <em>interposed</em> between two other classes C<i>1</i> and C<i>2</i> if
    and only if there is some path, following direct superclasses, from the class C<i>1</i> to
    the class C<i>2</i> which includes I. </li>
  <li>A method is <em>specialized to</em> a class if and only if that class is in the list of
    specializers associated with the method; and the method is in the list of methods
    associated with some generic function. </li>
  <li>In a given implementation, a specified method is said to have been <em>promoted</em> if
    and only if the specializers of the method, S<i>1</i> ... S<i>n</i>, are defined in this
    specification as the classes C<i>1</i> ... C<i>n</i>, but in the implementation, one or
    more of the specializers S<i>i</i>, is a superclass of the class given in the
    specification C<i>i</i>. </li>
  <li>For a given generic function and set of arguments, a method M<i>2</i> <em>extends</em> a
    method M<i>1</i> if and only if: <dl>
      <dd>(i) M<i>1</i> and M<i>2</i> are both associated with the given generic function, </dd>
      <dd>(ii) M<i>1</i> and M<i>2</i> are both applicable to the given arguments, </dd>
      <dd>(iii) the specializers and qualifiers of the methods are such that when the generic
        function is called, M<i>2</i> is executed before M<i>1</i>, </dd>
      <dd>(iv) M<i>1</i> will be executed if and only if <b>call-next-method</b> is invoked from
        within the body of M<i>2</i> and </dd>
      <dd>(v)<b>call-next-method</b> is invoked from within the body of M<i>2</i>, thereby causing
        M<i>1</i> to be executed. </dd>
    </dl>
  </li>
  <li>For a given generic function and set of arguments, a method M<i>2</i> <em>overrides</em>
    a method M<i>1</i> if and only if conditions i through iv above hold and <dl>
      <dd>(v<i>'</i>) <b>call-next-method</b> is not invoked from within the body of M<i>2</i>,
        thereby preventing M<i>1</i> from being executed. </dd>
    </dl>
  </li>
</ul>

<h4><a name="implementation">Restrictions on Implementations</a></h4>

<p>Implementations are allowed latitude to modify the structure of specified classes and
methods. This includes: the interposition of implementation-specific classes; the
promotion of specified methods; and the consolidation of two or more specified methods
into a single method specialized to interposed classes. </p>

<p>Any such modifications are permitted only so long as for any portable class C<i>p</i>
that is a subclass of one or more specified classes C<i>0</i> ... C<i>i</i>, the following
conditions are met: 

<ul>
  <li>In the actual class precedence list of C<i>p</i>, the classes C<i>0</i> ... C<i>i</i>
    must appear in the same order as they would have if no implementation-specific
    modifications had been made. </li>
  <li>The method applicability of any specified generic function must be the same in terms of
    behavior as it would have been had no implementation-specific changes been made. This
    includes specified generic functions that have had portable methods added. In this
    context, the expression ``the same in terms of behavior'' means that methods with the same
    behavior as those specified are applicable, and in the same order. </li>
  <li>No portable class C<i>p</i> may inherit, by virtue of being a direct or indirect
    subclass of a specified class, any slot for which the name is a symbol accessible in the <b>common-lisp-user</b>
    package or exported by any package defined in the ANSI Common Lisp standard. </li>
  <li>Implementations are free to define implementation-specific before- and after-methods on
    specified generic functions. Implementations are also free to define
    implementation-specific around-methods with extending behavior. </li>
</ul>

<h4><a name="portable">Restrictions on Portable Programs</a></h4>

<p>Portable programs are allowed to define subclasses of specified classes, and are
permitted to define methods on specified generic functions, with the following
restrictions. The results are undefined if any of these restrictions is violated. 

<ul>
  <li>Portable programs must not redefine any specified classes, generic functions, methods or
    method combinations. Any method defined by a portable program on a specified generic
    function must have at least one specializer that is neither a specified class nor an <b>eql</b>
    specializer whose associated value is an instance of a specified class. </li>
  <li>Portable programs may define methods that extend specified methods unless the
    description of the specified method explicitly prohibits this. Unless there is a specific
    statement to the contrary, these extending methods must return whatever value was returned
    by the call to <b>call-next-method</b>. </li>
  <li>Portable programs may define methods that override specified methods only when the
    description of the specified method explicitly allows this. Typically, when a method is
    allowed to be overridden, a small number of related methods will need to be overridden as
    well. <p>An example of this is the specified methods on the generic functions <a
    href="dictionary.html#add-dependent"><b>add-dependent</b></a>, <a
    href="dictionary.html#remove-dependent"><b>remove-dependent</b></a> and <a
    href="dictionary.html#map-dependents"><b>map-dependents</b></a>. Overriding a specified
    method on one of these generic functions requires that the corresponding method on the
    other two generic functions be overridden as well. </p>
  </li>
  <li>Portable methods on specified generic functions specialized to portable metaobject
    classes must be defined before any instances of those classes (or any subclasses) are
    created, either directly or indirectly by a call to <a
    href="dictionary.html#make-instance"><b>make-instance</b></a>. Methods can be defined
    after instances are created by <a href="dictionary.html#allocate-instance"><b>allocate-instance</b></a>
    however. Portable metaobject classes cannot be redefined. <blockquote>
      <b><p>Implementation Note:</b> The purpose of this last restriction is to permit
      implementations to provide performance optimizations by analyzing, at the time the first
      instance of a metaobject class is initialized, what portable methods will be applicable to
      it. This can make it possible to optimize calls to those specified generic functions which
      would have no applicable portable methods. </p>
    </blockquote>
    <blockquote>
      <b><p>Note:</b> The specification technology used in this document needs further
      development. The concepts of object-oriented protocols and subclass specialization are
      intuitively familiar to programmers of object-oriented systems; the protocols presented
      here fit quite naturally into this framework. Nonetheless, in preparing this document, we
      have found it difficult to give specification-quality descriptions of the protocols in a
      way that makes it clear what extensions users can and cannot write. Object-oriented
      protocol specification is inherently about specifying leeway, and this seems difficult
      using current technology. </p>
    </blockquote>
  </li>
</ul>

<h2><a name="processing">Processing of the User Interface Macros</a></h2>

<p>A list in which the first element is one of the symbols <b>defclass</b>, <b>defmethod</b>,
<b>defgeneric</b>, or <b>define-method-combination</b>, <!-- removed from ANSI
<b>generic-function</b>, <b>generic-flet</b> or <b>generic-labels</b>, --> and which has proper syntax for
that macro is called a <em>user interface macro form</em>. This document provides an
extended specification of the <b>defclass</b>, <b>defmethod</b> and <b>defgeneric</b>
macros. </p>

<p>The user interface macros <b>defclass</b>, <b>defgeneric</b> and <b>defmethod</b> can
be used not only to define metaobjects that are instances of the corresponding standard
metaobject class, but also to define metaobjects that are instances of appropriate
portable metaobject classes. To make it possible for portable metaobject classes to
properly process the information appearing in the macro form, this document provides a
limited specification of the processing of these macro forms. </p>

<p>User interface macro forms can be <em>evaluated</em> or <em>compiled</em> and later <em>executed</em>.
The effect of evaluating or executing a user interface macro form is specified in terms of
calls to specified functions and generic functions which provide the actual behavior of
the macro. The arguments received by these functions and generic functions are derived in
a specified way from the macro form. </p>

<p>Converting a user interface macro form into the arguments to the appropriate functions
and generic functions has two major aspects: the conversion of the macro argument syntax
into a form more suitable for later processing, and the processing of macro arguments
which are forms to be evaluated (including method bodies). </p>

<p>In the syntax of the <b>defclass</b> macro, the <i>initform</i> and <i>default-initarg-initial-value-form</i>
arguments are forms which will be evaluated one or more times after the macro form is
evaluated or executed. Special processing must be done on these arguments to ensure that
the lexical scope of the forms is captured properly. This is done by building a function
of zero arguments which, when called, returns the result of evaluating the form in the
proper lexical environment. </p>

<p>In the syntax of the <b>defmethod</b> macro the <i>form*</i> argument is a list of
forms that comprise the body of the method definition. This list of forms must be
processed specially to capture the lexical scope of the macro form. In addition, the
lexical functions available only in the body of methods must be introduced. To allow this
and any other special processing (such as slot access optimization), a specializable
protocol is used for processing the body of methods. This is discussed in the section <a
href="#processing-method-bodies">``Processing Method Bodies.''</a> </p>

<h3><a name="compile-file">Compile-file Processing of the User Interface Macros</a></h3>

<p>It is common practice for Common Lisp compilers, while processing a file or set of
files, to maintain information about the definitions that have been compiled so far. Among
other things, this makes it possible to ensure that a global macro definition (<b>defmacro</b>
form) which appears in a file will affect uses of the macro later in that file. This
information about the state of the compilation is called the <em>compile-file environment</em>.
</p>

<p>When compiling files containing CLOS definitions, it is useful to maintain certain
additional information in the compile-file environment. This can make it possible to issue
various kinds of warnings (e.g., lambda list congruence) and to do various performance
optimizations that would not otherwise be possible. </p>

<p>At this time, there is such significant variance in the way existing Common Lisp
implementations handle compile-file environments that it would be premature to specify
this mechanism. Consequently, this document specifies only the behavior of evaluating or
executing user interface macro forms. What functions and generic functions are called
during compile-file processing of a user interface macro form is not specified.
Implementations are free to define and document their own behavior. Users may need to
check implementation-specific behavior before attempting to compile certain portable
programs. </p>

<h3><a name="defclass">The defclass Macro</a></h3>

<table border="yes">
  <caption><a name="defclass1"><b>Figure 1:</b></a> A <b>defclass</b> form with standard
  slot and class options and an expansion of it that would result in the proper call to <a
  href="dictionary.html#ensure-class"><b>ensure-class</b></a>. </caption>
  <tr>
    <td><pre>
(defclass plane (moving-object graphics-object)
     ((altitude :initform 0 :accessor plane-altitude)
      (speed))
  (:default-initargs :engine *jet*))

</pre>
    <p>(ensure-class 'plane ':direct-superclasses '(moving-object graphics-object)
    ':direct-slots (list (list ':name 'altitude ':initform '0 ':initfunction #'(lambda () 0)
    ':readers '(plane-altitude) ':writers '((setf plane-altitude))) (list ':name 'speed))
    ':direct-default-initargs (list (list ':engine '*jet* #'(lambda () *jet*)))) </td>
  </tr>
</table>

<table border="yes">
  <caption><a name="defclass2"><b>Figure 2:</b> A <b>defclass</b> form with non-standard
  class and slot options, and an expansion of it which results in the proper call to </a><a
  href="dictionary.html#ensure-class"><b>ensure-class</b></a>. <br>
  Note that the order of the slot options has not affected the order of the properties in
  the canonicalized slot specification, but has affected the order of the elements in the
  lists which are the values of those properties. </caption>
  <tr>
    <td><pre>
(defclass sst (plane)
     ((mach mag-step 2
            locator sst-mach
            locator mach-location
            :reader mach-speed
            :reader mach))
  (:metaclass faster-class)
  (another-option foo bar))

</pre>
    <p>(ensure-class 'sst ':direct-superclasses '(plane) ':direct-slots (list (list ':name
    'mach ':readers '(mach-speed mach) 'mag-step '2 'locator '(sst-mach mach-location)))
    ':metaclass 'faster-class 'another-option '(foo bar)) </td>
  </tr>
</table>

<p>The evaluation or execution of a <b>defclass</b> form results in a call to the <a
href="dictionary.html#ensure-class"><b>ensure-class</b></a> function. The arguments
received by <a href="dictionary.html#ensure-class"><b>ensure-class</b></a> are derived
from the <b>defclass</b> form in a defined way. The exact macro-expansion of the <b>defclass</b>
form is not defined, only the relationship between the arguments to the <b>defclass</b>
macro and the arguments received by the <a href="dictionary.html#ensure-class"><b>ensure-class</b></a>
function. Examples of typical <b>defclass</b> forms and sample expansions are shown in <a
href="#defclass1">Figure 1</a> and <a href="#defclass2">Figure 2</a>. 

<ul>
  <li>The <i>name</i> argument to <b>defclass</b> becomes the value of the first argument to <a
    href="dictionary.html#ensure-class"><b>ensure-class</b></a>. This is the only positional
    argument accepted by <a href="dictionary.html#ensure-class"><b>ensure-class</b></a>; all
    other arguments are keyword arguments. </li>
  <li>The <i>direct-superclasses</i> argument to <b>defclass</b> becomes the value of the <b>:direct-superclasses</b>
    keyword argument to <a href="dictionary.html#ensure-class"><b>ensure-class</b></a>. </li>
  <li>The <i>direct slots</i> argument to <b>defclass</b> becomes the value of the <b>:direct-slots</b>
    keyword argument to <a href="dictionary.html#ensure-class"><b>ensure-class</b></a>.
    Special processing of this value is done to regularize the form of each slot specification
    and to properly capture the lexical scope of the initialization forms. This is done by
    converting each slot specification to a property list called a <em>canonicalized slot
    specification</em>. The resulting list of canonicalized slot specifications is the value
    of the <b>:direct-slots</b> keyword argument. <p>Canonicalized slot specifications are
    later used as the keyword arguments to a generic function which will, in turn, pass them
    to <a href="dictionary.html#make-instance"><b>make-instance</b></a> for use as a set of
    initialization arguments. Each canonicalized slot specification is formed from the
    corresponding slot specification as follows: <ul>
      <li>The name of the slot is the value of the <b>:name</b> property. This property appears in
        every canonicalized slot specification. </li>
      <li>When the <b>:initform</b> slot option is present in the slot specification, then both
        the <b>:initform</b> and <b>:initfunction</b> properties are present in the canonicalized
        slot specification. The value of the <b>:initform</b> property is the initialization form.
        The value of the <b>:initfunction</b> property is a function of zero arguments which, when
        called, returns the result of evaluating the initialization form in its proper lexical
        environment. <p>If the <b>:initform</b> slot option is not present in the slot
        specification, then either the <b>:initfunction</b> property will not appear, or its value
        will be false. In such cases, the value of the <b>:initform</b> property, or whether it
        appears, is unspecified. </p>
      </li>
      <li>The value of the <b>:initargs</b> property is a list of the values of each <b>:initarg</b>
        slot option. If there are no <b>:initarg</b> slot options, then either the <b>:initargs</b>
        property will not appear or its value will be the empty list. </li>
      <li>The value of the <b>:readers</b> property is a list of the values of each <b>:reader</b>
        and <b>:accessor</b> slot option. If there are no <b>:reader</b> or <b>:accessor</b> slot
        options, then either the <b>:readers</b> property will not appear or its value will be the
        empty list. </li>
      <li>The value of the <b>:writers</b> property is a list of the values specified by each <b>:writer</b>
        and <b>:accessor</b> slot option. The value specified by a <b>:writer</b> slot option is
        just the value of the slot option. The value specified by an <b>:accessor</b> slot option
        is a two element list: the first element is the symbol <b>setf</b>, the second element is
        the value of the slot option. If there are no <b>:writer</b> or <b>:accessor</b> slot
        options, then either the <b>:writers</b> property will not appear or its value will be the
        empty list. </li>
      <li>The value of the <b>:documentation</b> property is the value of the <b>:documentation</b>
        slot option. If there is no <b>:documentation</b> slot option, then either the <b>:documentation</b>
        property will not appear or its value will be false. </li>
      <li>All other slot options appear as the values of properties with the same name as the slot
        option. Note that this includes not only the remaining standard slot options (<b>:allocation</b>
        and <b>:type</b>), but also any other options and values appearing in the slot
        specification. If one of these slot options appears more than once, the value of the
        property will be a list of the specified values. </li>
      <li>An implementation is free to add additional properties to the canonicalized slot
        specification provided these are not symbols accessible in the <b>common-lisp-user</b>
        package, or exported by any package defined in the ANSI Common Lisp standard. </li>
    </ul>
    <p>Returning to the correspondence between arguments to the <b>defclass</b> macro and the
    arguments received by the <a href="dictionary.html#ensure-class"><b>ensure-class</b></a>
    function: </p>
  </li>
  <li>The <i>default initargs</i> class option, if it is present in the <b>defclass</b> form,
    becomes the value of the <b>:direct-default-initargs</b> keyword argument to <a
    href="dictionary.html#ensure-class"><b>ensure-class</b></a>. Special processing of this
    value is done to properly capture the lexical scope of the default value forms. This is
    done by converting each default initarg in the class option into a <em>canonicalized
    default initarg</em>. The resulting list of canonicalized default initargs is the value of
    the <b>:direct-default-initargs</b> keyword argument to <a
    href="dictionary.html#ensure-class"><b>ensure-class</b></a>. <p>A canonicalized default
    initarg is a list of three elements. The first element is the name; the second is the
    actual form itself; and the third is a function of zero arguments which, when called,
    returns the result of evaluating the default value form in its proper lexical environment.
    </p>
  </li>
  <li>The <i>metaclass</i> class option, if it is present in the <b>defclass</b> form, becomes
    the value of the <b>:metaclass</b> keyword argument to <a
    href="dictionary.html#ensure-class"><b>ensure-class</b></a>. </li>
  <li>The <i>documentation</i> class option, if it is present in the <b>defclass</b> form,
    becomes the value of the <b>:documentation</b> keyword argument to <a
    href="dictionary.html#ensure-class"><b>ensure-class</b></a>. </li>
  <li>Any other class options become the value of keyword arguments with the same name. The
    value of the keyword argument is the tail of the class option. An error is signaled if any
    class option appears more than once in the <b>defclass</b> form. </li>
</ul>

<p>In the call to <a href="dictionary.html#ensure-class"><b>ensure-class</b></a>, every
element of its arguments appears in the same left-to-right order as the corresponding
element of the <b>defclass</b> form, except that the order of the properties of
canonicalized slot specifications is unspecified. The values of properties in
canonicalized slot specifications do follow this ordering requirement. Other ordering
relationships in the keyword arguments to <a href="dictionary.html#ensure-class"><b>ensure-class</b></a>
are unspecified. </p>

<p>The result of the call to <a href="dictionary.html#ensure-class"><b>ensure-class</b></a>
is returned as the result of evaluating or executing the <b>defclass</b> form. </p>

<h3><a name="defmethod">The defmethod Macro</a></h3>

<p>The evaluation or execution of a <b>defmethod</b> form requires first that the body of
the method be converted to a method function. This process is described in the <a
href="#processing-method-bodies">next section</a>. The result of this process is a method
function and a set of additional initialization arguments to be used when creating the new
method. Given these two values, the evaluation or execution of a <b>defmethod</b> form
proceeds in three steps. </p>

<p>The first step ensures the existence of a generic function with the specified name.
This is done by calling the function <a href="dictionary.html#ensure-generic-function"><b>ensure-generic-function</b></a>.
The first argument in this call is the generic function name specified in the <b>defmethod</b>
form. </p>

<p>The second step is the creation of the new method metaobject by calling <a
href="dictionary.html#make-instance"><b>make-instance</b></a>. The class of the new method
metaobject is determined by calling <a
href="dictionary.html#generic-function-method-class"><b>generic-function-method-class</b></a>
on the result of the call to <a href="dictionary.html#ensure-generic-function"><b>ensure-generic-function</b></a>
from the first step. </p>

<p>The initialization arguments received by the call to <a
href="dictionary.html#make-instance"><b>make-instance</b></a> are as follows: 

<ul>
  <li>The value of the <b>:qualifiers</b> initialization argument is a list of the qualifiers
    which appeared in the <b>defmethod</b> form. No special processing is done on these
    values. The order of the elements of this list is the same as in the <b>defmethod</b>
    form. </li>
  <li>The value of the <b>:lambda-list</b> initialization argument is the unspecialized lambda
    list from the <b>defmethod</b> form. </li>
  <li>The value of the <b>:specializers</b> initialization argument is a list of the
    specializers for the method. For specializers which are classes, the specializer is the
    class metaobject itself. In the case of <b>eql</b> specializers, it will be an <b>eql-specializer</b>
    metaobject obtained by calling <b>intern-eql-specializer</b> on the result of evaluating
    the <b>eql</b> specializer form in the lexical environment of the <b>defmethod</b> form. </li>
  <li>The value of the <b>:function</b> initialization argument is the method function. </li>
  <li>The value of the <b>:declarations</b> initialization argument is a list of the
    declarations from the <b>defmethod</b> form. If there are no declarations in the macro
    form, this initialization argument either doesn't appear, or appears with a value of the
    empty list. </li>
  <li>The value of the <b>:documentation</b> initialization argument is the documentation
    string from the <b>defmethod</b> form. If there is no documentation string in the macro
    form this initialization argument either doesn't appear, or appears with a value of false.
  </li>
  <li>Any other initialization argument produced in conjunction with the method function are
    also included. </li>
  <li>The implementation is free to include additional initialization arguments provided these
    are not symbols accessible in the <b>common-lisp-user</b> package, or exported by any
    package defined in the ANSI Common Lisp standard. </li>
</ul>

<p>In the third step, <a href="dictionary.html#add-method"><b>add-method</b></a> is called
to add the newly created method to the set of methods associated with the generic function
metaobject. </p>

<p>The result of the call to <a href="dictionary.html#add-method"><b>add-method</b></a> is
returned as the result of evaluating or executing the <b>defmethod</b> form. </p>

<table border="yes">
  <caption><a name="defmethod1"><b>Figure 3:</b></a> An example <b>defmethod</b> form and
  one possible correct expansion. <br>
  In the expansion, <em>method-lambda</em> is the result of calling <a
  href="dictionary.html#make-method-lambda"><b>make-method-lambda</b></a> as described in
  the section <a href="#processing-method-bodies">``Processing Method Bodies''.</a> The
  initargs appearing after <b>:function</b> are assumed to be additional initargs returned
  from the call to <a href="dictionary.html#make-method-lambda"><b>make-method-lambda</b></a>.
  </caption>
  <tr>
    <td><pre>
(defmethod move :before ((p position) (l (eql 0))
                         &amp;optional (visiblyp t)
                         &amp;key color)
  (set-to-origin p)
  (when visiblyp (show-move p 0 color)))

</pre>
    <p>(let ((#:g001 (ensure-generic-function 'move))) (add-method #:g001 (make-instance
    (generic-function-method-class #:g001) ':qualifiers '(:before) ':specializers (list
    (find-class 'position) (intern-eql-specializer 0)) ':lambda-list '(p l &amp;optional
    (visiblyp t) &amp;key color) ':function (function <i>method-lambda</i>)
    'additional-initarg-1 't 'additional-initarg-2 '39))) </td>
  </tr>
</table>

<p>An example showing a typical <b>defmethod</b> form and a sample expansion is shown in <a
href="#defmethod1">Figure 3</a>. The processing of the method body for this method is
shown in <a href="#defmethod2">Figure 4</a>. </p>

<h3><a name="processing-method-bodies">Processing Method Bodies</a></h3>

<p>Before a method can be created, the list of forms comprising the method body must be
converted to a method function. This conversion is a two step process. </p>

<blockquote>
  <b><p>Note:</b> The body of methods can also appear in the <b>:initial-methods</b> option
  of <b>defgeneric</b> forms. Initial methods are not considered by any of the protocols
  specified in this document. </p>
</blockquote>

<table border="yes">
  <caption><a name="defmethod2"><b>Figure 4:</b></a> During macro-expansion of the <b>defmethod</b>
  macro shown in <a href="#defmethod1">Figure 3</a>, code similar to this would be run to
  produce the method lambda and additional initargs. <br>
  In this example, <em>environment</em> is the macroexpansion environment of the <b>defmethod</b>
  macro form. </caption>
  <tr>
    <td><pre>
(let ((gf (ensure-generic-function 'move)))
  (make-method-lambda
    gf
    (class-prototype (generic-function-method-class gf))
    '(lambda (p l &amp;optional (visiblyp t) &amp;key color)
       (set-to-origin p)
       (when visiblyp (show-move p 0 color)))
   <i>environment</i>))
</pre>
    </td>
  </tr>
</table>

<p>The first step occurs during macro-expansion of the macro form. In this step, the
method lambda list, declarations and body are converted to a lambda expression called a <em>method
lambda</em>. This conversion is based on information associated with the generic function
definition in effect at the time the macro form is expanded. </p>

<p>The generic function definition is obtained by calling <a
href="dictionary.html#ensure-generic-function"><b>ensure-generic-function</b></a> with a
first argument of the generic function name specified in the macro form. The <b>:lambda-list</b>
keyword argument is not passed in this call. </p>

<p>Given the generic function, production of the method lambda proceeds by calling <a
href="dictionary.html#make-method-lambda"><b>make-method-lambda</b></a>. The first
argument in this call is the generic function obtained as described above. The second
argument is the result of calling <b>class-prototype</b> on the result of calling <a
href="dictionary.html#generic-function-method-class"><b>generic-function-method-class</b></a>
on the generic function. The third argument is a lambda expression formed from the method
lambda list, declarations and body. The fourth argument is the macro-expansion environment
of the macro form; this is the value of the <b>&amp;environment</b> argument to the <b>defmethod</b>
macro. </p>

<p>The generic function <a href="dictionary.html#make-method-lambda"><b>make-method-lambda</b></a>
returns two values. The first is the method lambda itself. The second is a list of
initialization arguments and values. These are included in the initialization arguments
when the method is created. </p>

<p>In the second step, the method lambda is converted to a function which properly
captures the lexical scope of the macro form. This is done by having the method lambda
appear in the macro-expansion as the argument of the <b>function</b> special form. During
the subsequent evaluation of the macro-expansion, the result of the <b>function</b>
special form is the method function. </p>

<h3><a name="defgeneric">The defgeneric Macro</a></h3>

<p>The evaluation or execution of a <b>defgeneric</b> form results in a call to the <a
href="dictionary.html#ensure-generic-function"><b>ensure-generic-function</b></a>
function. The arguments received by <a href="dictionary.html#ensure-generic-function"><b>ensure-generic-function</b></a>
are derived from the <b>defgeneric</b> form in a defined way. As with <b>defclass</b> and <b>defmethod</b>,
the exact macro-expansion of the <b>defgeneric</b> form is not defined, only the
relationship between the arguments to the macro and the arguments received by <a
href="dictionary.html#ensure-generic-function"><b>ensure-generic-function</b></a>. 

<ul>
  <li>The <i>function-name</i> argument to <b>defgeneric</b> becomes the first argument to <a
    href="dictionary.html#ensure-generic-function"><b>ensure-generic-function</b></a>. This is
    the only positional argument accepted by <a href="dictionary.html#ensure-generic-function"><b>ensure-generic-function</b></a>;
    all other arguments are keyword arguments. </li>
  <li>The <i>lambda-list</i> argument to <b>defgeneric</b> becomes the value of the <b>:lambda-list</b>
    keyword argument to <a href="dictionary.html#ensure-generic-function"><b>ensure-generic-function</b></a>.
  </li>
  <li>For each of the options <b>:argument-precedence-order</b>, <b>:documentation</b>, <b>:generic-function-class</b>
    and <b>:method-class</b>, the value of the option becomes the value of the keyword
    argument with the same name. If the option does not appear in the macro form, the keyword
    argument does not appear in the resulting call to <a
    href="dictionary.html#ensure-generic-function"><b>ensure-generic-function</b></a>. </li>
  <li>For the option <b>declare</b>, the list of declarations becomes the value of the <b>:declarations</b>
    keyword argument. If the <b>declare</b> option does not appear in the macro form, the <b>:declarations</b>
    keyword argument does not appear in the call to <a
    href="dictionary.html#ensure-generic-function"><b>ensure-generic-function</b></a>. </li>
  <li>The handling of the <b>:method-combination</b> option is not specified. </li>
</ul>

<p>The result of the call to <a href="dictionary.html#ensure-generic-function"><b>ensure-generic-function</b></a>
is returned as the result of evaluating or executing the <b>defgeneric</b> form. </p>

<h2><a name="subprotocols">Subprotocols</a></h2>

<p>This section provides an overview of the Metaobject Protocols. The detailed behavior of
each function, generic function and macro in the Metaobject Protocol is presented in the <a
name="dictionary">Generic Functions and Methods Dictionary</a>. The remainder of this
chapter is intended to emphasize connections among the parts of the Metaobject Protocol,
and to provide some examples of the kinds of specializations and extensions the protocols
are designed to support. </p>

<h3><a name="metaobject-initialization-protocols">Metaobject Initialization Protocols</a></h3>

<p>Like other objects, metaobjects can be created by calling <a
href="dictionary.html#make-instance"><b>make-instance</b></a>. The initialization
arguments passed to <a href="dictionary.html#make-instance"><b>make-instance</b></a> are
used to initialize the metaobject in the usual way. The set of legal initialization
arguments, and their interpretation, depends on the kind of metaobject being created.
Implementations and portable programs are free to extend the set of legal initialization
arguments. Detailed information about the initialization of each kind of metaobject are
provided in <a name="dictionary">Generic Functions and Methods Dictionary</a>; this
section provides an overview and examples of this behavior. </p>

<h4><a name="init-class">Initialization of Class Metaobjects</a></h4>

<p>Class metaobjects created with <a href="dictionary.html#make-instance"><b>make-instance</b></a>
are usually <em>anonymous</em>; that is, they have no proper name. An anonymous class
metaobject can be given a proper name using <b>setf find-class</b> and <a
href="dictionary.html#(setf class-name)"><b>setf class-name</b></a>. </p>

<p>When a class metaobject is created with <a href="dictionary.html#make-instance"><b>make-instance</b></a>,
it is initialized in the usual way. The initialization arguments passed to <a
href="dictionary.html#make-instance"><b>make-instance</b></a> are use to establish the
definition of the class. Each initialization argument is checked for errors and associated
with the class metaobject. The initialization arguments correspond roughly to the
arguments accepted by the <b>defclass</b> macro, and more closely to the arguments
accepted by the <a href="dictionary.html#ensure-class"><b>ensure-class</b></a> function. </p>

<p>Some class metaobject classes allow their instances to be redefined. When permissible,
this is done by calling <b>reinitialize-instance</b>. This is discussed in the next
section. </p>

<p>An example of creating an anonymous class directly using <a
href="dictionary.html#make-instance"><b>make-instance</b></a> follows: </p>

<pre>
(flet ((zero () 0)
       (propellor () *propellor*))
  (make-instance 'standard-class
    :name '(my-class foo)
    :direct-superclasses (list (find-class 'plane)
                              <i>another-anonymous-class</i>)
    :direct-slots `((:name x
                     :initform 0
                     :initfunction ,#'zero
                     :initargs (:x)
                     :readers (position-x)
                     :writers ((setf position-x)))
                    (:name y
                     :initform 0
                     :initfunction ,#'zero
                     :initargs (:y)
                     :readers (position-y)
                     :writers ((setf position-y))))
    :direct-default-initargs `((:engine *propellor* ,#'propellor))))
</pre>

<h4><a name="reinit-class">Reinitialization of Class Metaobjects</a></h4>

<p>Some class metaobject classes allow their instances to be reinitialized. This is done
by calling <b>reinitialize-instance</b>. The initialization arguments have the same
interpretation as in class initialization. </p>

<p>If the class metaobject was finalized before the call to <b>reinitialize-instance</b>, <a
href="dictionary.html#finalize-inheritance"><b>finalize-inheritance</b></a> will be called
again once all the initialization arguments have been processed and associated with the
class metaobject. In addition, once finalization is complete, any dependents of the class
metaobject will be updated by calling <a href="dictionary.html#update-dependent"><b>update-dependent</b></a>.
</p>

<h4><a name="init-generic">Initialization of Generic Function and Method Metaobjects</a></h4>

<p>An example of creating a generic function and a method metaobject, and then adding the
method to the generic function is shown below. This example is comparable to the method
definition shown in <a href="#defmethod1">Figure 3</a>. </p>

<pre>
(let* ((gf (make-instance 'standard-generic-function
                          :lambda-list '(p l &amp;optional visiblyp &amp;key)))
       (method-class (generic-function-method-class gf)))
  (multiple-value-bind (lambda initargs)
       (make-method-lambda
         gf
         (class-prototype method-class)
         '(lambda (p l &amp;optional (visiblyp t) &amp;key color)
            (set-to-origin p)
            (when visiblyp (show-move p 0 color)))
         nil)
    (add-method gf
                (apply #'make-instance method-class
                       :function (compile nil lambda)
                       :specializers (list (find-class 'position)
                                           (intern-eql-specializer 0))
                       :qualifiers ()
                       :lambda-list '(p l &amp;optional (visiblyp t)
                                          &amp;key color)
                       initargs))))
</pre>

<h3><a name="class-finalization-protocol">Class Finalization Protocol</a></h3>

<p>Class <em>finalization</em> is the process of computing the information a class
inherits from its superclasses and preparing to actually allocate instances of the class.
The class finalization process includes computing the class's class precedence list, the
full set of slots accessible in instances of the class and the full set of default
initialization arguments for the class. These values are associated with the class
metaobject and can be accessed by calling the appropriate reader. In addition, the class
finalization process makes decisions about how instances of the class will be implemented.
</p>

<p>To support forward-referenced superclasses, and to account for the fact that not all
classes are actually instantiated, class finalization is not done as part of the
initialization of the class metaobject. Instead, finalization is done as a separate
protocol, invoked by calling the generic function <a
href="dictionary.html#finalize-inheritance"><b>finalize-inheritance</b></a>. The exact
point at which <a href="dictionary.html#finalize-inheritance"><b>finalize-inheritance</b></a>
is called depends on the class of the class metaobject; for <b>standard-class</b> it is
called sometime after all the classes superclasses are defined, but no later than when the
first instance of the class is allocated (by <a href="dictionary.html#allocate-instance"><b>allocate-instance</b></a>).
</p>

<p>The first step of class finalization is computing the class precedence list. Doing this
first allows subsequent steps to access the class precedence list. This step is performed
by calling the generic function <a href="dictionary.html#compute-class-precedence-list"><b>compute-class-precedence-list</b></a>.
The value returned from this call is associated with the class metaobject and can be
accessed by calling the <a href="dictionary.html#class-mo-readers"><b>class-precedence-list</b></a>
generic function. </p>

<p>The second step is computing the full set of slots that will be accessible in instances
of the class. This step is performed by calling the generic function <a
href="dictionary.html#compute-slots"><b>compute-slots</b></a>. The result of this call is
a list of effective slot definition metaobjects. This value is associated with the class
metaobject and can be accessed by calling the <a href="dictionary.html#class-mo-readers"><b>class-slots</b></a>
generic function. </p>

<p>The behavior of <a href="dictionary.html#compute-slots"><b>compute-slots</b></a> is
itself layered, consisting of calls to <a
href="dictionary.html#effective-slot-definition-class"><b>effective-slot-definition-class</b></a>
and <a href="dictionary.html#compute-effective-slot-definition"><b>compute-effective-slot-definition</b></a>.
</p>

<p>The final step of class finalization is computing the full set of initialization
arguments for the class. This is done by calling the generic function <a
href="dictionary.html#compute-default-initargs"><b>compute-default-initargs</b></a>. The
value returned by this generic function is associated with the class metaobject and can be
accessed by calling <a href="dictionary.html#class-mo-readers"><b>class-default-initargs</b></a>.
</p>

<p>If the class was previously finalized, <a href="dictionary.html#finalize-inheritance"><b>finalize-inheritance</b></a>
may call <b>make-instances-obsolete</b>. The circumstances under which this happens are
describe in the section of the CLOS specification called ``Redefining Classes.'' </p>

<p>Forward-referenced classes, which provide a temporary definition for a class which has
been referenced but not yet defined, can never be finalized. An error is signalled if <a
href="dictionary.html#finalize-inheritance"><b>finalize-inheritance</b></a> is called on a
forward-referenced class. </p>

<h3><a name="instance-structure-protocol">Instance Structure Protocol</a></h3>

<p>The instance structure protocol is responsible for implementing the behavior of the
slot access functions like <b>slot-value</b> and <b>(setf slot-value)</b>. </p>

<p>For each CLOS slot access function other than <b>slot-exists-p</b>, there is a
corresponding generic function which actually provides the behavior of the function. When
called, the slot access function finds the pertinent effective slot definition metaobject,
calls the corresponding generic function and returns its result. The arguments passed on
to the generic function include one additional value, the class of the <i>object</i>
argument, which always immediately precedes the <i>object</i> argument </p>

<p>The correspondences between slot access function and underlying slot access generic
function are as follows: </p>

<table border="yes">
  <tr>
    <th>Slot Access Function</th>
    <th>Corresponding Slot Access Generic Function</th>
  </tr>
  <tr>
    <td>slot-boundp </td>
    <td>slot-boundp-using-class </td>
  </tr>
  <tr>
    <td>slot-makunbound </td>
    <td>slot-makunbound-using-class </td>
  </tr>
  <tr>
    <td>slot-value </td>
    <td>slot-value-using-class </td>
  </tr>
  <tr>
    <td>(setf slot-value) </td>
    <td>(setf slot-value-using-class) </td>
  </tr>
</table>

<p>At the lowest level, the instance structure protocol provides only limited mechanisms
for portable programs to control the implementation of instances and to directly access
the storage associated with instances without going through the indirection of slot
access. This is done to allow portable programs to perform certain commonly requested slot
access optimizations. </p>

<p>In particular, portable programs can control the implementation of, and obtain direct
access to, slots with allocation <b>:instance</b> and type <b>t</b>. These are called <em>directly
accessible slots</em>. </p>

<p>The relevant specified around-method on <a href="dictionary.html#compute-slots"><b>compute-slots</b></a>
determines the implementation of instances by deciding how each slot in the instance will
be stored. For each directly accessible slot, this method allocates a <em>location</em>
and associates it with the effective slot definition metaobject. The location can be
accessed by calling the <b>slot-definition-location</b> generic function. Locations are
non-negative integers. For a given class, the locations increase consecutively, in the
order that the directly accessible slots appear in the list of effective slots. (Note that
here, the next paragraph, and the specification of this around-method are the only places
where the value returned by <a href="dictionary.html#compute-slots"><b>compute-slots</b></a>
is described as a list rather than a set.) </p>

<p>Given the location of a directly accessible slot, the value of that slot in an instance
can be accessed with the appropriate accessor. For <b>standard-class</b>, this accessor is
the function <a href="dictionary.html#standard-instance-access"><b>standard-instance-access</b></a>.
For <b>funcallable-standard-class</b>, this accessor is the function <a
href="dictionary.html#funcallable-standard-instance-access"><b>funcallable-standard-instance-access</b></a>.
In each case, the arguments to the accessor are the instance and the slot location, in
that order. See the definition of each accessor in Chapter <a href="#dictionary"></a> for
additional restrictions on the use of these function. </p>

<p>Portable programs are permitted to affect and rely on the allocation of locations only
in the following limited way: By first defining a portable primary method on <a
href="dictionary.html#compute-slots"><b>compute-slots</b></a> which orders the returned
value in a predictable way, and then relying on the defined behavior of the specified
around-method to assign locations to all directly accessible slots. Portable programs may
compile-in calls to low-level accessors which take advantage of the resulting predictable
allocation of slot locations. </p>

<p>The following example shows the use of this mechanism to implement a new class
metaobject class, <b>ordered-class</b> and class option <b>:slot-order</b>. This option
provides control over the allocation of slot locations. In this simple example
implementation, the <b>:slot-order</b> option is not inherited by subclasses; it controls
only instances of the class itself. </p>

<pre>
(defclass ordered-class (standard-class)
     ((slot-order :initform ()
                  :initarg :slot-order
                  :reader class-slot-order)))

</pre>

<p>(defmethod compute-slots ((class ordered-class)) (let ((order (class-slot-order
class))) (sort (copy-list (call-next-method)) #'(lambda (a b) (<(position (slot-definition-name a) order) (position (slot-definition-name b) order)))))) </pre> </p>

<p>Following is the source code the user of this extension would write. Note that because
the code above doesn't implement inheritance of the <b>:slot-order</b> option, the
function <b>distance</b> must not be called on instances of subclasses of <b>point</b>; it
can only be called on instances of <b>point</b> itself. </p>

<pre>
(defclass point ()
     ((x :initform 0)
      (y :initform 0))
  (:metaclass ordered-class)
  (:slot-order x y))

</pre>

<p>(defun distance (point) (sqrt (/ (+ (expt (standard-instance-access point 0) 2) (expt
(standard-instance-access point 1) 2)) 2.0))) </p>

<p>In more realistic uses of this mechanism, the calls to the low-level instance structure
accessors would not actually appear textually in the source program, but rather would be
generated by a meta-level analysis program run during the process of compiling the source
program. </p>

<h3><a name="funcallable-instances">Funcallable Instances</a></h3>

<p>Instances of classes which are themselves instances of <b>funcallable-standard-class</b>
or one of its subclasses are called <i>funcallable instances</i>. Funcallable instances
can only be created by <a href="dictionary.html#allocate-instance"><b>allocate-instance
(funcallable-standard-class)</b></a>. </p>

<p>Like standard instances, funcallable instances have slots with the normal behavior.
They differ from standard instances in that they can be used as functions as well; that
is, they can be passed to <b>funcall</b> and <b>apply</b>, and they can be stored as the
definition of a function name. Associated with each funcallable instance is the function
which it runs when it is called. This function can be changed with <a
href="dictionary.html#set-funcallable-instance-function"><b>set-funcallable-instance-function</b></a>.
</p>

<p>The following simple example shows the use of funcallable instances to create a simple,
<b>defstruct</b>-like facility. (Funcallable instances are useful when a program needs to
construct and maintain a set of functions and information about those functions. They make
it possible to maintain both as the same object rather than two separate objects linked,
for example, by hash tables.) </p>

<pre>
(defclass constructor ()
     ((name :initarg :name :accessor constructor-name)
      (fields :initarg :fields :accessor constructor-fields))
  (:metaclass funcallable-standard-class))

</pre>

<p>(defmethod initialize-instance :after ((c constructor) &amp;key) (with-slots (name
fields) c (set-funcallable-instance-function c #'(lambda () (let ((new (make-array (1+
(length fields))))) (setf (aref new 0) name) new))))) </p>

<p>(setq c1 (make-instance 'constructor :name 'position :fields '(x y))) #&lt;CONSTRUCTOR
262437&gt; </p>

<p>(setq p1 (funcall c1)) #&lt;ARRAY 3 263674&gt; </p>

<h3><a name="generic-function-invocation-protocol">Generic Function Invocation Protocol</a></h3>

<p>Associated with each generic function is its discriminating function. Each time the
generic function is called, the discriminating function is called to provide the behavior
of the generic function. The discriminating function receives the full set of arguments
received by the generic function. It must lookup and execute the appropriate methods, and
return the appropriate values. </p>

<p>The discriminating function is computed by the highest layer of the generic function
invocation protocol, <a href="dictionary.html#compute-discriminating-function"><b>compute-discriminating-function</b></a>.
Whenever a generic function metaobject is initialized, reinitialized, or a method is added
or removed, the discriminating function is recomputed. The new discriminating function is
then stored with <a href="dictionary.html#set-funcallable-instance-function"><b>set-funcallable-instance-function</b></a>.
</p>

<p>Discriminating functions call <a href="dictionary.html#compute-applicable-methods"><b>compute-applicable-methods</b></a>
and <a href="dictionary.html#compute-applicable-methods-using-classes"><b>compute-applicable-methods-using-classes</b></a>
to compute the methods applicable to the generic functions arguments. Applicable methods
are combined by <a href="dictionary.html#compute-effective-method"><b>compute-effective-method</b></a>
to produce an <i>effective method</i>. Provisions are made to allow memoization of the
method applicability and effective methods computations. (See the description of <a
href="dictionary.html#compute-discriminating-function"><b>compute-discriminating-function</b></a>
for details.) </p>

<p>The body of method definitions are processed by <a
href="dictionary.html#make-method-lambda"><b>make-method-lambda</b></a>. The result of
this generic function is a lambda expression which is processed by either <b>compile</b>
or the file compiler to produce a <i>method function</i>. The arguments received by the
method function are controlled by the <b>call-method</b> forms appearing in the effective
methods. By default, method functions accept two arguments: a list of arguments to the
generic function, and a list of next methods. The list of next methods corresponds to the
next methods argument to <b>call-method</b>. If <b>call-method</b> appears with additional
arguments, these will be passed to the method functions as well; in these cases, <a
href="dictionary.html#make-method-lambda"><b>make-method-lambda</b></a> must have created
the method lambdas to expect additional arguments. </p>

<h3><a name="dependent-maintenance-protocol">Dependent Maintenance Protocol</a></h3>

<p>It is convenient for portable metaobjects to be able to memoize information about other
metaobjects, portable or otherwise. Because class and generic function metaobjects can be
reinitialized, and generic function metaobjects can be modified by adding and removing
methods, a means must be provided to update this memoized information. </p>

<p>The dependent maintenance protocol supports this by providing a way to register an
object which should be notified whenever a class or generic function is modified. An
object which has been registered this way is called a <em>dependent</em> of the class or
generic function metaobject. The dependents of class and generic function metaobjects are
maintained with <a href="dictionary.html#add-dependent"><b>add-dependent</b></a> and <a
href="dictionary.html#remove-dependent"><b>remove-dependent</b></a>. The dependents of a
class or generic function metaobject can be accessed with <a
href="dictionary.html#map-dependents"><b>map-dependents</b></a>. Dependents are notified
about a modification by calling <a href="dictionary.html#update-dependent"><b>update-dependent</b></a>.
(See the specification of <a href="dictionary.html#update-dependent"><b>update-dependent</b></a>
for detailed description of the circumstances under which it is called.) </p>

<p>To prevent conflicts between two portable programs, or between portable programs and
the implementation, portable code must not register metaobjects themselves as dependents.
Instead, portable programs which need to record a metaobject as a dependent, should
encapsulate that metaobject in some other kind of object, and record that object as the
dependent. The results are undefined if this restriction is violated. </p>

<p>This example shows a general facility for encapsulating metaobjects before recording
them as dependents. The facility defines a basic kind of encapsulating object: an updater.
Specializations of the basic class can be defined with appropriate special updating
behavior. In this way, information about the updating required is associated with each
updater rather than with the metaobject being updated. </p>

<p>Updaters are used to encapsulate any metaobject which requires updating when a given
class or generic function is modified. The function <b>record-updater</b> is called to
both create an updater and add it to the dependents of the class or generic function.
Methods on the generic function <a href="dictionary.html#update-dependent"><b>update-dependent</b></a>,
specialized to the specific class of updater do the appropriate update work. </p>

<pre>
(defclass updater ()
     ((dependent :initarg :dependent :reader dependent)))

</pre>

<p>(defun record-updater (class dependee dependent &amp;rest initargs) (let ((updater
(apply #'make-instance class :dependent dependent initargs))) (add-dependent dependee
updater) updater)) </p>

<p>A <b>flush-cache-updater</b> simply flushes the cache of the dependent when it is
updated. </p>

<pre>
(defclass flush-cache-updater (updater) ())

</pre>

<p>(defmethod update-dependent (dependee (updater flush-cache-updater) &amp;rest args)
(declare (ignore args)) (flush-cache (dependent updater))) </p>
</body>
</html>
