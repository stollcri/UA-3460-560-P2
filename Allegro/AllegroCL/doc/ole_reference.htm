<html>
<head>
<title>Allegro OLE Reference</title>
</head>
<body>
<h1>Allegro OLE	Reference</h1>
<hr>
<ul>
<li><a href="#ADDCONNECTIONPOINT">add-connection-point</a>
<li><a href="#ADDDOCUMENT">add-document</a>
<li><a href="#ADDINPROCFACTORY">add-inproc-factory</a>
<li><a href="#ADDREF">add-ref</a>
<li><a href="#ADDREGISTRYKEY">add-registry-key</a>
<li><a href="#ADDREGISTRYSTRUCTURE">add-registry-structure</a>
<li><a href="#ADDSITE">add-site</a>
<li><a href="#ADVISECONNECTION">advise-connection</a>
<li><a href="#APPLICATIONCLASSID">application-classid</a>
<li><a href="#ASKFORAUTOTOOL">ask-for-autotool</a>
<li><a href="#AUTOGETF">auto-getf</a>
<li><a href="#AUTOMATON">automaton</a>
<li><a href="#AUTOMATONCLASS">automaton-class</a>
<li><a href="#AUTOMETHOD">auto-method</a>
<li><a href="#BINARYGUID">binary-guid</a>
<li><a href="#BOOL">bool</a>
<li><a href="#BSTR">bstr</a>
<li><a href="#BSTRSTRING">bstr-string</a>
<li><a href="#CHECKRETURN">check-return</a>
<li><a href="#CLASSFACTORY">class-factory</a>
<li><a href="#CLOSECONTROL">close-control</a>
<li><a href="#CLOSEREGISTRYKEY">close-registry-key</a>
<li><a href="#CODEGUID">code-guid</a>
<li><a href="#COMPUTEHIMETRICCONVERSION">compute-himetric-conversion</a>
<li><a href="#CONNECTEVENTCHANNEL">connect-event-channel</a>
<li><a href="#CONNECTIONENUMERATOR">connection-enumerator</a>
<li><a href="#CONNECTIONPOINT">connection-point</a>
<li><a href="#CONNECTIONPOINTCONTAINER">connection-point-container</a>
<li><a href="#CONNECTIONPOINTENUMERATOR">connection-point-enumerator</a>
<li><a href="#CONNECTSITE">connect-site</a>
<li><a href="#CONNECTTOSERVER">connect-to-server</a>
<li><a href="#CONTAINERMIXIN">container-mixin</a>
<li><a href="#CONTROL">control</a>
<li><a href="#CREATEINSTANCE">create-instance</a>
<li><a href="#CY">cy</a>
<li><a href="#DATE">date</a>
<li><a href="#DEFAUTOMETHOD">def-automethod</a>
<li><a href="#DEFCLIENTINTERFACE">def-client-interface</a>
<li><a href="#DEFIID">defiid</a>
<li><a href="#DEFOCXCLASS">def-ocx-class</a>
<li><a href="#DEFOLEINTERFACE">def-ole-interface</a>
<li><a href="#DEFOLELINKAGE">def-ole-linkage</a>
<li><a href="#DEFSERVERINTERFACE">def-server-interface</a>
<li><a href="#DELETEREGISTRYVALUE">delete-registry-value</a>
<li><a href="#DESTROYSAFEARRAY">destroy-safearray</a>
<li><a href="#DISCONNECT">disconnect</a>
<li><a href="#DISPIDNAMES">dispid-names</a>
<li><a href="#DOASPROCESS">do-as-process</a>
<li><a href="#DOCUMENTMIXIN">document-mixin</a>
<li><a href="#DOREGISTRYSUBKEYNAMES">do-registry-subkey-names</a>
<li><a href="#DOREGISTRYVALUENAMES">do-registry-value-names</a>
<li><a href="#ENUMERATECONNECTIONPOINTS">enumerate-connection-points</a>
<li><a href="#ENUMERATECONNECTIONS">enumerate-connections</a>
<li><a href="#ENUMERATORCLONE">enumerator-clone</a>
<li><a href="#ENUMERATORINTERFACEIID">enumerator-interface-iid</a>
<li><a href="#ENUMERATORNEXT">enumerator-next</a>
<li><a href="#ENUMERATORRESET">enumerator-reset</a>
<li><a href="#ENUMERATORSKIP">enumerator-skip</a>
<li><a href="#ENUMERATORSTEP">enumerator-step</a>
<li><a href="#EVENTTRACING">event-tracing</a>
<li><a href="#EXCEPINFO">excepinfo</a>
<li><a href="#EXCEPTIONINFO">exception-info</a>
<li><a href="#EXECUTIONERROR">execution-error</a>
<li><a href="#EXTENDEDINCOMINGERROR">extended-incoming-error</a>
<li><a href="#FACTORYIDLE">factory-idle</a>
<li><a href="#FAILURE">failure</a>
<li><a href="#FILEISSTORAGEP">file-is-storage-p</a>
<li><a href="#FINDCONNECTIONPOINT">find-connection-point</a>
<li><a href="#FORMATIDL">format-idl</a>
<li><a href="#FRAMEMIXIN">frame-mixin</a>
<li><a href="#FREEBSTR">free-bstr</a>
<li><a href="#FREEUNICODE">free-unicode</a>
<li><a href="#GETCLASSOBJECT">get-class-object</a>
<li><a href="#GETCONNECTIONCONTAINER">get-connection-container</a>
<li><a href="#GETCONNECTIONINTERFACE">get-connection-interface</a>
<li><a href="#GETTYPEATTR">get-type-attr</a>
<li><a href="#GETTYPEINFO">get-type-info</a>
<li><a href="#GETTYPEINFOCOUNT">get-type-info-count</a>
<li><a href="#GUID">guid</a>
<li><a href="#GUIDBINARY">guid-binary</a>
<li><a href="#GUIDNAME">guid-name</a>
<li><a href="#GUIDP">guid-p</a>
<li><a href="#GUIDTYPEINFO">guid-typeinfo</a>
<li><a href="#GUIDTYPELIB">guid-typelib</a>
<li><a href="#H">h</a>
<li><a href="#HRESULT">hresult</a>
<li><a href="#HRESULTCODE">hresult-code</a>
<li><a href="#HRESULTFACILITY">hresult-facility</a>
<li><a href="#ICLASSFACTORY">IClassFactory</a>
<li><a href="#ICLASSFACTORYCLIENT">IClassFactory-client</a>
<li><a href="#ICLASSFACTORYSERVER">IClassFactory-server</a>
<li><a href="#ICONNECTIONPOINT">IConnectionPoint</a>
<li><a href="#ICONNECTIONPOINTCLIENT">IConnectionPoint-client</a>
<li><a href="#ICONNECTIONPOINTCONTAINER">IConnectionPointContainer</a>
<li><a href="#ICONNECTIONPOINTCONTAINERCLIENT">IConnectionPointContainer-client</a>
<li><a href="#ICONNECTIONPOINTCONTAINERSERVER">IConnectionPointContainer-server</a>
<li><a href="#ICONNECTIONPOINTSERVER">IConnectionPoint-server</a>
<li><a href="#IDISPATCH">IDispatch</a>
<li><a href="#IDISPATCHCLIENT">IDispatch-client</a>
<li><a href="#IDISPATCHINVOKEEXCEPTION">idispatch-invoke-exception</a>
<li><a href="#IDISPATCHSERVER">IDispatch-server</a>
<li><a href="#IENUMCONNECTIONPOINTS">IEnumConnectionPoints</a>
<li><a href="#IENUMCONNECTIONPOINTSCLIENT">IEnumConnectionPoints-client</a>
<li><a href="#IENUMCONNECTIONPOINTSSERVER">IEnumConnectionPoints-server</a>
<li><a href="#IENUMCONNECTIONS">IEnumConnections</a>
<li><a href="#IENUMCONNECTIONSCLIENT">IEnumConnections-client</a>
<li><a href="#IENUMCONNECTIONSSERVER">IEnumConnections-server</a>
<li><a href="#IENUMXXX">IEnumxxx</a>
<li><a href="#IENUMXXXCLIENT">IEnumxxx-client</a>
<li><a href="#IENUMXXXSERVER">IEnumxxx-server</a>
<li><a href="#IIDCLIENTINTERFACETYPE">iid-client-interface-type</a>
<li><a href="#IIDICLASSFACTORY">IID_IClassFactory</a>
<li><a href="#IIDICONNECTIONPOINT">IID_IConnectionPoint</a>
<li><a href="#IIDICONNECTIONPOINTCONTAINER">IID_IConnectionPointContainer</a>
<li><a href="#IIDIENUMCONNECTIONPOINTS">IID_IEnumConnectionPoints</a>
<li><a href="#IIDIENUMCONNECTIONS">IID_IEnumConnections</a>
<li><a href="#IIDIMALLOC">IID_IMalloc</a>
<li><a href="#IIDISTORAGE">IID_IStorage</a>
<li><a href="#IIDITYPEINFO">IID_ITypeInfo</a>
<li><a href="#IIDITYPELIB">IID_ITypeLib</a>
<li><a href="#IIDIUNKNOWN">IID_IUnknown</a>
<li><a href="#IIDNULL">IID_NULL</a>
<li><a href="#IMALLOC">IMalloc</a>
<li><a href="#IMALLOCCLIENT">IMalloc-client</a>
<li><a href="#INCOMINGERROR">incoming-error</a>
<li><a href="#INSTALLCONTROL">install-control</a>
<li><a href="#INTERFACEHANDLE">interface-handle</a>
<li><a href="#INVOKE">Invoke</a>
<li><a href="#ISTORAGE">IStorage</a>
<li><a href="#ISTORAGECLIENT">IStorage-client</a>
<li><a href="#ISTORAGESERVER">IStorage-server</a>
<li><a href="#ITYPEINFO">ITypeInfo</a>
<li><a href="#ITYPEINFOCLIENT">ITypeInfo-client</a>
<li><a href="#ITYPELIB">ITypeLib</a>
<li><a href="#ITYPELIBCLIENT">ITypeLib-client</a>
<li><a href="#IUNKNOWN">IUnknown</a>
<li><a href="#IUNKNOWNCLIENT">IUnknown-client</a>
<li><a href="#IUNKNOWNSERVER">IUnknown-server</a>
<li><a href="#LISPDATE">lisp-date</a>
<li><a href="#LISPDATETOOLEDATE">lisp-date-to-ole-date</a>
<li><a href="#LISPDATEUT">lisp-date-ut</a>
<li><a href="#LISPELEMDESC">lisp-elemdesc</a>
<li><a href="#LISPELEMDESCFLOW">lisp-elemdesc-flow</a>
<li><a href="#LISPELEMDESCNAME">lisp-elemdesc-name</a>
<li><a href="#LISPELEMDESCTDESC">lisp-elemdesc-tdesc</a>
<li><a href="#LISPFUNCDESC">lisp-funcdesc</a>
<li><a href="#LISPFUNCDESCELEMDESCFUNC">lisp-funcdesc-elemdescFunc</a>
<li><a href="#LISPFUNCDESCINVKIND">lisp-funcdesc-invkind</a>
<li><a href="#LISPFUNCDESCNAME">lisp-funcdesc-name</a>
<li><a href="#LISPFUNCDESCPARAMS">lisp-funcdesc-params</a>
<li><a href="#LISPGUID">lisp-guid</a>
<li><a href="#LISPOLEOBJECT">lisp-ole-object</a>
<li><a href="#LISPSAFEARRAY">lisp-safearray</a>
<li><a href="#LISPTYPEINFO">lisp-typeinfo</a>
<li><a href="#LISPTYPEINFOFUNCTIONS">lisp-typeinfo-functions</a>
<li><a href="#LISPTYPEINFOINTERFACEFLAGS">lisp-typeinfo-interface-flags</a>
<li><a href="#LISPTYPEINFOINTERFACES">lisp-typeinfo-interfaces</a>
<li><a href="#LISPTYPEINFOKIND">lisp-typeinfo-kind</a>
<li><a href="#LOADTYPELIB">load-typelib</a>
<li><a href="#LOCKEDP">lockedp</a>
<li><a href="#LOCKSERVER">lock-server</a>
<li><a href="#MAKECLIENTINTERFACEINSTANCE">make-client-interface-instance</a>
<li><a href="#MAKELISPDATE">make-lisp-date</a>
<li><a href="#MAKELISPSAFEARRAY">make-lisp-safearray</a>
<li><a href="#MAKESCODE">make-scode</a>
<li><a href="#MALLOCINTERFACE">*malloc-interface*</a>
<li><a href="#MANUFACTUREDOBJECT">manufactured-object</a>
<li><a href="#NEXTCONNECTIONPOINT">next-connection-point</a>
<li><a href="#OBJECTNAME">object-name</a>
<li><a href="#OBJECTWINDOW">object-window</a>
<li><a href="#OLEDATETOLISPDATE">ole-date-to-lisp-date</a>
<li><a href="#OLEERROR">ole-error</a>
<li><a href="#OLEFREE">ole-free</a>
<li><a href="#OLELANGUAGE">*ole-language*</a>
<li><a href="#OLELOCALE">*ole-locale*</a>
<li><a href="#OPENOLESTORAGE">open-ole-storage</a>
<li><a href="#OPENOLESTREAM">open-ole-stream</a>
<li><a href="#OPENREGISTRYKEY">open-registry-key</a>
<li><a href="#OWNINGPROCESS">owning-process</a>
<li><a href="#PINTERFACE">pInterface</a>
<li><a href="#PROCESSCONNECTIONEVENT">process-connection-event</a>
<li><a href="#PROCESSSITEMESSAGE">process-site-message</a>
<li><a href="#QUERYINTERFACE">query-interface</a>
<li><a href="#REFCOUNT">ref-count</a>
<li><a href="#REGISTERFACTORY">register-factory</a>
<li><a href="#REGISTERSERVER">register-server</a>
<li><a href="#REGISTRYKEY">registry-key</a>
<li><a href="#REGISTRYSUBKEYNAMES">registry-subkey-names</a>
<li><a href="#REGISTRYVALUE">registry-value</a>
<li><a href="#REGISTRYVALUENAMES">registry-value-names</a>
<li><a href="#REGISTRYVALUEPRESENTP">registry-value-present-p</a>
<li><a href="#RELEASE">release</a>
<li><a href="#RELEASEPROCESSCLIENTINTERFACES">release-process-client-interfaces</a>
<li><a href="#REMOTEAUTOTOOL">remote-autotool</a>
<li><a href="#REQUIRECLIENTINTERFACES">require-client-interfaces</a>
<li><a href="#REQUIREMODULES">require-modules</a>
<li><a href="#REQUIRESERVERINTERFACES">require-server-interfaces</a>
<li><a href="#RKEYCLASSESROOT">rkey-classes-root</a>
<li><a href="#RKEYCURRENTUSER">rkey-current-user</a>
<li><a href="#RKEYLOCALMACHINE">rkey-local-machine</a>
<li><a href="#RKEYUSERS">rkey-users</a>
<li><a href="#RUNNINGBLIND">*running-blind*</a>
<li><a href="#SAFEARRAY">safearray</a>
<li><a href="#SAFEARRAYAREF">safearray-aref</a>
<li><a href="#SAFEARRAYDIMENSION">safearray-dimension</a>
<li><a href="#SAFEARRAYDIMENSIONS">safearray-dimensions</a>
<li><a href="#SAFEARRAYELEMENTADDRESS">safearray-element-address</a>
<li><a href="#SAFEARRAYPOINTER">safearray-pointer</a>
<li><a href="#SAFEARRAYRANK">safearray-rank</a>
<li><a href="#SERVERDLLNAME">server-dll-name</a>
<li><a href="#SERVERINITIALIZATIONCOMPLETE">*server-initialization-complete*</a>
<li><a href="#SETEVENTRETURN">set-event-return</a>
<li><a href="#SETSERVERTRACE">set-server-trace</a>
<li><a href="#SETVARIANTVALUEEXTENSION">set-variant-value-extension</a>
<li><a href="#SIGNALSERVEREXCEPTION">signal-server-exception</a>
<li><a href="#SITEMIXIN">site-mixin</a>
<li><a href="#STARTOLE">start-ole</a>
<li><a href="#STOPOLE">stop-ole</a>
<li><a href="#STORAGEFORSITE">storage-for-site</a>
<li><a href="#STRINGBSTR">string-bstr</a>
<li><a href="#STRINGGUID">string-guid</a>
<li><a href="#STRINGUNICODE">string-unicode</a>
<li><a href="#SUCCESS">success</a>
<li><a href="#UNADVISECONNECTION">unadvise-connection</a>
<li><a href="#UNICODE">unicode</a>
<li><a href="#UNICODESTRING">unicode-string</a>
<li><a href="#UNIQUEGUID">unique-guid</a>
<li><a href="#UNREGISTERAPPLICATION">unregister-application</a>
<li><a href="#UNREGISTERFACTORY">unregister-factory</a>
<li><a href="#VARIANT">variant</a>
<li><a href="#VARIANTAREF">variant-aref</a>
<li><a href="#VARIANTCHANGETYPE">VariantChangeType</a>
<li><a href="#VARIANTCLEAR">VariantClear</a>
<li><a href="#VARIANTCOPY">VariantCopy</a>
<li><a href="#VARIANTINIT">VariantInit</a>
<li><a href="#VARIANTVALUE">variant-value</a>
<li><a href="#VARIANTVALUES">variant-values</a>
<li><a href="#VARIANTVALUETRANSLATIONFUNCTION">variant-value-translation-function</a>
<li><a href="#WITHFOREIGNDATA">with-foreign-data</a>
<li><a href="#WITHOPENREGISTRYKEY">with-open-registry-key</a>
<li><a href="#WITHSAFEARRAYLOCK">with-safearray-lock</a>
<li><a href="#WITHUNICODEARGUMENT">with-unicode-argument</a>
<li><a href="#XENOADDRESS">xeno-address</a>
<li><a href="#XENOSLOT">xeno-slot</a>
</ul>
<hr>
<a name="ADDCONNECTIONPOINT">
<b>add-connection-point</b><i> cpc iid &key (limit
                                             1) agent (cookie 1)</i><br>
Function<br>
Calling this function creates a new connection-point object and
adds it to an existing
connection-point-container, making interfaces for the specified IID available
from that container.  It is an error to try to add a second connection-point
for an iid that is already available from the connection-point-container.<dl>
<dt>cpc<dd>The connection-point-container object to support the new IID.
<dt>iid<dd>The lisp-guid for the IID to be added.
<dt>limit<dd>The maximum number of open connections to be allowed at one time.
<dt>agent<dd>The agent to handle connection-events for this connection.
<dt>cookie<dd>The initial cookie value to be provided for connections.
</dl><br>
<hr>

<a name="ADDDOCUMENT">
<b>add-document</b><i> doc container</i><br>
Method: primary (document-mixin frame-mixin)<br>
Adds a document object to a container object.<br>
<hr>

<a name="ADDINPROCFACTORY">
<b>add-inproc-factory</b><i> factory</i><br>
Function<br>
Record <i>factory</i> for serving inproc OLE requests.
Requests for its component-classid will be honored
and a server interface returned to the caller.<br>
<hr>

<a name="ADDREF">
<b>add-ref</b><i> object</i><br>
Generic Function<br>
This function is called to announce the creation of a new reference
to object.  It gets called on the xxx-server interface when a client
or OLE calls the AddRef for that interface.<br>
<hr>

<b>add-ref</b><i> obj</i><br>
Method: primary (IUnknown)<br>
Increments (ref-count <i>obj</i>).<br>
<hr>

<b>add-ref</b><i> ifc</i><br>
Method: primary (IUnknown-client)<br>
This method just calls the foreign pInterface's AddRef method, returning
the integer that comes back from that method.<br>
<hr>

<b>add-ref</b><i> obj</i><br>
Method: after (connection-point)<br>
Adding a reference to a connection point also adds a reference to its
container.  The container shouldn't die until all its connection points are
gone.<br>
<hr>

<b>add-ref</b><i> obj</i><br>
Method: after (connection-point-enumerator)<br>
Bumps the ref-count on the connection-point-container object.<br>
<hr>

<b>add-ref</b><i> obj</i><br>
Method: after (connection-enumerator)<br>
Does an add-ref on the connection-point object, as well.<br>
<hr>

<b>add-ref</b><i> obj</i><br>
Method: after (advise-enumerator)<br>
Bumps the ref-count on the adviser object.<br>
<hr>

<a name="ADDREGISTRYKEY">
<b>add-registry-key</b><i> root path &optional (value
                                                nil
                                                value-p)</i><br>
Function<br>
This ensures the existance of the registry key that is
reached by following <i>path</i> from the existing open <i>root</i>,
creating the key if necessary, and optionally setting the default
value of that key to <i>value</i>.<br>
<hr>

<a name="ADDREGISTRYSTRUCTURE">
<b>add-registry-structure</b><i> root structure</i><br>
Function<br>
This function creates registry structure subordinate to the
open registry key <i>root</i>.  The structure to be built is
specified by the list <i>structure</i>.  Each element in list
must be a list specifying a key and value to be attached to <i>root</i>
or a subkey and its structure.  A key-and-value entry for <i>root</i>
is represented as a list of the form (:value <i>name</i> <i>value</i>),
where <i>name</i> is a string.  A subkey and its structure is
represented as a list of the form
(<i>key</i> <i>[value]</i> . <i>structure</i>).  In this element,
the <i>key</i> entry is a string naming the subkey and the optional
<i>value</i>, if present, becomes the default value associated with that
subkey.  The trailing portion of the entry, <i>structure</i> recursively
describes the structure to be built for this new subkey, if any.<br>
<hr>

<a name="ADDSITE">
<b>add-site</b><i> site doc</i><br>
Method: primary (site-mixin document-mixin)<br>
Adds a control site to a document object.<br>
<hr>

<b>add-site</b><i> site frame</i><br>
Method: primary (site-mixin frame-mixin)<br>
Adds a control site directly to a frame object.<br>
<hr>

<a name="ADVISECONNECTION">
<b>advise-connection</b><i> object sink</i><br>
Generic Function<br>
Asks a ConnectionPoint object to accept a <i>sink</i>
interface.  Returns the cookie if the request was honored, otherwise it returns
two values, NIL and an error code.<br>
<hr>

<b>advise-connection</b><i> ifc sink</i><br>
Method: primary (IConnectionPoint-client t)<br>
Invokes IConnectionPoint.Advise and returns the cookie or error code<br>
<hr>

<b>advise-connection</b><i> cp ifc-iunk</i><br>
Method: primary (connection-point t)<br>
If <i>cp</i>'s current active connection count exceeds its limit,
then this function releases <i>ifc-iunk</i> and returns two values,
nil and CONNECT_E_ADVISELIMIT.  If <i>ifc-iunk</i> doesn't support the
interface that <i>cp</i> offers, then <i>ifc-iunk</i> is released and
this function returns the two values nil and CONNECT_E_CANNOTCONNECT.
Otherwise the request is valid.  In this case <i>ifc-iunk</i> is
released and the specified interface is added to <i>cp</i>'s active
connection set.  Process-connection-event is called and this function returns
<i>cp</i>'s next cookie value.<br>
<hr>

<a name="APPLICATIONCLASSID">
<b>application-classid</b><i> appname</i><br>
Function<br>
This function looks up an application in the registry and returns
the associated classid.  The appname must be a string naming an application
that serves OLE objects.
The function looks first for HKEY_CLASSES_ROOT/appname/CLSID.
If that doesn't exist, it tries HKEY_CLASSES_ROOT/appname/CurVer to find
an alternate name for the application.  If either lookup provides a
classid, then that is returned as a lisp-guid.  Otherwise the function
returns nil.<br>
<hr>

<a name="ASKFORAUTOTOOL">
<b>ask-for-autotool</b><i> source context &optional class &rest inits</i><br>
Function<br>
This function calls create-instance to ask for a new
 object and gets an IDispatch interface for it.  The <i>source</i> and
 <i>context</i> arguments are passed to create-instance.<br>
  A successful result from create-instance results
 in the creation of a remote-autotool object that can be used to drive the
 IDispatch interface.  This remote-autotool object is returned from
 ask-for-autotool.  If the create-instance call fails, ask-for-autotool
 returns nil.<br>
 The class of the autotool object defaults to remote-autotool, but can be
 specified using the optional class argument.  If specified, the class
 argument must name a subclass of remote-autotool, and the remaining
 arguments must be keywords and values specifying initialization
 arguments for that class.<br>
<hr>

<a name="AUTOGETF">
<b>auto-getf</b><i> tool prop &rest indices</i><br>
Generic Function<br>
Retrieves the value of a named property via an IDispatch interface.
<dl>
<dt>tool<dd>A remote-autotool object controlling a remote object.
<dt>prop<dd>a string or symbol naming the property to access.
<dt>indices<dd>Any additional values needed to specify a unique property value.
</dl>
The form (auto-getf ...) is setf-able.<br>
<hr>

<b>auto-getf</b><i> tool prop &rest indices</i><br>
Method: primary (remote-autotool t)<br>
This primary method implements auto-getf for instances of remote-autotool.
It should not be overridden for subclasses of remote-autotool; :before,
:after and :around methods should be used to customize behavior.<br>
<hr>

<b>auto-getf</b><i> obj dispid &rest indices</i><br>
Method: primary (IDispatch t)<br>
This default method just returns a keyword that will be interpreted as an
error.  It should be overridden by a more specific method.<br>
<hr>

<b>auto-getf</b><i> obj dispid &rest indices</i><br>
Method: primary (automaton t)<br>
This method uses the dispids from the slot defs.<br>
<hr>

<b>(setf auto-getf)</b><i> value obj dispid &rest indices</i><br>
Method: primary (t automaton t)<br>
This method uses the dispids from the slot defs.<br>
<hr>

<a name="AUTOMATON">
<b>automaton</b><br>
Class<br>
This is the base class for classes that support IDispatch
for remote clients.<br>
<hr>

<a name="AUTOMATONCLASS">
<b>automaton-class</b><br>
Class<br>
The metaclass that allows the use of the :dispid keyword in defclass
slot definitions.<br>
<hr>

<a name="AUTOMETHOD">
<b>auto-method</b><i> tool method-name &rest args</i><br>
Generic Function<br>
Invokes a named method via IDispatch.
<dl>
<dt>tool<dd>A remote-autotool instance controlling a remote object.
<dt>method-name<dd>a string or symbol naming the method to be invoked.
<dt>args<dd>values to be passed as positional arguments followed by
keywords and values designating named arguments.  The first occurrence
of a keyword symbol in the <i>args</i> list ends the positional arguments
and provides the name of the first named argument.  From that point on
the <i>args</i> list must consist of alternating keywords and values.
<br>
Example
<pre><code>
   (auto-method loo-tool :fortify 12 "xxx" :agency 19 :part "a")
</code></pre>
invokes the method named fortify with 4 arguments, two positional and
two named agency and part.
</dl>
The invoked OLE xxx.Invoke method returns its result in a Variant record
whose contents are converted to Lisp and returned as the result of
auto-method.<br>
<hr>

<b>auto-method</b><i> tool method-name &rest args &aux named-args args-rev</i><br>
Method: primary (remote-autotool t)<br>
This primary method implements auto-method for instances of remote-autotool.
It should not be overridden for subclasses of remote-autotool; :before,
:after and :around methods should be used to customize behavior.<br>
<hr>

<b>auto-method</b><i> obj dispid &rest args</i><br>
Method: primary (IDispatch t)<br>
This default method just returns a keyword that will be interpreted as an
error.  It should be overridden by a more specific method.<br>
<hr>

<a name="BINARYGUID">
<b>binary-guid</b><i> cpointer &optional (offset 0)</i><br>
Function<br>
This function accepts a reference to a foreign binary guid and returns
the lisp-guid representing it.  The <i>cpointer</i> argument addresses a
block of foreign data that contains the 16-byte binary guid starting at
<i>offset</i> bytes within the block.<br>
<hr>

<a name="BOOL">
<b>bool</b><br>
Foreign Type<br>
A C boolean, i.e., 0 => false, non-zero => true.<br>
<hr>

<a name="BSTR">
<b>bstr</b><br>
Foreign Type<br>
The OLE BSTR type.<br>
<hr>

<a name="BSTRSTRING">
<b>bstr-string</b><i> bstr &optional release</i><br>
Function<br>
This function accepts a reference to a foreign bstr object and returns
a lisp string containing the same data.  If the optional <i>release</i>
argument is non-nil, the bstr will be freed by a call on SysFreeString.<br>
<hr>

<a name="CHECKRETURN">
<b>check-return</b><i> form &optional excepinfo</i><br>
Macro<br>
Expands to code that evaluates <i>form</i> and checks the result for
OLE success.  If the result indicates OLE failure, then ole-error is
called, passing it the failure result and the <i>excepinfo</i>, if any.<br>
<hr>

<a name="CLASSFACTORY">
<b>class-factory</b><br>
Class<br>
Instances of this class supply a Lisp wrapper for OLE object creation.
  The important slots are:<dl>
<dt>component-classid<dd>a guid that OLE will use to request the services
of this class factory.  It is specified by the :classid keyword arg
when a class-factory instance is created, and it remains constant for
the life of the class-factory instance.
<dt>registration-code<dd>an integer supplied by OLE when the class is
registered.
<dt>locked<dd>a status that can be read with lockedp.
<dt>children<dd>a list of active objects created by this factory.
<dt>product-class<dd>the symbol naming the Lisp class of objects
 manufactured by this class-factory object.  The product-class will be
a descendant of manufactured-object.  It is specified by the
:product-class initialization keyword when a class-factory instance is
created,
and it remains constant for the life of the class-factory instance.
<dt>allow-aggregation<dd>a boolean that specifies whether clients can
create instances with an outer-iunknown.  The default is nil, meaning
no outer-iunknown is allowed.  The initialization keyword
:allow-aggregation can be used to specify a non-default value.
</dl><br>
<hr>

<a name="CLOSECONTROL">
<b>close-control</b><i> control &optional mode</i><br>
Method: primary (ur-control)<br>
This method, applicable to controls, closes the control and releases
associated resources. The mode argument can be one of :nosave,
:save-if-dirty, or :promptsave, or one of the associated numeric codes which
are 1, 0, and 2, respectively, and defaults to :nosave<br>
<hr>

<a name="CLOSEREGISTRYKEY">
<b>close-registry-key</b><i> rkey</i><br>
Generic Function<br>
Called to close the open registry key <i>rkey</i>.<br>
<hr>

<b>close-registry-key</b><i> k</i><br>
Method: primary (registry-key)<br>
This releases the OLE resources associated with the key and changes
the argument's class so that it cannot again be used as a registry key.
Closing an already closed key or one of the root registry keys (rkey-...)
is legal and has no effect.<br>
<hr>

<a name="CODEGUID">
<b>code-guid</b><i> d &optional (w1 0) (w2 0) (w3 49152) (l 70)</i><br>
Function<br>
This function accepts integer arguments defining the components of
a guid and returns the associated lisp-guid.  The arguments specify
the components as they appear in the standard string representation,
roughly "{d-w1-w2-w3-l}".  The defaults allow compact expression of
the common Microsoft IIDs, e.g., IID_IUnknown can be designated by
<code>(code-guid 0 0 0 #xc000 #x0046)</code> or as
<code>(code-guid 0)</code>.<br>
<hr>

<a name="COMPUTEHIMETRICCONVERSION">
<b>compute-himetric-conversion</b><i> c</i><br>
Function<br>
Call to initialize the *pixel-xxx-himetric* globals from the argument's DC<br>
<hr>

<a name="CONNECTEVENTCHANNEL">
<b>connect-event-channel</b><i> this &key event-interface-class</i><br>
Method: primary (access-to-ole-control)<br>
This method opens the event channel for the control argument. If the
event-interface-class argument is present and non-nil, it names the
interface class to use, otherwise the object's event-interface-class slot
specifies the class to request. In either case the class must be one
of those legal for the object.<br>
<hr>

<a name="CONNECTIONENUMERATOR">
<b>connection-enumerator</b><br>
Class<br>
Supports the IEnumConnections interface for a ConnectionPoint object.<br>
<hr>

<a name="CONNECTIONPOINT">
<b>connection-point</b><br>
Class<br>
Instances of this class represent connection points to which external
clients can attach via the OLE IConnectionPoint interface.  A connection-point
might support more than one connection simultaneously, or might be limited to
one connection at a time, but it provides just one kind of interface to
its clients.  Connection-point objects are attached to an owning
connection-point-container object at creation time.<br>
<hr>

<a name="CONNECTIONPOINTCONTAINER">
<b>connection-point-container</b><br>
Class<br>
This OCX class supports the IConnectionPointContainer-server interface.
Each instance holds some set of IconnectionPoint objects that are ready to
support AdviseConnection calls.<br>
<hr>

<a name="CONNECTIONPOINTENUMERATOR">
<b>connection-point-enumerator</b><br>
Class<br>
This class provides IEnumConnectionPoints support for the
 connection-point-container class.<br>
<hr>

<a name="CONNECTSITE">
<b>connect-site</b><i> site</i><br>
Method: primary (site-mixin)<br>
This method makes sure the OCX server for the control installed in
this site is actually running and the object active.<br>
<hr>

<a name="CONNECTTOSERVER">
<b>connect-to-server</b><i> this &key inplace</i><br>
Method: primary (access-to-ole-control)<br>
This method makes sure the control argument (this) is being served. It
stamps the object with the *dumplisp-generation-tick* when it makes the connection,
and won't redo the connection unless called in a lisp with a different value
of *dumplisp-generation-tick*<br>
<hr>

<a name="CONTAINERMIXIN">
<b>container-mixin</b><br>
Class<br>
The mixin class to get container-specific behavior<br>
<hr>

<a name="CONTROL">
<b>control</b><br>
Class<br>
This class specializes remote-autotool to run an OCX control object in
a container.<br>
<hr>

<a name="CREATEINSTANCE">
<b>create-instance</b><i> what iid &key</i><br>
Generic Function<br>
Asks for a new instance or connection to an existing instance, and returns
the client interface object that results, if successful.  If unsuccessful,
returns a first value of nil and possibly other values describing the
reason for failure.
<dl><dt>what<dd>an interface for a class factory object, a lisp-guid for
a server, or a string naming a server.
<dt>iid<dd>A lisp-guid specifying the IID of the interface desired
<dt>outer<dd>an IUnknown interface object to be used as the controlling
IUnknown for the new object.  If omitted or nil the new object is independent.
<dt>context<dd>The class context (:local, :inproc, :active) desired for the server.
</dl><br>
<hr>

<b>create-instance</b><i> clsid iid &key outer context</i><br>
Method: primary (lisp-guid t)<br>
Asks for instance creation via CoCreateInstance or for an interface to an
active object via GetActiveObject.  Returns
the client interface object that results, if successful.  If unsuccessful,
returns two values: nil and the HRESULT from the attempted creation.<br>
<hr>

<b>create-instance</b><i> appname iid &key outer context</i><br>
Method: primary (string t)<br>
Asks for instance creation via CoCreateInstance.  The classid is
obtained from the registry entry for <i>appname</i>.  Returns
the client interface object that results, if successful.  If unsuccessful,
returns two values: nil and either the HRESULT from the attempted creation
or a string describing the error.<br>
<hr>

<b>create-instance</b><i> ifc iid &key outer context</i><br>
Method: primary (IClassFactory-client t)<br>
Asks for instance creation via IClassFactory.CreateInstance.  Returns
the client interface object that results, if successful.  If unsuccessful,
returns two values: nil and the HRESULT from the attempted creation.
The context keyword argument is ignored.<br>
<hr>

<b>create-instance</b><i> obj iid &key outer</i><br>
Method: primary (class-factory t)<br>
If the arguments are valid then a new instance of <i>obj</i>'s product-class is
created and queried for the interface specified by <i>iid</i>.<br>
<hr>

<a name="CY">
<b>cy</b><br>
Foreign Type<br>
The OLE CY (currency) type, a 64-bit integer, the represented value scaled by 10**4.<br>
<hr>

<a name="DATE">
<b>date</b><br>
Foreign Type<br>
The high-precision windows DATE type, a double-float.<br>
<hr>

<a name="DEFAUTOMETHOD">
<b>def-automethod</b><i> method ((arg-obj class)
                                 (arg-dispid dispid)
                                 &rest
                                 more) &body body</i><br>
Macro<br>
This macro expands into code that defines an IDispatch method, a specialization of
auto-method.
<dl>
<dt>method<dd>The name of the method, as exported via Dispid mapping.
<dt>arg-obj<dd>The symbol naming the object parameter to auto-method, for use in the method body.
<dt>class<dd>A subclass of automaton which is to support this method.
<dt>arg-dispid<dd>The symbol naming the dispid parameter to auto-method, for use in the method
body.
<dt>dispid<dd>The (integer) dispid that is to invoke this method.
<dt>more<dd>Should be <i>&rest somename</i> to match the generic function definition.
<dt>body<dd>The body of the method.  Whatever value it computes will be returned as the
result of the IDispatch method invocation.
</dl><br>
<hr>

<a name="DEFCLIENTINTERFACE">
<b>def-client-interface</b><i> iname &optional (documentation
                                                "Client interface class.") &key direct (release-heap
                                                                                        :never) (release-heap-when-ok
                                                                                                 nil) (release-heap-never
                                                                                                       nil) (release-heap-always
                                                                                                             nil) (package
                                                                                                                   (symbol-package
                                                                                                                    iname))</i><br>
Macro<br>
This macro expands into the code needed to
<ol>
<li>define all the client-side linkage functions for the named interface;
<li>load the client library code for the base interface, if any;
<li>define the CLOS class for the client interfaces;
<li>initialize the iid global symbol, if any.
</ol>
Symbols created for methods and classes will be interned in the package
of <i>iname</i>, the symbol naming the interface.
<br>
If the :direct keyword is specified, it provides a list of methods
in the interface that are to be declared :call-direct.
<br>
The :release-heap-always, :release-heap-never and :release-heap-when-ok
keywords specify which methods use which calling paradigm.
The values are lists of method names to get the specified treatment.
<br>
The :release-heap keyword specifies the release-heap value to be used in
the foreign-call definitions of all methods not named explicitly in one
of :release-heap-never, :release-heap-always, or :release-heap-when-ok.
The default is :never.<br>
<hr>

<a name="DEFIID">
<b>defiid</b><i> name &optional d (w1
                                   0) (w2 0) (w3 49152) (l 70)</i><br>
Macro<br>
The form (defiid name) is used to declare that name is a global symbol
whose value is an iid, but which is given a value in some other place.
When specified with one or more values the defiid form expands to code
that sets the variable's value to a lisp-guid for the specified iid.
The value can be specified as a string, as in
<br><pre><code>
(defiid IID_IClassFactory "{00000001-0000-0000-C000-000000000046}")
</code></pre><br>
Or numerically, as in the equivalent
<br><pre><code>
(defiid IID_IClassFactory 1 0 0 #xc000 #x0046)
</code></pre><br>
The w1, w2, w3 and l arguments all default to the most common values
for Microsoft iid's, so that the last could be specified as
<br><pre><code>
(defiid IID_IClassFactory 1)
</code></pre><br>
This macro is rarely used, since the def-ole-interface macro includes
this facility.<br>
<hr>

<a name="DEFOCXCLASS">
<b>def-ocx-class</b><i> name supers slots &rest rest</i><br>
Macro<br>
This macro is an extended and specialized defclass.  The extension is that
<i>supers</i>, the list of superclasses, can contain the keyword
:interfaces.  If it does, the keyword is removed from the list of superclasses
as far as the defclass is concerned.  The names after the :interfaces
keyword are interpreted as interface names, and code is generated to
require the associated server library code for each one.  Each entry after the
:interfaces keyword can be an interface name or a list of interface names.
If the entry is a list, then it means the ocx-class will support all the
interfaces named in the list, but will actually provide an interface of the
first class named in the list when asked for any of the other interfaces in
that list.  The list of interfaces need not explicitly include IUnknown
as IUnknown is a superclass of every interface.<br>
The specialization is that lisp-ole-object
is always added as a last super-class before the interface classes.
The effect is that the defined class supports IUnknown and its methods,
and can build server side interfaces for all the named interface classes and
for all their ancestral interface classes.<br>
<hr>

<a name="DEFOLEINTERFACE">
<b>def-ole-interface</b><i> iname &rest methods-and-stuff</i><br>
Macro<br>
This macro provides a definition for an OLE interface.  This definition
is entered in a database that is available to the compiler when it
processes def-client-interface and def-server-interface macros.
<i>Iname</i> is the interface name, e.g., IUnknown or ITypeLib.  The
first entries after <i>iname</i> are keywords and (keyword value) pairs
that affect the interface as a whole.  After these come method definitions.
The keywords and keyword-value entries can appear in any order, but none
can be duplicated in the same def-ole-interface form.  These keywords are:<br>
<dl>
<dt>:enumerator</dt>
<dd>Specifies that this interface is an enumerator, inheriting from the
standard enumerator interface.  Cannot be combined with the :base
keyword.</dd>
<dt>(:base symbol)</dt>
<dd>Specifies the interface from which this interface inherits.  The base
interface must already be defined, but not necessarily loaded; the compiler
will attempt to load needed definitions from the OLE definition library.
The default base interface is IUnknown, which is almost
always the right value.  Specifying nil means there is no base interface,
which would only be appropriate for the IUnknown interface.  This keyword
cannot be specified if the :enumerator keyword is present.</dd>
<dt>(:iid ...)</dt>
<dd>Specifies the interface id for this interface.  The id can be specified in
string form, as (:iid "{009541a0-3b81-101c-92f3-040224009c02}") or as a
set of integer components, as (:iid #x300 0 0 #xc000 #x0046).  In the
latter case, elements after the first default to 0, 0, #xc000 and #x0046,
in order, the most common entries for Microsoft OLE.  For
example, the short entry for IClassFactory would be (:iid 1).</dd>
<dt>(:iidname symbol)</dt>
<dd>Specifies a symbol to be made a global variable whose value
is the (Lisp) guid structure for this iid.  The default is to prefix IID_
in front of the interface name, as in IID_IUnknown.  A non-nil symbol named
here replaces the default symbol.  Specifying nil suppresses the creation
vof a global symbol holding the guid.</dd>
<dt>(:client-class symbol)</dt>
<dd>Specifies the name of the CLOS class whose instances are clients for
this interface.  The default is to suffix -client after the interface
name, as in IClassFactory-client.</dd>
<dt>(:server-class symbol)</dt>
<dd>Specifies the name of the CLOS class whose instances are servers for
this interface.  The default is to suffix -server after the interface
name, as in IClassFactory-server.</dd>
<dt>(:for-library boolean)</dt>
<dd>This entry controls whether the interface definition is to be part of the
output of this compilation (:for-library t) or just used while compiling
this file (:for-library nil).  The (:for-library t) case is appropriate
when the only thing in the source file is the def-ole-interface form
(and probably an in-package form).  The def-client-interface and/or
def-server-interface forms would then appear in other files and the compiler
would need to load the def-ole-interface data to process them.  The
(:for-library nil) case is the default and is appropriate when the
def-client-interface and/or def-server-interface form(s) appear in the
same file as the def-ole-interface form.</dd></dl><br>
<hr>

<a name="DEFOLELINKAGE">
<b>def-ole-linkage</b><i> package &rest keys-and-values</i><br>
Macro<br>
This macro loads a typelib specified by the keyword arguments and
expands into a form that defines the lisp linkage to the objects described
in that typelib. The form defines a package whose name is given as the
<i>package</i>. Symbols exported from that package name classes and methods
corresponding to the elements of the typelib's objects.<br>
<hr>

<a name="DEFSERVERINTERFACE">
<b>def-server-interface</b><i> name &key (mixin-class
                                          name) (mixin-class-documentation
                                                 "Allegro Active mixin class.") (interface-class-documentation
                                                                                 "Server interface class.") (package
                                                                                                             (symbol-package
                                                                                                              name)) (method-transforms
                                                                                                                      nil)</i><br>
Macro<br>
This macro expands into code that
<ol>
<li>defines the Vtable needed to serve this interface;
<li>initializes the global iid symbol, if any
<li>loads the server library code for the base interface, if any;
<li>defines the CLOS class for the server interfaces;
<li>defines the mixin class for Allegro active objects that wish to provide this
interface.
</ol>
Symbols created for methods and classes will be interned in the package
of <i>name</i>, the symbol naming the interface.
<br>
The vtable for an object served by Allegro is a vector of pointers to
linkage functions, one for each method in the interface.  These linkage
functions always receive the pInterface value for the interface as their
first argument.  The default action for any linkage function is to
call a function with the same name as the method and return the result
to the external caller.  The arguments used in this call are,
first, the unique server interface object associated with the incoming
pInterface value, and then the integer values coming in as arguments to
the linkage function.  With no extra programmer effort the
linkage function for IUnknown.AddRef will evaluate
<pre><code>
    (AddRef (find-the-server-interface-for pInterface))
</code></pre>
It is often convenient to have the worker function call something other
than the default function.  Name clashes can make this desirable, for
example.  It is also often the case that an argument coming in to the
linkage function is a pointer to data rather than an integer value.
An example is a pointer to a guid coming in to the QueryInterface method.
In this case it might be useful to perform some conversion in the
linkage function and pass Lisp data to the worker function.
<br>
The :method-transforms keyword allows specialized linkage to be defined
for any of the interface's methods.  The value after the
:method-transforms keyword must be a list of lists, each one modifying
one of the methods defined for the interface.  Each of these modification
entries consists of a list of two elements, the symbol naming the method
and a specification of the transform to be applied.
<br>
This transformation is specified as a list, the first element being the
worker function to call and the remainder defining how to treat each
incoming argument after the first.  No specification is needed or
possible for the first since it is always converted from a pInterface
value to a Lisp server-interface object.  The argument order is not
changed by the transform.  Instead, each argument after the first is
either passed to the worker function unchanged or is transformed before
being passed to the worker function.  Each argument's treatment
is specified as a form in which the symbol * represents the value
actually received for that argument. So a * by itself says to pass that
argument unchanged (foo *) says to call foo on that argument value and
pass the result to the worker function.  Any Lisp form can appear.
(not (eql * 0)), for example, would convert a c-style boolean to a Lisp
boolean.<br>
Another example:
<pre>
<code>
(def-server-interface IUnknown
   :method-transforms
   ((QueryInterface (bxg-fad (binary-guid *) *))))
</code>
</pre>
says that only the QueryInterface method for IUnknown-server objects is
nonstandard.  Its foreign-callable linkage function calls
bxg-fad with three arguments.  The first argument to bxg-fad is, of course,
the xxx-server object associated with the 
incoming pInterface value.  The second argument to bxg-fad is computed by
calling binary-guid on the second argument coming in to the worker function.
The third argument to bxg-fad is just the incoming third argument, unmodified.
<br>
In either case, whether the default method or a transform is used, the
(integer) value returned from the function is passed on back to the caller.
<br>
By default, the mixin class has the same name as the interface,
but this can be overridden with the :mixin-class keyword.  Any Allegro active
class that inherits from a server interface mixin class will automatically
be able to respond to QueryInterface calls for the corresponding IID.
<br>
<i>Note: currently, the :mixin-class keyword cannot be used to change the
name of the mixin class.</i><br>
<hr>

<a name="DELETEREGISTRYVALUE">
<b>delete-registry-value</b><i> key name &optional path</i><br>
Generic Function<br>
This function removes a specified name and its value from
a specified registry entry.  The registry entry is designated by
giving a starting key, <i>key</i>, and an optional <i>path</i>.  The
<i>path</i> argument can be a string or a list of strings.  If omitted or
nil it causes the <i>key</i> argument to be the registry entry to search.
If the <i>name</i>d value is found in that registry entry then the name
and associated value are removed from the registry.<br>
<hr>

<a name="DESTROYSAFEARRAY">
<b>destroy-safearray</b><i> v</i><br>
Function<br>
The argument <i>v</i> can be a lisp-safearray or an OLE safearray
reference.  If the latter, the argument is freed via a call to OLE's
SafeArrayDestroy.  If the former, the associated OLE safearray is destroyed
and the lisp-safearray is marked as empty.<br>
<hr>

<a name="DISCONNECT">
<b>disconnect</b><i> access-to-control</i><br>
Generic Function<br>
Releases all OLE resources supporting the argument.<br>
<hr>

<b>disconnect</b><i> this</i><br>
Method: primary (access-to-ole-control)<br>
This method disconnects the object's event channels and releases
the object's main interface.<br>
<hr>

<b>disconnect</b><i> channel</i><br>
Method: primary (control-event-channel)<br>
This method unadvises the associated connection point, then releases it.<br>
<hr>

<a name="DISPIDNAMES">
<b>dispid-names</b><i> object lcid</i><br>
Generic Function<br>
This function is called to get the mapping data that converts names to
dispids.  Each subclass of IDispatch should provide a primary method that
returns a list of the following form, possibly taking into account the
locale specified by lcid:<br>
The mapping must be a list of lists.  The first element of each sublist
is a string or symbol naming an operation or property; the second element
must be the integer dispid for that named operation or property.  Subsequent
elements, if any, provide the  from argument names to dispids for that
particular operation.  For example,  entry in the list that looks like this
<pre>
<code>(decode 123 (rehash 9) (flights 27))</code>
</pre>
says that the decode operation has dispid 123 and that when used with decode,
the names rehash and flights are represented by dispids 9 and 27,
respectively.  Note that the same name may represent different dispids when
used as an argument name for different operations.<br>
<hr>

<b>dispid-names</b><i> obj lcid</i><br>
Method: primary (IDispatch t)<br>
If nothing more specific applies, there is no mapping information.<br>
<hr>

<b>dispid-names</b><i> obj lcid</i><br>
Method: primary (automaton t)<br>
The default for an automaton supplies the dispids from the slot defs when lcid
is LOCALE_SYSTEM_DEFAULT, nil otherwise.<br>
<hr>

<a name="DOASPROCESS">
<b>do-as-process</b><i> (&key (suppress-start-stop nil)
                         (ide (find-package :ide))
                         (name
                          '(format nil "ole-process-~d"
                                   (incf ole-process-name-counter)))
                         (gate-symbol (gensym))) &rest body</i><br>
Macro<br>
This macro expands into code to run the forms of <i>body</i> in a separate
process, releasing the client interfaces created by that process.
The process executing the form will wait until the separate process completes.
The do-as-process form evaluates to nil.
Unless <i>suppress-start-stop</i> is specified and non-nil, the <i>body</>
forms will be preceded by a call to start-ole and followed by a call to
stop-ole. If the form is expanded in an ide environment and the <i>ide</i>
argument is not specified as nil, then the separate process will have initial
bindings to allow the ide debugger to be invoked for errors. The <i>name</i>
argument can be used to specify a form to evaluate (in the macro's environment)
to get a name for the process. It defaults to a numbered generic name.
The macro expansion allocates a gate for synchronization. The
<i>gate-symbol</i> argument, if specified, must be a symbol that will be
bound to the gate while the <i>body</i> forms are evaluated.
<br>
<hr>

<a name="DOCUMENTMIXIN">
<b>document-mixin</b><br>
Class<br>
This class is a superclass of all OLE document objects.  Document objects
correspond to application forms that can hold embeddable objects or controls.
See the <a href="ole.htm">Allegro ActiveX documentation</a> for details.<br>
<hr>

<a name="DOREGISTRYSUBKEYNAMES">
<b>do-registry-subkey-names</b><i> (var
                                    keyform
                                    &optional
                                    retform) &body body</i><br>
Macro<br>
This macro expands to code that loops over the subkeys of a registry
key, evaluating the body with the loop variable bound to each subkey name
in turn.  The key whose subkeys are to be scanned is specified by the
<i>keyform</i>, which must evaluate to a registry key that is open for
reading.  The <i>body</i> forms are evaluated with the <i>var</i>
symbol let-bound to the name (a string) of each subkey in turn.  When there
are no more subkeys left, the <i>retform</i> is evaluated and the result
returned as the value of the do-registry-subkey-names form.
<dl>
<dt>var<dd>a symbol naming the variable to be let-bound during the iteration
<dt>keyform<dd>a form evaluating to a registry key open for reading
<dt>retform<dd>a form to be evaluated when there are no more subkey names
<dt>body<dd>an implicit loop body to be evaluated once for each iteration
</dl><br>
<hr>

<a name="DOREGISTRYVALUENAMES">
<b>do-registry-value-names</b><i> (var
                                   keyform
                                   &optional
                                   retform) &body body</i><br>
Macro<br>
This macro expands to code that loops over the values of a registry
key, evaluating the body with the loop variable bound to a description of
each value in turn.  The key whose values are to be scanned is specified by the
<i>keyform</i>, which must evaluate to a registry key that is open for
reading.  The <i>body</i> forms are evaluated with the <i>var</i>
symbol let-bound to a list of the name (a string) and the type (a keyword)
of each value in turn.  When there
are no more values left, the <i>retform</i> is evaluated and the result
returned as the value of the do-registry-value-names form.
<dl>
<dt>var<dd>a symbol naming the variable to be let-bound during the iteration
<dt>keyform<dd>a form evaluating to a registry key open for reading
<dt>retform<dd>a form to be evaluated when there are no more subkey names
<dt>body<dd>an implicit loop body to be evaluated once for each iteration
</dl><br>
<hr>

<a name="ENUMERATECONNECTIONPOINTS">
<b>enumerate-connection-points</b><i> object</i><br>
Generic Function<br>
Returns an enumerator for the connection points of the
connection point container <i>object</i>.<br>
<hr>

<b>enumerate-connection-points</b><i> ifc</i><br>
Method: primary (IConnectionPointContainer-client)<br>
Returns an IEnumConnectionPoints-client enumerator interface for
 <i>ifc</i>.<br>
<hr>

<a name="ENUMERATECONNECTIONS">
<b>enumerate-connections</b><i> object</i><br>
Generic Function<br>
Returns an enumerator for the connection point <i>object</i><br>
<hr>

<b>enumerate-connections</b><i> ifc</i><br>
Method: primary (IConnectionPoint-client)<br>
Invokes IConnectionPoint.EnumConnections to acquire a connection
enumerator for <i>ifc</i>.<br>
<hr>

<b>enumerate-connections</b><i> cp</i><br>
Method: primary (connection-point)<br>
Returns a connection-enumerator for <i>cp</i>.<br>
<hr>

<a name="ENUMERATORCLONE">
<b>enumerator-clone</b><i> object</i><br>
Generic Function<br>
Returns a clone of the current state of the argument enumerator.
This function gets called to deal with IEnumxxx.Clone method calls
for classes that inherit from IEnumxxx.  An appropriate method must
exist for each subclass of IEnumxxx.<br>
<hr>

<b>enumerator-clone</b><i> ifc</i><br>
Method: primary (IEnumxxx-client)<br>
This invokes the x.Clone method on the client interface, then
creates a new instance of the enumerator's class to hold the resulting
pInterface, returning that Lisp object.<br>
<hr>

<b>enumerator-clone</b><i> enum</i><br>
Method: primary (connection-point-enumerator)<br>
Clone code for connection-point-enumerator objects.<br>
<hr>

<b>enumerator-clone</b><i> enum</i><br>
Method: primary (connection-enumerator)<br>
Clone code for connection-enumerator objects.<br>
<hr>

<b>enumerator-clone</b><i> enum</i><br>
Method: primary (advise-enumerator)<br>
Clone code for advise-enumerator objects.<br>
<hr>

<a name="ENUMERATORINTERFACEIID">
<b>enumerator-interface-iid</b><i> enumerator</i><br>
Generic Function<br>
This generic function is called to obtain the IID associated with an
   enumerator object.  Methods must be provided so that this function
responds correctly for instances of every subclass of IEnumxxx-server.<br>
<hr>

<a name="ENUMERATORNEXT">
<b>enumerator-next</b><i> interface reqct outbuffer</i><br>
Generic Function<br>
This function asks the enumerator available via <i>interface</i> to
copy up to <i>reqct</i> items into the <i>outbuffer</i>.
The destination buffer should be in foreign space or on the stack,
but if a binary-element Lisp vector is supplied, and doesn't move during
the function call, that is acceptable, too.  The function returns
the number of elements actually placed in the buffer.<br>
<hr>

<b>enumerator-next</b><i> ifc reqct outbuffer</i><br>
Method: primary (IEnumxxx-client t t)<br>
This method invokes <i>ifc</i>'s x.Next method to retrieve the
requested data.<br>
<hr>

<a name="ENUMERATORRESET">
<b>enumerator-reset</b><i> object</i><br>
Generic Function<br>
This function is called to reset the enumerator available via
<i>object</i> back to its initial state.  An appropriate method must
exist for each subclass of IEnumxxx.<br>
<hr>

<b>enumerator-reset</b><i> ifc</i><br>
Method: primary (IEnumxxx-client)<br>
This just invokes the x.Reset method on the client interface <i>ifc</i>.<br>
<hr>

<a name="ENUMERATORSKIP">
<b>enumerator-skip</b><i> object count</i><br>
Generic Function<br>
This function is called to have the enumerator <i>object</i>
skip past the next <i>count</i> elements without returning them.<br>
<hr>

<b>enumerator-skip</b><i> ifc reqct</i><br>
Method: primary (IEnumxxx-client t)<br>
This just invokes the x.Skip method on the client interface object.<br>
<hr>

<b>enumerator-skip</b><i> obj skipct</i><br>
Method: primary (IEnumxxx t)<br>
This method invokes enumerator-step with NULL (0) pointers to
inhibit copying data.<br>
<hr>

<a name="ENUMERATORSTEP">
<b>enumerator-step</b><i> enumerator cpointer</i><br>
Generic Function<br>
This function is called by pieces of the IEnumxxx system to process the
   next element of the enumeration.  The first argument is the enumerator
   object in question, an instance of some subclass of IEnumxxx.  The cpointer
   argument is either 0 or an address where data is to be placed.  Each
   subclass of IEnumxxx must define a method for this GF specializing
   on the type of the enumerator argument.  The method must return the
   length, in bytes, of the next element in the enumeration, or 0 if
   there are no more elements to be enumerated.  If the return value is
   non-zero and the cpointer is non-zero then the method must also place
   the appropriate representation of the element in the area addressed by
   cpointer.  Finally, the method must adjust the internal state of the
   enumerator to skip over the element returned, so that the next call
   will return the element after it.<br>
   There are no default methods for this generic function; each subclass
   of IEnumxxx must define its own method.<br>
<hr>

<a name="EVENTTRACING">
<b>event-tracing</b><i> control &optional interface</i><br>
Generic Function<br>
Setf-able. Defaults to nil. Can be set on individual event channels
 to get low-level event tracing.<br>
<hr>

<b>event-tracing</b><i> this &optional interface</i><br>
Method: primary (access-to-ole-control)<br>
Applied to an object that represents a control; <i>interface</i> can be omitted,
or the name of an interface, e.g. xxx:DWebBrowser2. When reading the state,
the control must have a unique channel or <i>interface</i> must specify one
of those attached to the object. When setting the state, omitting  <i>interface</i>
directs the function to set the state of all the object's channels.<br>
<hr>

<b>(setf event-tracing)</b><i> val this &optional interface</i><br>
Method: primary (t access-to-ole-control)<br>
Set the event-tracing attribute of either the specified channel, when
<i>interface</i> is present, or all event channels, when <i>interface</i> is
omitted.<br>
<hr>

<a name="EXCEPINFO">
<b>excepinfo</b><br>
Foreign Type<br>
The OLE EXCEPINFO structure.<br>
<hr>

<a name="EXCEPTIONINFO">
<b>exception-info</b><br>
Class<br>
An object of this class carries excepinfo data<br>
<hr>

<a name="EXECUTIONERROR">
<b>execution-error</b><br>
Class<br>
A class of errors signaled by OLE code, a subclass of error<br>
<hr>

<a name="EXTENDEDINCOMINGERROR">
<b>extended-incoming-error</b><br>
Class<br>
An error class associated with bad HRESULT codes
returned from OLE calls, and carrying excepinfo data.
A subclass of incoming-error and exception-info.<br>
<hr>

<a name="FACTORYIDLE">
<b>factory-idle</b><i> factory</i><br>
Generic Function<br>
Called when the last child of a factory is released and the factory is not locked.<br>
<hr>

<b>factory-idle</b><i> factory</i><br>
Method: primary (class-factory)<br>
The default method does nothing.<br>
<hr>

<a name="FAILURE">
<b>failure</b><i> hr</i><br>
Macro<br>
Expands to code that evaluates the form <i>hr</i> and tests the
(integer) result, returning true if and only if it is an OLE failure code.<br>
<hr>

<a name="FILEISSTORAGEP">
<b>file-is-storage-p</b><i> s</i><br>
Function<br>
Accepts a string naming a file.  Returns non-nil if and only if
the file is formatted as a storage.<br>
<hr>

<a name="FINDCONNECTIONPOINT">
<b>find-connection-point</b><i> object iid</i><br>
Generic Function<br>
Returns the connection point that <i>object</i> provides for the
interface identified by <i>iid</i>.  The <i>iid</i> argument must be a
lisp-guid object.  If <i>object</i> does not provide a connection point
of the requested type, this function returns nil.<br>
<hr>

<b>find-connection-point</b><i> ifc guid</i><br>
Method: primary (IConnectionPointContainer-client t)<br>
Uses IConnectionPointContainer.FindConnectionPoint to obtain a
connection point.  If there is one, this method returns an
IConnectionPoint-client interface for it, otherwise it returns nil.<br>
<hr>

<a name="FORMATIDL">
<b>format-idl</b><i> outfilename &optional (typelib
                                            (car
                                             loaded-typelibs))</i><br>
Function<br>
This function writes an idl file for a typelib internalized by lisp. The
<i>outfilename</i> argument is a string naming the place to write the idl file.
The <i>typelib</i> argument is a lisp-typelib, the result of, for example, a
call to load-typelib. If <i>typelib</i> is omitted, the last loaded typelib
is the source for the generated idl.<br>
<hr>

<a name="FRAMEMIXIN">
<b>frame-mixin</b><br>
Class<br>
This class is a superclass of all OLE container objects.  Container objects
correspond to applications that use embeddable objects or controls.
See the <a href="ole.htm">Allegro ActiveX documentation</a> for details.<br>
<hr>

<a name="FREEBSTR">
<b>free-bstr</b><i> bstr</i><br>
Function<br>
The argument to free-bstr must be a reference (address) to a bstr object
allocated by string-bstr or obtained from some external source.  Unless the
reference is the NULL pointer 0, SysFreeString is called to free the foreign
data.<br>
<hr>

<a name="FREEUNICODE">
<b>free-unicode</b><i> c</i><br>
Function<br>
The argument must be a unicode item allocated by string-unicode.  Its
memory is freed.  Do not call free-unicode on data allocated using
with-foreign-data or with-unicode-argument.<br>
<hr>

<a name="GETCLASSOBJECT">
<b>get-class-object</b><i> classid context iid</i><br>
Function<br>
Calls CoGetClassObject to ask for access to an OLE component.
The component is identified by its classid and context, the desired
interface by its IID. If the CoGetClassObject call is successful then
the new client interface object is returned; otherwise the function returns
two values: nil and the HRESULT from the CoGetClassObject call.
<dl><dt>classid<dd>The guid for the desired class.  Can be specified
as a lisp-guid, a binary guid (in foreign space, i.e., by address), or
a string in the standard format, i.e., {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}.
<dt>context<dd>one or more of the following values or'ed together:<ul>
<li>CLSCTX_INPROC_SERVER
<li> CLSCTX_INPROC_HANDLER
<li> CLSCTX_LOCAL_SERVER
<li> CLSCTX_REMOTE_SERVER
</ul>
<dt>iid<dd>A lisp-guid specifying the desired interface on the object.
</dl><br>
<hr>

<a name="GETCONNECTIONCONTAINER">
<b>get-connection-container</b><i> object</i><br>
Generic Function<br>
Returns the connection point container that owns <i>object</i>.<br>
<hr>

<b>get-connection-container</b><i> ifc</i><br>
Method: primary (IConnectionPoint-client)<br>
Invokes IConnectionPoint.GetConnectionPointContainer to return an
IConnectionPointContainer-client interface.<br>
<hr>

<a name="GETCONNECTIONINTERFACE">
<b>get-connection-interface</b><i> object</i><br>
Generic Function<br>
Returns the lisp-guid object for the iid offered by the argument.<br>
<hr>

<b>get-connection-interface</b><i> ifc</i><br>
Method: primary (IConnectionPoint-client)<br>
Invokes IConnectionPoint.GetConnectionInterface and returns the unique
lisp-guid corresponding to the result.<br>
<hr>

<b>get-connection-interface</b><i> cp</i><br>
Method: primary (connection-point)<br>
Returns the lisp-guid for <i>cp</i>.<br>
<hr>

<a name="GETTYPEATTR">
<b>get-type-attr</b><i> ifc &key use-registry check-native displaced-guid</i><br>
Method: primary (ITypeInfo-client)<br>
Calls several ITypeInfo methods and returns a lisp-typeinfo structure that
holds the retrieved information.<br>
<hr>

<a name="GETTYPEINFO">
<b>get-type-info</b><i> object index &key locale</i><br>
Generic Function<br>
Asks for the indexed entry in the object's typeinfo structure.
Signals an error if the entry does not exist.  The index value must
be less than the number returned from get-type-info-count.<br>
<hr>

<b>get-type-info</b><i> ifc i &key locale</i><br>
Method: primary (IDispatch-client t)<br>
This method uses ifc's IDispatch.GetTypeInfo method to construct
an ITypeInfo-client interface for ifc's i-th typeinfo element.<br>
<hr>

<b>get-type-info</b><i> tool i &key locale</i><br>
Method: primary (remote-autotool t)<br>
This is reflected to <i>tool</i>'s IDispatch interface.<br>
<hr>

<a name="GETTYPEINFOCOUNT">
<b>get-type-info-count</b><i> object</i><br>
Generic Function<br>
Returns the number of TypeInfo entries available for
<i>object</i><br>
<hr>

<b>get-type-info-count</b><i> ifc</i><br>
Method: primary (IDispatch-client)<br>
Calls IDispatch.GetTypeInfoCount and returns the result.<br>
<hr>

<b>get-type-info-count</b><i> tool</i><br>
Method: primary (remote-autotool)<br>
This is reflected to <i>tool</i>'s IDispatch interface.<br>
<hr>

<b>get-type-info-count</b><i> obj</i><br>
Method: primary (automaton)<br>
The default method for automatons says there's no type info.<br>
<hr>

<a name="GUID">
<b>guid</b><br>
Foreign Type<br>
The OLE guid type in foreign space.<br>
<hr>

<a name="GUIDBINARY">
<b>guid-binary</b><i> lisp-guid</i><br>
Function<br>
Returns a reference to (i.e., integer address of) the foreign-allocated
binary form of the lisp-guid argument.<br>
<hr>

<a name="GUIDNAME">
<b>guid-name</b><i> lisp-guid</i><br>
Function<br>
Returns a Lisp string containing the standard human-readable form of
the lisp-guid argument.<br>
<hr>

<a name="GUIDP">
<b>guid-p</b><i> object</i><br>
Function<br>
Returns true if and only if the argument is a lisp-guid object.<br>
<hr>

<a name="GUIDTYPEINFO">
<b>guid-typeinfo</b><i> ifc guid</i><br>
Method: primary (ITypeLib-client t)<br>
Calls ITypeLib.GetTypeInfoOfGuid, returning the ITypeInfo-client interface
if the call is successful, nil otherwise.<br>
<hr>

<a name="GUIDTYPELIB">
<b>guid-typelib</b><i> guid &key (major-version
                                  1) (minor-version
                                      0) (locale
                                          *ole-locale*) (error-ret
                                                         nil
                                                         errorp)</i><br>
Function<br>
Returns an ITypeLib-client interface for the registered typelibrary with
the given guid, versions, and locale.  If the specified library is not
available, then an error is signaled unless the error-ret keyword argument
is specified, in which case the error-ret value is returned.<br>
<hr>

<a name="H">
<b>h</b><i> f</i><br>
Macro<br>
Expands into code to evaluate <i>f</i> and return the OLE 'handle'
associated with the result.  Typically the value of <i>f</i> is an
interface object and (h <i>f</i>) is the associated pInterface value.<br>
<hr>

<a name="HRESULT">
<b>hresult</b><i> obj</i><br>
Generic Function<br>
Returns the hresult value associated with an error object.<br>
<hr>

<b>hresult</b><i> (obj incoming-error)</i><br>
Method: nil Returns the hresult value that caused obj to be created.<br>
nil<br>
<hr>

<a name="HRESULTCODE">
<b>hresult-code</b><i> hr</i><br>
Macro<br>
Expands to code that evaluates the form <i>hr</i> and extracts the
OLE hresult CODE portion.<br>
<hr>

<a name="HRESULTFACILITY">
<b>hresult-facility</b><i> hr</i><br>
Macro<br>
Expands to code that evaluates the form <i>hr</i> and extracts the
OLE hresult FACILITY portion.<br>
<hr>

<a name="ICLASSFACTORY">
<b>IClassFactory</b><br>
Class<br>
Allegro Active mixin class.<br>
<hr>

<a name="ICLASSFACTORYCLIENT">
<b>IClassFactory-client</b><br>
Class<br>
Client interface class.<br>
<hr>

<a name="ICLASSFACTORYSERVER">
<b>IClassFactory-server</b><br>
Class<br>
Server interface class.<br>
<hr>

<a name="ICONNECTIONPOINT">
<b>IConnectionPoint</b><br>
Class<br>
Allegro Active mixin class.<br>
<hr>

<a name="ICONNECTIONPOINTCLIENT">
<b>IConnectionPoint-client</b><br>
Class<br>
Client interface class.<br>
<hr>

<a name="ICONNECTIONPOINTCONTAINER">
<b>IConnectionPointContainer</b><br>
Class<br>
Allegro Active mixin class.<br>
<hr>

<a name="ICONNECTIONPOINTCONTAINERCLIENT">
<b>IConnectionPointContainer-client</b><br>
Class<br>
Client interface class.<br>
<hr>

<a name="ICONNECTIONPOINTCONTAINERSERVER">
<b>IConnectionPointContainer-server</b><br>
Class<br>
Server interface class.<br>
<hr>

<a name="ICONNECTIONPOINTSERVER">
<b>IConnectionPoint-server</b><br>
Class<br>
Server interface class.<br>
<hr>

<a name="IDISPATCH">
<b>IDispatch</b><br>
Class<br>
Allegro Active mixin class.<br>
<hr>

<a name="IDISPATCHCLIENT">
<b>IDispatch-client</b><br>
Class<br>
<br>
<hr>

<a name="IDISPATCHINVOKEEXCEPTION">
<b>idispatch-invoke-exception</b><br>
Class<br>
An object of this class is created to signal an
exception in an auto-method.<br>
<hr>

<a name="IDISPATCHSERVER">
<b>IDispatch-server</b><br>
Class<br>
Server interface class.<br>
<hr>

<a name="IENUMCONNECTIONPOINTS">
<b>IEnumConnectionPoints</b><br>
Class<br>
Allegro Active mixin class.<br>
<hr>

<a name="IENUMCONNECTIONPOINTSCLIENT">
<b>IEnumConnectionPoints-client</b><br>
Class<br>
Client interface class.<br>
<hr>

<a name="IENUMCONNECTIONPOINTSSERVER">
<b>IEnumConnectionPoints-server</b><br>
Class<br>
Server interface class.<br>
<hr>

<a name="IENUMCONNECTIONS">
<b>IEnumConnections</b><br>
Class<br>
Allegro Active mixin class.<br>
<hr>

<a name="IENUMCONNECTIONSCLIENT">
<b>IEnumConnections-client</b><br>
Class<br>
Client interface class.<br>
<hr>

<a name="IENUMCONNECTIONSSERVER">
<b>IEnumConnections-server</b><br>
Class<br>
Server interface class.<br>
<hr>

<a name="IENUMXXX">
<b>IEnumxxx</b><br>
Class<br>
This is a base class for all enumerator mixin classes.  It provides
default behavior for the standard enumerator operations.<br>
<hr>

<a name="IENUMXXXCLIENT">
<b>IEnumxxx-client</b><br>
Class<br>
This is a base class for all client enumerator interface classes.  It
provides default behavior for the standard enumerator operations.<br>
<hr>

<a name="IENUMXXXSERVER">
<b>IEnumxxx-server</b><br>
Class<br>
This is a base class for all enumerator server interface classes.
It provides default behavior for the standard enumerator operations.<br>
<hr>

<a name="IIDCLIENTINTERFACETYPE">
<b>iid-client-interface-type</b><i> iid</i><br>
Function<br>
This function returns the name of the client interface class associated
with the lisp-guid <i>iid</i>.  If there is no associated client interface
class, then an error is signalled.<br>
<hr>

<a name="IIDICLASSFACTORY">
<b>IID_IClassFactory</b><br>
OLE IID<br>
{00000001-0000-0000-c000-000000000046}<br>
<hr>

<a name="IIDICONNECTIONPOINT">
<b>IID_IConnectionPoint</b><br>
OLE IID<br>
{b196b286-bab4-101a-b69c-00aa00341d07}<br>
<hr>

<a name="IIDICONNECTIONPOINTCONTAINER">
<b>IID_IConnectionPointContainer</b><br>
OLE IID<br>
{b196b284-bab4-101a-b69c-00aa00341d07}<br>
<hr>

<a name="IIDIENUMCONNECTIONPOINTS">
<b>IID_IEnumConnectionPoints</b><br>
OLE IID<br>
{b196b285-bab4-101a-b69c-00aa00341d07}<br>
<hr>

<a name="IIDIENUMCONNECTIONS">
<b>IID_IEnumConnections</b><br>
OLE IID<br>
{b196b287-bab4-101a-b69c-00aa00341d07}<br>
<hr>

<a name="IIDIMALLOC">
<b>IID_IMalloc</b><br>
OLE IID<br>
{00000002-0000-0000-c000-000000000046}<br>
<hr>

<a name="IIDISTORAGE">
<b>IID_IStorage</b><br>
OLE IID<br>
{0000000b-0000-0000-c000-000000000046}<br>
<hr>

<a name="IIDITYPEINFO">
<b>IID_ITypeInfo</b><br>
OLE IID<br>
{00020401-0000-0000-c000-000000000046}<br>
<hr>

<a name="IIDITYPELIB">
<b>IID_ITypeLib</b><br>
OLE IID<br>
{00020402-0000-0000-c000-000000000046}<br>
<hr>

<a name="IIDIUNKNOWN">
<b>IID_IUnknown</b><br>
OLE IID<br>
{00000000-0000-0000-c000-000000000046}<br>
<hr>

<a name="IIDNULL">
<b>IID_NULL</b><br>
OLE IID<br>
{00000000-0000-0000-0000-000000000000}<br>
<hr>

<a name="IMALLOC">
<b>IMalloc</b><br>
Class<br>
Allegro Active mixin class.<br>
<hr>

<a name="IMALLOCCLIENT">
<b>IMalloc-client</b><br>
Class<br>
Client interface class.<br>
<hr>

<a name="INCOMINGERROR">
<b>incoming-error</b><br>
Class<br>
An error class associated with bad HRESULT codes
returned from OLE calls, but without excepinfo data.  A subclass of
execution-error.<br>
<hr>

<a name="INSTALLCONTROL">
<b>install-control</b><i> control site</i><br>
Method: primary (ur-control t)<br>
Attaches a control object to an existing empty site.<br>
<hr>

<a name="INTERFACEHANDLE">
<b>interface-handle</b><i> ifc</i><br>
Generic Function<br>
Returns the pInterface "handle" of a client or server interface
object.<br>
<hr>

<a name="INVOKE">
<b>Invoke</b><i> object dispid riid lcid mode pdisp pvarret pexcept pargerr</i><br>
Generic Function<br>
This function attempts to perform the specified IDispatch operation,
returning an OLE success or failure code.
<dl>
<dt>object<dd>the object that has IDispatch behavior, typically an IDispatch
<dt>dispid<dd>the symbol or string naming the operation to perform
<dt>riid<dd>ignored
<dt>lcid<dd>ignored
<dt>mode<dd>one of:<ul>
<li>DISPATCH_PROPERTYGET - retrieve property named by dispid
<li>DISPATCH_PROPERTYPUT - store value in property
<li>DISPATCH_METHOD - call method
<li>(logior DISPATCH_PROPERTYGET DISPATCH_METHOD) - do either of these
</ul>
<dt>pdisp<dd>address of a foreign-allocated dispparams structure or 0
<dt>pvarret<dd>address of a foreign-allocated variant object into which
a result value can be stored
<dt>pexcept<dd>address of a foreign-allocated excepinfo object into
which exception information can be stored
<dt>pargerr<dd>not used, should be 0
</dl><br>
<hr>

<b>Invoke</b><i> obj dispid riid lcid mode pdisp pvarret pexcept pargerr</i><br>
Method: primary (IDispatch t t t t t t t t)<br>
Responds to an IDispatch.Invoke to carry out the remote request.<br>
<hr>

<a name="ISTORAGE">
<b>IStorage</b><br>
Class<br>
Allegro Active mixin class.<br>
<hr>

<a name="ISTORAGECLIENT">
<b>IStorage-client</b><br>
Class<br>
Client interface class.<br>
<hr>

<a name="ISTORAGESERVER">
<b>IStorage-server</b><br>
Class<br>
Server interface class.<br>
<hr>

<a name="ITYPEINFO">
<b>ITypeInfo</b><br>
Class<br>
Allegro Active mixin class.<br>
<hr>

<a name="ITYPEINFOCLIENT">
<b>ITypeInfo-client</b><br>
Class<br>
Client interface class.<br>
<hr>

<a name="ITYPELIB">
<b>ITypeLib</b><br>
Class<br>
Allegro Active mixin class.<br>
<hr>

<a name="ITYPELIBCLIENT">
<b>ITypeLib-client</b><br>
Class<br>
Client interface class.<br>
<hr>

<a name="IUNKNOWN">
<b>IUnknown</b><br>
Class<br>
This is the mixin class that allows a lisp-ole-object to provide an
IUnknown-server interface on demand.  It is not usually specified as an
explicit interface in def-ocx-class, because it will be included automatically
if it is not explicitly present.  The OLE methods for IUnknown are AddRef,
Release, and QueryInterface.  The first two are implemented as add-ref and
release calls on the server-interface object, which normally just calls
add-ref and release, respectively, on the interface's owning lisp-ole-object.
The default behavior of QueryInterface is to call query-interface on the
owning lisp-ole-object and report the result to the client.<br>
<hr>

<a name="IUNKNOWNCLIENT">
<b>IUnknown-client</b><br>
Class<br>
This is the base class from which all standard client interfaces
inherit their add-ref, release and query-interface behavior.<br>
<hr>

<a name="IUNKNOWNSERVER">
<b>IUnknown-server</b><br>
Class<br>
Server interface class.<br>
<hr>

<a name="LISPDATE">
<b>lisp-date</b><br>
Type<br>
This is a Lisp object holding (in its lisp-date-ut element)
a Lisp universal-time value.  It is the typed value associated with
a COM date value.<br>
<hr>

<a name="LISPDATETOOLEDATE">
<b>lisp-date-to-ole-date</b><i> lisp-date</i><br>
Function<br>
Returns the OLE double-float value encoding the lisp GMT
universal-time<br>
<hr>

<a name="LISPDATEUT">
<b>lisp-date-ut</b><i> ld</i><br>
Function<br>
Returns the universal time held in the lisp-date <i>ld</i>.<br>
<hr>

<a name="LISPELEMDESC">
<b>lisp-elemdesc</b><br>
Type<br>
A structure describing an element in a function or structure.  It
has components for the element name, type, and flow (in, out, lcid retval).<br>
<hr>

<a name="LISPELEMDESCFLOW">
<b>lisp-elemdesc-flow</b><i> led</i><br>
Function<br>
Returns a subset of (:in :out :retval :lcid)<br>
<hr>

<a name="LISPELEMDESCNAME">
<b>lisp-elemdesc-name</b><i> led</i><br>
Function<br>
Returns a string naming the element described by lisp-elemdesc led.<br>
<hr>

<a name="LISPELEMDESCTDESC">
<b>lisp-elemdesc-tdesc</b><i> led</i><br>
Function<br>
Returns a lisp ctype description of the lisp-elemdesc led.<br>
<hr>

<a name="LISPFUNCDESC">
<b>lisp-funcdesc</b><br>
Type<br>
A lisp structure holding the typelibrary information for one function.<br>
<hr>

<a name="LISPFUNCDESCELEMDESCFUNC">
<b>lisp-funcdesc-elemdescFunc</b><i> lfd</i><br>
Function<br>
Returns a lisp ctype description of the type of data returned by the
function described by the lisp-funcdesc lfd.  This may be :empty.<br>
<hr>

<a name="LISPFUNCDESCINVKIND">
<b>lisp-funcdesc-invkind</b><i> lfd</i><br>
Function<br>
Returns the (numeric) invkind code for the function described by
lisp-funcdesc lfd.<br>
<hr>

<a name="LISPFUNCDESCNAME">
<b>lisp-funcdesc-name</b><i> lfd</i><br>
Function<br>
Returns a string naming the function described by lisp-funcdesc lfd.<br>
<hr>

<a name="LISPFUNCDESCPARAMS">
<b>lisp-funcdesc-params</b><i> lfd</i><br>
Function<br>
Returns a list of lisp-elemdesc structures describing the parameters
to the function described by the lisp-funcdesc lfd.  This will be nil if there
are no parameters.<br>
<hr>

<a name="LISPGUID">
<b>lisp-guid</b><br>
Type<br>
Objects of this type represent OLE guid's.  Each
unique guid is represented by a unique lisp-guid, which has slots
holding:<ul>
<li> a standard string representation of the guid
("{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}")
<li> a binary representation
<li>the client-interface class associated with this guid, if any
</ul>
The functions string-guid, binary-guid, unique-guid and code-guid
find or create the lisp-guid object corresponding to some representation.
The functions guid-name and guid-binary return string and binary
representations of the argument lisp-guid.
A lisp-guid can be used as an eql specializer in a method; a make-load-form
method associated with the type ensures correct semantics in compiled files.<br>
<hr>

<a name="LISPOLEOBJECT">
<b>lisp-ole-object</b><br>
Class<br>
This is the base class for all lisp-defined objects that make OLE
interfaces available to callers.  It provides machinery that builds
interfaces as needed, along with an object-level reference count
accessable via the generic function ref-count.  A per-object tracing flag
allows marking objects for tracing.<br>
<hr>

<a name="LISPSAFEARRAY">
<b>lisp-safearray</b><br>
Type<br>
This is a lisp object providing access to an OLE safearray.
The lisp-safearray holds a pointer to the OLE (foreign) safearray and
an indication of the element type in that safearray.<br>
<hr>

<a name="LISPTYPEINFO">
<b>lisp-typeinfo</b><br>
Type<br>
This structure is the lisp representation of a Type Library or entry.<br>
<hr>

<a name="LISPTYPEINFOFUNCTIONS">
<b>lisp-typeinfo-functions</b><i> lti</i><br>
Function<br>
Returns the list of lisp-funcdesc structures describing functions
belonging to the lisp-typeinfo structure lti.<br>
<hr>

<a name="LISPTYPEINFOINTERFACEFLAGS">
<b>lisp-typeinfo-interface-flags</b><i> lti</i><br>
Function<br>
Returns a list of keywords associated with the interface described
by the lisp-typeinfo structure lti.  This list will include :source if and
only if the interface is an event (i.e., call-back) interface.<br>
<hr>

<a name="LISPTYPEINFOINTERFACES">
<b>lisp-typeinfo-interfaces</b><i> lti</i><br>
Function<br>
Returns the list of lisp-typeinfo structures describing the interfaces
belonging to the lisp-typeinfo structure lti.<br>
<hr>

<a name="LISPTYPEINFOKIND">
<b>lisp-typeinfo-kind</b><i> lti</i><br>
Function<br>
Returns one of the following: :enum :record :module :interface :dispatch
				 :coclass :alias :union<br>
<hr>

<a name="LOADTYPELIB">
<b>load-typelib</b><i> &key guid major-version minor-version pathname application &allow-other-keys</i><br>
Function<br>
This function tries to read a typelib and return the corresponding lisp
 structure. The typelib to process can be specified by giving either its
 pathname, or its major and minor version numbers with its guid or an
 application name. If the typelib is found, its data is internalized and
 can be formatted as idl.<br>
<hr>

<a name="LOCKEDP">
<b>lockedp</b><i> obj</i><br>
Generic Function<br>
Returns non-nil if and only if the argument is locked, in whatever sense is
defined for <i>obj</i>'s type.<br>
<hr>

<b>lockedp</b><i> (obj class-factory)</i><br>
Method: nil Returns the state of the class-factory's locked slot.
This slot is initially nil; its state is changed by calls to lock-server.<br>
nil<br>
<hr>

<a name="LOCKSERVER">
<b>lock-server</b><i> object mode</i><br>
Generic Function<br>
This function locks or unlocks the factory <i>object</i>.  If
mode is non-nil then the factory is locked; if mode is nil the
factory is unlocked.<br>
<hr>

<b>lock-server</b><i> ifc flag</i><br>
Method: primary (IClassFactory-client t)<br>
This method invokes the IClassFactory.LockServer method.<br>
<hr>

<b>lock-server</b><i> obj lockit</i><br>
Method: primary (class-factory t)<br>
Sets the state of the locked slot based on the incoming argument.
If the factory is left unlocked and has no children, factory-idle is called.<br>
<hr>

<a name="MAKECLIENTINTERFACEINSTANCE">
<b>make-client-interface-instance</b><i> class pinterface &optional addref</i><br>
Function<br>
Creates and returns a client interface object of specified class for
the pinterface argument.  If the class is not already defined, the
function attempts to load the client interface code from the OLE
libraries first.  If the optional addref argument is non-nil then an
AddRef is done on the pinterface.  If the pinterface argument is 0, however,
make-client-interface-instance returns nil without trying to do an addref.<br>
<hr>

<a name="MAKELISPDATE">
<b>make-lisp-date</b><i> ut</i><br>
Function<br>
Builds and retuns a new lisp-date whose universal time is <i>ut</i>.<br>
<hr>

<a name="MAKELISPSAFEARRAY">
<b>make-lisp-safearray</b><i> dims &key (element-type
                                         'variant
                                         etype-p) (element-code
                                                   nil
                                                   ecode-p)</i><br>
Function<br>
This function constructs a lisp-safearray having specified dimensions
and element type; it also allocates foreign space for the OLE part of
the safearray.  The dimensions are specified by <i> dims</i>,
which can be a single integer or a list of integers.  The element type
can be specified symbolically with the :element-type keyword or via the
OLE element type code via the :element-code keyword.  At most one of
these two keywords can be specified.  Legal values for :element-type are
<code>
<ul>
<li>:char
<li>:unsigned-char
<li>:short
<li>:unsigned-short
<li>:long
<li>:unsigned-long
<li>:quad
<li>:unsigned-quad
<li>:float
<li>:double
<li>ole:cy
<li>ole:date
<li>ole:bstr
<li>error
<li>ole:bool
<li>ole:hresult
<li>ole:safearray
<li>ole:variant
<li>ole:IUnknown
<li>ole:IDispatch
</ul></code><br>
<hr>

<a name="MAKESCODE">
<b>make-scode</b><i> severity facility code</i><br>
Function<br>
This function returns the 32-bit integer value encoding the
specified <i>severity</i>, <i>facility</i>, and <i>code</i> components,
which must be supplied as integers.<br>
<hr>

<a name="MALLOCINTERFACE">
<b>*malloc-interface*</b><br>
Variable<br>
Holds the IMalloc interface acquired from OLE at start-ole time.
This interface is needed as an argument for a few methods calls.<br>
<hr>

<a name="MANUFACTUREDOBJECT">
<b>manufactured-object</b><br>
Class<br>
This is the base mixin class for all lisp objects that are to be
made available to clients via a class-factory object.<br>
<hr>

<a name="NEXTCONNECTIONPOINT">
<b>next-connection-point</b><i> enumerator</i><br>
Generic Function<br>
Returns the next connection point object available from <i>enumerator</i>,
or nil if there are no more.<br>
<hr>

<b>next-connection-point</b><i> ifc</i><br>
Method: primary (IEnumConnectionPoints-client)<br>
Uses the enumeration methods to retrieve the next IConnectionPoint-client
interface from the enumerator <i>ifc</i>, returning nil if there are no more.<br>
<hr>

<a name="OBJECTNAME">
<b>object-name</b><i> object</i><br>
Generic Function<br>
This function must return a symbol naming the object
uniquely within the set of named OLE objects in the application.<br>
<hr>

<a name="OBJECTWINDOW">
<b>object-window</b><i> object</i><br>
Generic Function<br>
This function must return the window handle for the
window associated with <i>object</i>.  This is generally applicable
to containers and controls.<br>
<hr>

<a name="OLEDATETOLISPDATE">
<b>ole-date-to-lisp-date</b><i> ole-date</i><br>
Function<br>
Returns the lisp-date universal-time encoding for the GMT ole-date<br>
<hr>

<a name="OLEERROR">
<b>ole-error</b><i> hcode &optional xi</i><br>
Function<br>
ole-error is typically called with an HRESULT value as the first argument.
If the excepinfo is present and non-nil and non-zero, then
it must reference a foreign excepinfo structure that was filled in by the
OLE operation producing the error <i>hcode</i>.
ole-error signals an error of type incoming-error if there was no excepinfo,
extended-incoming-error if there was excepinfo.<br>
<hr>

<a name="OLEFREE">
<b>ole-free</b><i> object</i><br>
Generic Function<br>
This function is called when the release function decrements
a ref-count to 0.  The primary method defined for a lisp-ole-object
frees the
associated server interfaces.  This method should not be overridden.
Additional behavior should be added with :before, :after, or :around
methods.<br>
<hr>

<b>ole-free</b><i> obj</i><br>
Method: after (automaton)<br>
An after method for an automaton lets its factory, if any, know the new situation.<br>
<hr>

<a name="OLELANGUAGE">
<b>*ole-language*</b><br>
Variable<br>
Holds the default language value for the running system.  Initialized
from the :language keyword supplied (or defaulted) when start-ole is
called.<br>
<hr>

<a name="OLELOCALE">
<b>*ole-locale*</b><br>
Variable<br>
Holds the default locale value for the running system.  Initialized
from the :locale keyword supplied (or defaulted) when start-ole is
called.<br>
<hr>

<a name="OPENOLESTORAGE">
<b>open-ole-storage</b><i> location s &key (mode
                                            :direct) (direction
                                                      :io) (share
                                                            :exclusive) (priority
                                                                         nil) (delete-on-release
                                                                               nil) (if-exists
                                                                                     nil) (if-does-not-exist
                                                                                           (case
                                                                                            direction
                                                                                            (:input
                                                                                             :error)
                                                                                            (t
                                                                                             :create))) (exclude
                                                                                                         nil)</i><br>
Function<br>
Opens an OLE Storage and returns the IStorage-client interface.
<ul>
<li>location: an IStorage-client interface or the keyword :root.
<li>s: a string naming the storage to be opened.  If location is :root,
the name can be nil, to create a temporary storage.
<li>mode: one of :direct, :transacted, :simple.
<li>direction: one of :input, :output, :io.
<li>share: one of :deny-read, :deny-write, :exclusive, nil.
<li>priority: boolean. (not currently implemented, allow to default)
<li>delete-on-release: boolean.
<li>if-exists: one of :supersede, :convert, :fail, nil.
<li>if-does-not-exist: one of :create, :error, nil.
<li>exclude: (not currently implemented, allow to default)
</ul><br>
<hr>

<a name="OPENOLESTREAM">
<b>open-ole-stream</b><i> location s &key (mode
                                           :direct) (direction
                                                     :input) (share
                                                              :exclusive) (priority
                                                                           nil) (delete-on-release
                                                                                 nil) (if-exists
                                                                                       nil) (if-does-not-exist
                                                                                             (case
                                                                                              direction
                                                                                              (:input
                                                                                               :error)
                                                                                              (t
                                                                                               :create)))</i><br>
Function<br>
Opens an OLE storage stream and returns the IStream-client interface.
<ul>
<li>location: an IStorage-client interface.
<li>s: a string naming the stream to be opened.
<li>mode: one of :direct, :transacted, :simple.
<li>direction: one of :input, :output, :io.
<li>share: one of :deny-read, :deny-write, :exclusive, nil.
<li>priority: boolean. (not currently implemented, allow to default)
<li>delete-on-release: boolean.
<li>if-exists: one of :supersede, :convert, :fail, nil.
<li>if-does-not-exist: one of :create, :error, nil.
</ul><br>
<hr>

<a name="OPENREGISTRYKEY">
<b>open-registry-key</b><i> root path &key (access
                                            :read) (create
                                                    nil) (error-return
                                                          nil
                                                          error-return-p)</i><br>
Generic Function<br>
Calling this function creates and returns a registry-key instance that
provides access to a specified key in the registry.  It can be used to add
a key entry to the registry.  The registry entry to be opened is specified
by giving a path to it from some already-open key.  The <i>root</i>
argument must be an open registry-key instance.  The <i>path</i> can be a
single string naming a subkey of the <i>root</i>.  Alternatively, it can
be a list of strings describing a path from the <i>root</i>.  For example,
a path of ("Class" "Ptr") designates the "Ptr" subkey of the "Class"
subkey of the <i>root</i>.  The path can be nil, in which case a second
access key to the <i>root</i> registry entry is being requested.
The specified registry entry is opened with
read-only access unless the :access keyword is used to specify :write or :all.
If the :create keyword value is non-nil, and the requested
entry does not exist, then it will be created.  If the :create keyword value
is explicitly nil or is omitted, and the entry does not exist, then the
result depends on the state of the :error-return keyword.  If this keyword
is present, then the value it supplies is returned in place of the missing
registry entry.  Otherwise an error is signalled.<br>
If a registry-key is created, then a gc finalization is scheduled for it, so
that its OLE resources can be freed when it is garbage-collected if they
have not been released before that.<br>
<hr>

<a name="OWNINGPROCESS">
<b>owning-process</b><i> object</i><br>
Generic Function<br>
This function returns the (Lisp) process that was executing when <i>object</i> was created.  This allows the finalization method to free <i>object</i> in the same process, which is essential for some VB-allocated interfaces.  There is a method defined for external-ole-interface objects, and these objects are the only ones for which it is meaningful.<br>
<hr>

<a name="PINTERFACE">
<b>pInterface</b><br>
Foreign Type<br>
The OLE pInterface type.
A pInterface value is the address of an interface instance.<br>
<hr>

<a name="PROCESSCONNECTIONEVENT">
<b>process-connection-event</b><i> agent event connection sink cookie</i><br>
Generic Function<br>
The connection-point support functions arrange to call
process-connection-event at several significant points in the history of
a connection.  The first argument in the call is always the connection-point's
agent.  Methods specialized to the agent's class provide for user-defined
behavior.  A null method is defined for a nil agent.<dl>
<dt>agent<dd>The connection-point's agent.  If this is nil, a method that
does nothing is invoked.
<dt>event<dd> one of <dl><dt>:attach<dd>An AdviseConnection has been accepted
and the cookie is about to be returned to the caller.
<dt>:predetach<dd>An UnadviseConnection has been received for an active
connection, but the connection has not yet been closed.
<dt>:detach<dd>An UnadviseConnection has been received and the connection
removed, but the sink has not yet been released.
</dl>
<dt>cp<dd>the connection-point object
<dt>sink<dd>the Ixxxx-client object that is the sink for this connection
<dt>cookie<dd>the value of the cookie to be returned to the caller.
</dl><br>
<hr>

<b>process-connection-event</b><i> agent event connection sink cookie</i><br>
Method: primary ((eql nil) t t t t)<br>
This null method handles the case where no agent has been defined
for the connection-point.<br>
<hr>

<a name="PROCESSSITEMESSAGE">
<b>process-site-message</b><i> site msg wp lp</i><br>
Method: primary (site-mixin t t t)<br>
This is the windows message handler for sites.  It returns non-nil if it handled the message, nil otherwise.  If it returns a value, that value should be
returned to windows. (That is, it should. Currently it does nothing).<br>
<hr>

<a name="QUERYINTERFACE">
<b>query-interface</b><i> object iid</i><br>
Generic Function<br>
This generic function asks <i>object</i> to provide its interface
of type <i>iid</i>.  Methods defined for client interfaces query the
external interface and return a new client interface of the appropriate
type or nil, depending on the external object's response.  Methods defined
for objects that inherit from lisp-ole-object find or build a server
interface of the designated type if the object presents that interface and
return nil otherwise.<br>
<hr>

<b>query-interface</b><i> obj guid</i><br>
Method: primary (lisp-ole-object t)<br>
This method checks to see if <i>obj</i> supports the specified
interface.  If it does, then the appropriate interface object is
returned, from <i>obj</i>'s cache if possible and by creating (and
caching) a new one if necessary.  If <i>obj</i> doesn't support
the specified interface, then this method returns nil.<br>
<hr>

<b>query-interface</b><i> ifc iid</i><br>
Method: primary (IUnknown-client t)<br>
This function calls the foreign pInterface's QueryInterface method,
asking for the guid specified by <i>iid</i>.  The iid must have an
associated client-interface class defined.  If the QueryInterface response
is positive, query-interface constructs and returns a client-interface object
of the appropriate type referencing the new returned pInterface.  If the
QueryInterface response indicates a failure, query-interface returns two
values, nil and the HRESULT value from the QueryInterface call.<br>
<hr>

<b>query-interface</b><i> tool iid</i><br>
Method: primary (remote-autotool t)<br>
This just passes the request on to the tool's IDispatch interface.<br>
<hr>

<a name="REFCOUNT">
<b>ref-count</b><i> object</i><br>
Generic Function<br>
This is an accessor function for the ref-count slot of those ole
objects that maintain them.<br>
<hr>

<a name="REGISTERFACTORY">
<b>register-factory</b><i> obj classid context flags</i><br>
Generic Function<br>
Calls CoRegisterClassObject to register <i>obj</i> so that OLE can
make the service available to other processes.  Returns true if successful,
signals an error otherwise<dl>
<dt>obj<dd>the class-factory object that is to be registered.
<dt>classid<dd>the lisp-guid specifying the Classid by which OLE is to register this factory.
<dt>context<dd>one or more of the following values or'ed together:<ul>
<li>CLSCTX_INPROC_SERVER
<li> CLSCTX_INPROC_HANDLER
<li> CLSCTX_LOCAL_SERVER
<li> CLSCTX_REMOTE_SERVER
</ul>
<dt>flags<dd>one of the following codes:<ul>
<li>REGCLS_SINGLEUSE
<li>REGCLS_MULTIPLEUSE
<li>REGCLS_MULTI_SEPARATE
</ul>
</dl><br>
<hr>

<b>register-factory</b><i> obj classid context flags</i><br>
Method: primary (class-factory t t t)<br>
Performs all the register-factory business for class-factory objects.<br>
<hr>

<a name="REGISTERSERVER">
<b>register-server</b><i> prog-name readable-name class-id &key inproc32 local32</i><br>
Function<br>
This function places entries in the registry to allow access to our
server.<dl>
<dt>prog-name<dd>a string of the form "Franz.autosample.1"
<dt>readable-name<dd>a readable description of the program, e.g.,
"Franz Automation Sample"
<dt>class-id<dd>the classid to be registered for the name.
Can be a lisp-guid or a standard string representation.
<dt>inproc32<dd>a string naming the InProcServer32 DLL
module for this class.  If omitted, no InProcServer32 registry key
is created.
<dt>local32<dd>non-nil means this class is supported by running lisp as a
local server.  The lisp executable and the lisp image need to be
specified.  The value for local32 can be one of the following:
<ul><li>a list of two strings giving the pathnames of the lisp executable
and the lisp image, in that order.
<li>a string giving the pathname of the lisp image; the current lisp
executable will be named as the local server.
<li>the symbol t; the current lisp executable and image will be specified
as the executable and image for the server.  This is useful for
self-registration.
</ul>
</dl><br>
<hr>

<a name="REGISTRYKEY">
<b>registry-key</b><br>
Class<br>
Instances of this class provide access to the windows registry.<br>
<hr>

<a name="REGISTRYSUBKEYNAMES">
<b>registry-subkey-names</b><i> k &optional maxlng</i><br>
Method: primary (registry-key)<br>
Returns a sorted list of the names of subkeys associated with the
registry-key <i>k</i>.  The optional second argument is not currently
effective, and should be omitted.<br>
<hr>

<a name="REGISTRYVALUE">
<b>registry-value</b><i> key name &optional path</i><br>
Generic Function<br>
This function returns the value associated with a specified name
in a specified registry entry.  The registry entry is designated by
giving a starting key, <i>key</i> and an optional <i>path</i>.  The
<i>path</i> argument can be a string or a list of strings.  If omitted or
nil it causes the <i>key</i> argument to be the registry entry to search.
If the <i>name</i>d value is found in that registry entry then the
associated value is returned, otherwise nil is returned.  If <i>path</i>
is non-nil but does not lead to a valid registry entry, then nil is
returned.<br>
The empty string "" names the key's default value.<br>
The form (registry-value ...) is setf-able.<br>
<hr>

<a name="REGISTRYVALUENAMES">
<b>registry-value-names</b><i> k &optional maxlng</i><br>
Method: primary (registry-key)<br>
Returns a sorted list of the names of values associated with the
registry-key <i>k</i>.  The optional second argument is not currently
effective, and should be omitted.<br>
<hr>

<a name="REGISTRYVALUEPRESENTP">
<b>registry-value-present-p</b><i> key name &optional path</i><br>
Generic Function<br>
This function searches for a specified name
in a specified registry entry.  The registry entry is designated by
giving a starting key, <i>key</i> and an optional <i>path</i>.  The
<i>path</i> argument can be a string or a list of strings.  If omitted or
nil it causes the <i>key</i> argument to be the registry entry to search.
If the <i>name</i>d value is found in that registry entry then
t is returned, otherwise nil is returned.<br>
<hr>

<a name="RELEASE">
<b>release</b><i> object</i><br>
Generic Function<br>
This method is called when a user wishes to relinquish access to
an interface.  An OLE object maintains a reference count and may
free resources and generally invalidate future references when the
count goes to zero.<br>
<hr>

<b>release</b><i> obj</i><br>
Method: primary (IUnknown)<br>
This method decrements (ref-count <i>object</i>).  If the result is zero,
ole-free is called on <i>object</i>.  The post-decrement ref-count value is
returned.<br>
<hr>

<b>release</b><i> ifc</i><br>
Method: primary (IUnknown-client)<br>
This method calls the foreign pInterface's Release method, returning
the integer that comes back from that function.  It also changes the
argument's  class to released-IUnknown, preventing its subsequent misuse
in method calls.<br>
<hr>

<b>release</b><i> tool</i><br>
Method: primary (remote-autotool)<br>
This releases the IDispatch interface associated with <i>tool</i>.<br>
<hr>

<b>release</b><i> obj</i><br>
Method: after (connection-point)<br>
Releasing a reference to a connection point also releases a reference to
its container.  See add-ref.<br>
<hr>

<b>release</b><i> obj</i><br>
Method: after (connection-point-enumerator)<br>
Also does a release on the connection-point-container.<br>
<hr>

<b>release</b><i> obj</i><br>
Method: after (connection-enumerator)<br>
Does a release on the connection-point object, as well.<br>
<hr>

<b>release</b><i> obj</i><br>
Method: after (advise-enumerator)<br>
Also does a release on the adviser.<br>
<hr>

<a name="RELEASEPROCESSCLIENTINTERFACES">
<b>release-process-client-interfaces</b><i></i><br>
Function<br>
This function goes through acl's pending finalization set to
extract the release finalizations for all client interfaces created
by this process and not yet triggered. These are removed from acl's
finalization set, and are all released (in an undetermined order).
The list of released interfaces is returned. (The *malloc-interface*
is not released, even if it was created by this process, since it is shared
by multiple processes.)<br>
<hr>

<a name="REMOTEAUTOTOOL">
<b>remote-autotool</b><br>
Class<br>
This is a client class that provides lisp access to some object
via IDispatch.  It builds a name-to-id map dynamically as needed to
improve call efficiency.<br>
<hr>

<a name="REQUIRECLIENTINTERFACES">
<b>require-client-interfaces</b><i> &rest ifclist</i><br>
Macro<br>
This macro expands into the code to load the client library code
for the named (unevaluated) interfaces.  For example, a file that
needed to call upon the ITypeLib and ITypeInfo interfaces might include
the form (require-client-interfaces ITypeLib ITypeInfo).<br>
<hr>

<a name="REQUIREMODULES">
<b>require-modules</b><i> &rest module-names</i><br>
Macro<br>
This expands to code to require the specified ACLOLE modules.
The module-names can include any of the following keywords:
<dl>
<dt>:automation-server <dd>To include support for automation servers
<dt>:factory-server <dd>To include support for class factories
<dt>:connection-server<dd>To include support for providing connections
<dt>:ocx-container <dd>To include support for OLE Containers
</dl><br>
<hr>

<a name="REQUIRESERVERINTERFACES">
<b>require-server-interfaces</b><i> &rest ifclist</i><br>
Macro<br>
This macro expands into the code to load the server library code
for the named (unevaluated) interfaces.  For example, a file that
needed to call upon the ITypeLib and ITypeInfo interfaces might include
the form (require-server-interfaces ITypeLib ITypeInfo).<br>
<hr>

<a name="RKEYCLASSESROOT">
<b>rkey-classes-root</b><br>
Variable<br>
This holds a registry-key used to access HKEY_CLASSES_ROOT.<br>
<hr>

<a name="RKEYCURRENTUSER">
<b>rkey-current-user</b><br>
Variable<br>
This holds a registry-key used to access HKEY_CURRENT_USER.<br>
<hr>

<a name="RKEYLOCALMACHINE">
<b>rkey-local-machine</b><br>
Variable<br>
This holds a registry-key used to access HKEY_LOCAL_MACHINE.<br>
<hr>

<a name="RKEYUSERS">
<b>rkey-users</b><br>
Variable<br>
This holds a registry-key used to access HKEY_USERS.<br>
<hr>

<a name="RUNNINGBLIND">
<b>*running-blind*</b><br>
Variable<br>
Set nonnil to invoke errorset around all server method functions<br>
<hr>

<a name="SAFEARRAY">
<b>safearray</b><br>
Foreign Type<br>
The OLE SAFEARRAY type.<br>
<hr>

<a name="SAFEARRAYAREF">
<b>safearray-aref</b><i> v i &rest more-is</i><br>
Function<br>
This function retrieves and returns an element of the lisp-safearray or
OLE safearray <i>v</i>.  The specific element is specified by the index list
built by consing <i>i</i> in front of <i>more-is</i>.  In the common
single-dimension case <i>more-is</i> is nil and <i>i</i> is the only index.
This function wraps the access in a with-safearray-lock.  The form
<code>(safearray-aref ...)</code> is setf-able.<br>
<hr>

<a name="SAFEARRAYDIMENSION">
<b>safearray-dimension</b><i> v i</i><br>
Function<br>
Returns the dimension specification for the <i>i</i>-th dimension
of lisp-safearray or OLE safearray <i>v</i>.  The specification is a list
of the form (count lbound), where count is the array's width in this dimension
and lbound is the lowest valid index in this dimension.  The index <i>i</i>
must be non-negative and less than <i>v</i>'s rank,  If <i>i</i> is not
a valid dimension index then safearray-dimension returns nil.<br>
<hr>

<a name="SAFEARRAYDIMENSIONS">
<b>safearray-dimensions</b><i> v</i><br>
Function<br>
Returns a list of the dimension specifications for lisp-safearray or OLE
safearray <i>v</i>.  Each specification is as would be returned by
safearray-dimension.<br>
<hr>

<a name="SAFEARRAYELEMENTADDRESS">
<b>safearray-element-address</b><i> v i more-is</i><br>
Function<br>
This function returns the address of an element of the lisp-safearray or
OLE safearray <i>v</i>.  The element is specified by the index list built
by consing <i>i</i> in front of <i>more-is</i>.  In the common
single-dimension case <i>more-is</i> is nil and <i>i</i> is the only index.
Safearray-element-address can only be called inside a with-safearray-lock
block that locks the safearray <i>v</i>, and the result becomes invalid when that
block is exited.  If the index list is invalid then an error is signalled.<br>
<hr>

<a name="SAFEARRAYPOINTER">
<b>safearray-pointer</b><i> v</i><br>
Function<br>
The argument <i>v</i> can be a lisp-safearray object or the (integer)
address of an OLE safearray object.  In the former case the address of its
associated OLE safearray is returned; in the latter case the return value
is the argument value itself.<br>
<hr>

<a name="SAFEARRAYRANK">
<b>safearray-rank</b><i> v</i><br>
Function<br>
Returns the number of dimensions defined for the lisp-safarray or
OLE safearray <i>v</i>.<br>
<hr>

<a name="SERVERDLLNAME">
<b>server-dll-name</b><i> factory</i><br>
Generic Function<br>
ACLOLE calls this function during self-registration
to get the appropriate dll name.  Application code must provide an
appropriate method for any factories they wish to register.<br>
<hr>

<a name="SERVERINITIALIZATIONCOMPLETE">
<b>*server-initialization-complete*</b><br>
Variable<br>
This variable should be set non-nil when the Lisp server application
is ready to receive requests from OLE.  Any thread making OLE requests to
the server will be blocked until the value becomes non-nil.  This variable
cannot be used to block request processing after it has once begun, its
sole use is to delay processing while the server performs initialization.<br>
<hr>

<a name="SETEVENTRETURN">
<b>set-event-return</b><i> parmname value</i><br>
Function<br>
This function can be called within the dynamic scope of
an event handler created by def-ole-linkage. The parmname argument
names one of the out parameters of the method and the value argument
must be a legal value to be transmitted back to the method's
caller via that out parameter. The last value specified in this
way for a particular out parameter will be sent back to the caller.
The function returns its second argument.<br>
<hr>

<a name="SETSERVERTRACE">
<b>set-server-trace</b><i> object mode</i><br>
Generic Function<br>
This function controls tracing behavior of individual
server interfaces and of server objects.  The <i>object</i> argument is
the item in question.  The <i>mode</i> argument can be :on, to turn tracing
on, or :off, to turn tracing off.  When an interface is being traced,
each call to a method of that particular interface (not interface class)
will generate output to *trace-out*.  When a server object is being traced,
all its interfaces are traced and all requests for a new interface are
reported along with the results.<br>
<hr>

<b>set-server-trace</b><i> ifc mode</i><br>
Method: primary (lisp-ole-interface t)<br>
This method turns tracing for the specified interface on or off.<br>
<hr>

<b>set-server-trace</b><i> obj mode</i><br>
Method: primary (lisp-ole-object t)<br>
This method turns tracing for the object on or off.  All its existing
interfaces will be set to trace or not trace, as appropriate.  All interfaces
built are marked to trace or not according to the object's trace state at the
time the interface is created.<br>
<hr>

<a name="SETVARIANTVALUEEXTENSION">
<b>set-variant-value-extension</b><i> key val pvariant</i><br>
Generic Function<br>
This generic function allows (setf variant-value) to be extended to
deal with additional types.  If a value to be stored in a variant is
not of one of the known types, then set-variant-value-extension will
be called.  The <i>val</i> and <i>pvariant</i> arguments are the value and
variant pointer, respectively.  The <i>key</i> argument is <i>val</i>,
if that is an atom, its car if it is a cons cell.  Any method defined
on set-variant-value-extension must store an appropriate value in the
variant and return true, or return NIL to indicate failure.<br>
<hr>

<a name="SIGNALSERVEREXCEPTION">
<b>signal-server-exception</b><i> object code &key source description helpfile helpcontext use-scode</i><br>
Method: primary (automaton t)<br>
This function can be called within an auto-method handler
to signal an exception.  It causes the Invoke method to return a
DISP_E_EXCEPTION result after filling in the excepinfo block.  The
fields of the excepinfo structure are filled as follows:
<ul>
<li>
<i>object</i> argument, an automaton object, is used to determine the
source; see the <i>source</i> argument.
<li>
<i>code</i> argument is placed into wcode or scode.  If the
<i>use-scode</i> argument is non-nil, wcode gets 0 and scode gets the
<i>code</i> value, otherwise wcode gets the <i>code</i> value and
scode is set to 0.
<li>
<i>source</i>, if non-nil, is a string to fill in the excepinfo
source field.  If omitted or nil, the automaton object's factory,
if it has one supplies its server-progid value as the source field.
If neither source nor object provide a value, then the source field is
set to "".
<li>
<i>description</i> provides a string for the excepinfo description field.
If omitted, the string "Unhandled error in server" is used.
<li>
<i>helpfile</i> provides a string naming the help file, if any.
<li>
<i>helpcontext</i> provides an integer help context value.
<li>
<i>use-scode</i>, if present and non-nil, places the 0 into the
excepinfo wcode field and fills the scode field with the <i>code</i>
value.
</ul><br>
<hr>

<a name="SITEMIXIN">
<b>site-mixin</b><br>
Class<br>
This class is a superclass of all OLE site objects.  Site objects
correspond to places in application forms where embeddable objects or controls
are attached.
See the <a href="ole.htm">Allegro ActiveX documentation</a> for details.<br>
<hr>

<a name="STARTOLE">
<b>start-ole</b><i> &key verbose (language
                                  LANG_SYSTEM_DEFAULT) (locale
                                                        LOCALE_SYSTEM_DEFAULT)</i><br>
Function<br>
This functions sets up the initial linkage with OLE, loading the
necessary dll's.  If :verbose is specified and non-nil then progress
messages will be printed on *standard-output* during the initialization
process.  This function initializes the globals *ole-language* and 
*ole-locale* from the specified or defaulted keyword arguments :language and
:locale.  Any global initializations defined by defoleglobal macros are
performed after OLE is successfully initialized and the *malloc-interface*
global has been set.<br>
<hr>

<a name="STOPOLE">
<b>stop-ole</b><i> &optional verbose</i><br>
Function<br>
This function tells OLE that it is no longer needed.  It also runs any
de-initialization functions specified by defoleglobal macros.  If the
optional <i>verbose</i> argument is non-nil, then progress messages
will be written to *standard-output* during the shutdown process.  The
return value will be t if OLE had to be stopped.  A second call to this
function will find that OLE has already been disconnected and will
return nil.<br>
<hr>

<a name="STORAGEFORSITE">
<b>storage-for-site</b><i> obj site</i><br>
Generic Function<br>
This function is to create a storage interface that
an object can use to save its state.  Methods must be defined to
handle whatever application document classes inherit from
document-mixin and site-mixin.<br>
<hr>

<b>storage-for-site</b><i> this site</i><br>
Method: primary (object-with-storage t)<br>
This is the default method; it opens a new storage element in the object's
storage, signalling an error if the site's storage already exists.  The name
of the site's storage element is site=[xxx], where xxx is the site's name.<br>
<hr>

<a name="STRINGBSTR">
<b>string-bstr</b><i> string</i><br>
Function<br>
String-bstr allocates (using SysAllocString) and returns a foreign bstr
object holding a copy of the <i>string</i> argument.  If the argument is
the empty string "", then string-bstr returns the NULL pointer 0.<br>
<hr>

<a name="STRINGGUID">
<b>string-guid</b><i> guid</i><br>
Function<br>
This function accepts a string encoding a guid in the standard
human-readable format, "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" and returns
the lisp-guid object representing that guid.<br>
<hr>

<a name="STRINGUNICODE">
<b>string-unicode</b><i> string &optional cpointer</i><br>
Function<br>
This function converts its <i>string</i> argument to unicode and
returns the result.  If the <i>cpointer</i> argument is supplied, then it
must be the address of a foreign area big enough to hold the result, the
output string will be built there.  If the <i>cpointer</i> argument is
omitted then string-unicode allocates a foreign area for the result.
In either case, the string data is converted to its unicode equivalent
in the output area and the area's address is returned.<br>
<hr>

<a name="SUCCESS">
<b>success</b><i> hr</i><br>
Macro<br>
Expands to code that evaluates the form <i>hr</i> and tests the
(integer) result, returning true if and only if it is an OLE success code.<br>
<hr>

<a name="UNADVISECONNECTION">
<b>unadvise-connection</b><i> connpt cookie</i><br>
Generic Function<br>
Advises the connection point <i>connpt</i> that the connection it
identified by the <i>cookie</i> value can be closed.<br>
<hr>

<b>unadvise-connection</b><i> ifc cookie</i><br>
Method: primary (IConnectionPoint-client t)<br>
Calls IConnectionPoint.Unadvise to disconnect the sink associated with
the cookie argument, which must be the value returned from an earlier
advise-connection call on the same connection point.<br>
<hr>

<b>unadvise-connection</b><i> cp cookie</i><br>
Method: primary (connection-point t)<br>
If <i>cookie</i> identifies an active connection for <i>cp</i> then
the connection is detached, the associated interface is released, and
the appropriate calls to process-connection-event are made.  The function
returns true if the cookie was valid, nil otherwise.<br>
<hr>

<a name="UNICODE">
<b>unicode</b><br>
Foreign Type<br>
The foreign type representing unicode data.<br>
<hr>

<a name="UNICODESTRING">
<b>unicode-string</b><i> cpointer &optional (csize
                                             most-positive-fixnum)</i><br>
Function<br>
The unicode data is extracted from the foreign area addressed by
the <i>cpointer</i> argument and converted to a newly-allocated Lisp
string, which is returned.  If the <i>csize </i> argument is provided it
specifies a maximum length to be converted.  The actual amount converted
will be set by the smaller of the <i>csize</i> parameter and
the position of the first zero character in the unicode data.<br>
<hr>

<a name="UNIQUEGUID">
<b>unique-guid</b><i> guid</i><br>
Function<br>
This function accepts a lisp-guid or a string or binary representation
of a guid.  In the first case it returns the argument itself; in the other
cases it finds or creates the associated lisp-guid and returns that.<br>
<hr>

<a name="UNREGISTERAPPLICATION">
<b>unregister-application</b><i> appname</i><br>
Function<br>
This function looks up an application in the registry and deletes
entries associated with it.<br>
<hr>

<a name="UNREGISTERFACTORY">
<b>unregister-factory</b><i> factory</i><br>
Generic Function<br>
Informs OLE that <i>factory</i> is no longer available to serve
client requests.<br>
<hr>

<b>unregister-factory</b><i> obj</i><br>
Method: primary (class-factory)<br>
Revokes the registration so that OLE will make no further connections
to <i>obj</i>.<br>
<hr>

<a name="VARIANT">
<b>variant</b><br>
Foreign Type<br>
The OLE VARIANT structure in foreign space.<br>
<hr>

<a name="VARIANTAREF">
<b>variant-aref</b><i> v i</i><br>
Function<br>
This function returns a lisp value representing the value in the
OLE variant object at the <i>i</i>-th position in a (foreign) vector of
OLE variant objects starting at address <i>v</i>.  The form
<code>(variant-aref ...)</code> is setf-able.<br>
<hr>

<a name="VARIANTCHANGETYPE">
<b>VariantChangeType</b><i> destination source flags new</i><br>
Function<br>
This invokes the foreign function of the same name.<br>
<hr>

<a name="VARIANTCLEAR">
<b>VariantClear</b><i> variant</i><br>
Function<br>
This invokes the foreign function of the same name.<br>
<hr>

<a name="VARIANTCOPY">
<b>VariantCopy</b><i> destination source</i><br>
Function<br>
This invokes the foreign function of the same name.<br>
<hr>

<a name="VARIANTINIT">
<b>VariantInit</b><i> variant</i><br>
Function<br>
This invokes the foreign function of the same name.<br>
<hr>

<a name="VARIANTVALUE">
<b>variant-value</b><i> v &optional interface-type</i><br>
Function<br>
This function returns a lisp value obtained from the OLE variant
object at (foreign) address <i>v</i>.  The form
<code>(variant-value ..)</code> is setf-able.
If the optional <i>interfaace</i> argument is supplied it must name a
*-client interface type. In that case interface values willbe returned as the
specified type, rather than IUnknown-client or IDispatch-client.
If the special variable variant-value-translation-function is not NIL, then
the value extracted from the variant is translated before being returned.<br>
<hr>

<a name="VARIANTVALUES">
<b>variant-values</b><i> v count</i><br>
Function<br>
This function returns a vector of <i>count</i> elements obtained
by converting successive variant values starting at address <i>v</i>.<br>
<hr>

<a name="VARIANTVALUETRANSLATIONFUNCTION">
<b>variant-value-translation-function</b><br>
Variable<br>
This symbol may be bound to a function of one variable that is
to translate all values extracted from variants.  It may be left
NIL to skip translation.  If a translation function is specified,
then whenever variant-value extracts a value from a variant, that
value will be passed to the translation function and the result
will then be returned as the variant's effective value.  Since
IDispatch.Invoke arguments are received as variants, this means
all such arguments will be translated before being passed to the
invoked methods.<br>
<hr>

<a name="WITHFOREIGNDATA">
<b>with-foreign-data</b><i> obdefs &rest body</i><br>
Macro<br>
This macro expands into code that temporarily and efficiently
allocates areas to hold foreign data of specified types while
evaluating the <i>body</i> forms.  The <i>obdefs</i> entry is a list
of elements of the form (symbol foreign-type-spec [count]).  The symbols
are let-bound to instances of the associated foreign types and the body
is evaluated within that set of bindings.  The optional count form
can specify a constant or a form to be evaluated in the context of the
with-foreign-data.  If present, it specifies the allocation of an area
large enough to hold that many copies of the specified foreign type.
The foreign data is logically
deallocated after the body forms have been evaluated.  It is not defined
whether the data areas are allocated from a pool or on the stack, but in
any case they may not be referenced outside the <i>body</i> of the
with-foreign-data form.  The value of the whole form is whatever is computed
by the implicit progn of its <i>body</i> forms.<br>
<hr>

<a name="WITHOPENREGISTRYKEY">
<b>with-open-registry-key</b><i> (var
                                  root
                                  path
                                  &rest
                                  args) &body body</i><br>
Macro<br>
This macro expands into code that opens a registry key, evaluates the
<i>body</i>, then closes the registry key, returning what the body computed.
The close is done as an unwind-protect cleanup.  The open registry key is
obtained by applying open-registry-key to <i>root</i> <i>path</i> and
<i>args</i>, and is then let-bound to the <i>var</i> variable while
<i>body</i> is evaluated.<br>
<hr>

<a name="WITHSAFEARRAYLOCK">
<b>with-safearray-lock</b><i> aform &rest body</i><br>
Macro<br>
Expands to code that evalutes <i>body</i> as an implicit progn inside
an environment that has done an OLE lock on the safearray pointer obtained
by evaluating <i>aform</i>.  This allows the safearray's data to be accessed
within the body.  The <i>aform</i> can evaluate to a lisp-safearray or an
OLE safearray reference.<br>
<hr>

<a name="WITHUNICODEARGUMENT">
<b>with-unicode-argument</b><i> (v val) &rest body</i><br>
Macro<br>
This form expands to code that evaluates the <i>val</i> form,
which must produce a string, then allocates a foreign area to hold
a Unicode version of that string.  The unicode form of the string data
is copied into the foreign area, the variable <i>v</i> is let-bound to
the area, and the <i>body</i> forms are evaluated as an implicit progn
in this environment.  The unicode data is freed before the
with-unicode-argument form returns.  This macro is typically wrapped around
calls to OLE functions that require unicode arguments.<br>
<hr>

<a name="XENOADDRESS">
<b>xeno-address</b><i> type ptr &rest access</i><br>
Macro<br>
Expands to code that returns the address of the specified element of the
foreign structure addressed by the ptr argument, assuming it to be of the
specified foreign type. All subforms are evaluated.<br>
<hr>

<a name="XENOSLOT">
<b>xeno-slot</b><i> type ptr &rest access</i><br>
Macro<br>
Expands to code that returns the specified element of the foreign structure
addressed by the ptr argument, assuming it to be of the specified foreign type.
All subforms are evaluated.<br>
<hr>

</body>
</html>
