<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<meta NAME="GENERATOR" CONTENT="Microsoft FrontPage 3.0">
<title>IDE User Guide, Chapter 3: An example</title>
</head>

<body LINK="#0000ff">

<table border="0" width="100%" cellpadding="1" cellspacing="0">
  <tr>
    <td bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3">
      <tr>
        <td align="left" bgcolor="#00FFFF"><a href="../../contents.htm"><b>ToC</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../../introduction.htm"><b>DocOverview</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../../cgide.htm"><b>CGDoc</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../../release-notes.htm"><b>RelNotes</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../../index.htm"><b>Index</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../../permuted-index.htm"><b>PermutedIndex</b></a></td>
      </tr>
    </table>
    </td>
    <td align="right"><b>Allegro CL version 8.2</b></td>
  </tr>
</table>

<h1><a name="begin"></a>Chapter 3. An example</h1>

<p>This chapter contains the following sections:</p>

<blockquote>
  <p><a href="#sec-3-1">3.1 A simple example with two communicating controls</a><br>
  <a href="#sec-3-2">3.2 Building an application</a><br>
  <a href="#sec-3-3">3.3 The Doodler Tutorial</a><br>
  &nbsp;&nbsp;&nbsp; <a href="#sec-3-3-1">3.3.1 What the doodler application does</a><br>
  &nbsp;&nbsp;&nbsp; <a href="#sec-3-3-2">3.3.2 Developing an application</a><br>
  &nbsp;&nbsp;&nbsp; <a href="#sec-3-3-3">3.3.3 The steps in developing the doodler
  application</a><br>
  &nbsp;&nbsp;&nbsp; <a href="#sec-3-3-4">3.3.4 The doodler application windows</a><br>
  &nbsp;&nbsp;&nbsp; <a href="#sec-3-3-5">3.3.5 Popping up a common dialog</a></p>
</blockquote>

<p>This is chapter 3 of the User Guide for the Allegro CL 8.2 Integrated Development
Environment (IDE). The IDE is only supported on Windows machines. </p>

<p>The chapters of the IDE User Guide are:</p>

<blockquote>
  <p><a href="ide_user_guide_1.htm">Chapter 1: Introduction to the IDE</a> <br>
  <a href="ide_user_guide_2.htm">Chapter 2: The Allegro CL Development Environment (IDE)</a><br>
  <strong>Chapter 3: An example</strong> (this chapter)<br>
  <a href="ide_user_guide_4.htm">Chapter 4: Projects</a><br>
  <a href="ide_user_guide_5.htm">Chapter 5: Components</a><br>
  <a href="ide_user_guide_6.htm">Chapter 6: Designing a user interface using forms</a><br>
  <a href="ide_user_guide_7.htm">Chapter 7: Menus</a><br>
  <a href="ide_user_guide_8.htm">Chapter 8: Events</a></p>
</blockquote>

<p>The problem with examples is that to be interesting, they have to do something
interesting (to you, the reader) and anything that does something interesting needs some
programming. The Allegro CL IDE is a tool for designing and implementing user interfaces
to applications, along with a collection of tools which make the task of programming
easier, but it does not write the underlying program (the part that actually does the
work, often called the engine).</p>

<p>We will discuss two examples in this chapter. First is a simple example where we make a
form with two controls. We modify the event handler of one control so clicking on it
prompts the user for a string and then displays the string in the other control. We show
all steps and illustrate various windows and dialogs as we go.</p>

<p>Second, we discuss the application created by the Interface Builder Tutorial. We do not
discuss the steps of the Tutorial in detail. Rather we discuss aspects of the finished
application. If you see a feature of interest to your needs, you know that information on
implementing it can be found in the Tutorial.</p>

<h3><a name="sec-3-1"></a>3.1 A simple example with two communicating controls</h3>

<p>In this example, we create a dialog with a <a href="../../classes/cg/button.htm">button</a>
and <a href="../../classes/cg/single-item-list.htm">single-item-list</a>. We will arrange
it so that clicking on the button displays a dialog asking the user to enter some text
that is then added to the items in the single-item-list. </p>

<p>Here is approximately what the system looks like when we have a project with one form
(form1): </p>

<p><img src="../../pictures/startup-new-form.jpg"></p>

<p>We got this configuration by opening a project and then choosing <strong>New Form</strong>
from the <a href="../../ide-menus-and-dialogs/file-menu.htm">File</a> menu, specifying
Dialog for the type of form. We were asked where we wanted the project files to be saved,
and accepted the default <b>c:\allegro-projects\project1\</b>. (If you have used projects
before, you may be using project2 or project3 rather than project1.) You should have a
directory associated with the project. If we save files, we will save them here, as that
makes cleanup easier. It is actually not necessary to save files for the first example,
but if you do, it is best to place them is the project directory.</p>

<p>Second, we need to define a function that will be used in the application. This
function will display the dialog asking for a string. Go to the editor workbook window
(click <a href="../../ide-menus-and-dialogs/view-menu.htm#editor">View | Editor</a> if the
editor workbook is not visible -- that command brings it to the front). This window uses a
tab control to display editor buffers, which may or may not be associated with files. It
starts with a single unsaved buffer named Untitled (there may be a form1 buffer as well):</p>

<p><img src="../../pictures/ewb.jpg"></p>

<p>Add the following to Untitled:</p>

<pre>(in-package :cg-user)
(defun ask-for-string (prompt &amp;optional (string &quot;&quot;))
  (multiple-value-bind (string1 string2 result)
      (ask-user-for-string prompt string 
                           &quot;~OK&quot; &quot;~Cancel&quot;)
    (declare (ignore string2))
    (when (string-equal result &quot;~OK&quot;)
      string1)))</pre>

<p>While typing this in, try some editor tricks: </p>

<p>Bring up the Apropos dialog by clicking <a
href="../../ide-menus-and-dialogs/search-menu.htm#apropos">Search | Apropos</a>. Enter <b>ask-user-for</b>
in the String box and click Search. All symbols whose names start with <b>ask-user-for</b>
are displayed; <b>ask-user-for-string</b> is at the bottom.</p>

<p><img src="apro-3-2.jpg"></p>

<p>Select it by clicking on it (it is selected in the illustration). <a
href="../../ide-menus-and-dialogs/edit-menu.htm#copy">Edit | Copy</a> copies it to the
clipboard. Back in the Untitled buffer, <a
href="../../ide-menus-and-dialogs/edit-menu.htm#paste">Edit | Paste</a> pastes it into the
buffer. Pressing F1 causes the help page for <a
href="../../operators/cg/a/ask-user-for-string.htm">ask-user-for-string</a> to be
displayed.</p>
<b>

<p></b><a href="../../ide-menus-and-dialogs/search-menu.htm#complete-symbol">Search |
Complete Symbol</a> displays a menu of choices (a dialog if there are a lot of choices).
When you get to <strong>multiple-value-bind</strong>, only type multiple-v and click <a
href="../../ide-menus-and-dialogs/search-menu.htm#complete-symbol">Search | Complete
Symbol</a>. This pop-up menu is displayed:</p>

<p><img SRC="Image10.jpg"></p>

<p>Now press `a'. The `a' choice, <b>multiple-value-bind</b>, is printed in the editor.</p>

<p>Notice too that the Lisp code indents as you go to new lines. When you are done, the
buffer should look like this:</p>

<p><img src="../../pictures/ug3-ew-image5.jpg"></p>

<p>Place the cursor just after the final parenthesis (or anywhere within the definition)
and click <a href="../../ide-menus-and-dialogs/tools-menu.htm#incremental-evaluation">Tools
| Incremental Evaluation</a>. You should see <b>ask-for-string</b> printed in the Debug
window. That indicates that the function definition has been evaluated in the Lisp
environment, as we want.</p>

<p>Note that there are shortcut keys for most of the menu choices we have mentioned
(typically Control-C for <b>Edit</b> | <b>Copy</b>, Control-V for <b>Paste</b>, Control-.
for <b>Symbol Completion</b>, and Control-E for <b>Incremental Evaluation</b>). However,
your editor mode may use those key combinations for editing operations making them
unavailable as menu shortcuts. The shortcuts are shown in the menu. Use them in preference
to the menu if desired and if they are not used by the editor.</p>

<p>
Now we can design our application window. We will work with the
current project and form. Display the Project Manager window by
clicking <a href="../../ide-menus-and-dialogs/view-menu.htm#project-manager">View
| Project Manager</a>.
</p>

<p><img src="pm-g-3-4.jpg"></p>

<p>Now select the blank form. If it is not visible, click on (and so select) <i>form1 (not
saved)</i> in the Project Manager and click on the <b>View Selected Form</b> button (shown
in the illustration).</p>

<p>The form should appear. The Inspector should be inspecting Form1. If it is not (or is
not visible), double-click on the interior of the blank form. The Inspector, inspecting
form1, will appear.</p>

<p>Also now display the code associated with form1 in an editor buffer. Do this by
selecting form1 in the Project Manager dialog and clicking on the <b>View Selected Code</b>
button.</p>

<p><img src="pm-vsl.jpg"></p>

<p>This will display an unsaved form1 buffer in the Editor Workbook.</p>

<p><img src="../../pictures/editor-wb-form1.jpg"></p>

<p>We will be adding code for event handlers for controls on the form in this buffer
presently. (<b>Note</b>: if we do not display this buffer before we start editing event
handling code, the initial event handling function code is stored in a hidden buffer. Then
when this form1 buffer is used, redefinition warnings will be displayed when the code is
compiled. Such warnings, if they appear, may be safely ignored.)</p>

<p>Now back to the inspection of Form1. (Double-click on the form if the inspector is
hidden). The inspector looks like this:</p>

<p><img src="insp-f1.jpg"></p>

<p>Change the title of the form to Simple Example by selecting the original value (Form1)
as follows. Select the text (Form1) which is the value of the title property and type <i>Simple
Example</i>. Alternatively, click on the extended editor button (with the three dots, on
the right, when the title property is selected, and replace Form1 with Simple Example in
the dialog that appears and click OK. The title of form1 will change to Simple Example.
(This change is already made in the illustration.) 

<ul>
  <li>Add a button to the form. Do this by clicking on the Button button on the Widget Palette (click in the background of the form if the widget palette is not visible). Make sure not to select the Default Button or Cancel Button. (If you leave the
    mouse over a button on the Widget Palette, a tooltip appears saying which button it
    is.) Once you have clicked on the Button button, click on the form where you want the
    button to go. Here is the Widget Palette with the Button button and the
    Single-item-list button (used later) identified: </li>
</ul>

<p><img src="wp-but-sil.jpg"> 

<ul>
  <li>Add a single-item-list to the form. Click on the single-item-list icon on the Widget Palette and click on the form where you want it to go. </li>
</ul>

<p>The form will now look like this:</p>

<p><img src="f1-3-9.jpg"></p>

<p>We want to change the name and the range of the single-item-list. Select the
single-item-list by clicking on it. Sizing handles (the solid squares) appear around the
selected component, as in the illustration. The Inspector window should now be inspecting
the single-item-list component. Click in the <a href="../../operators/cg/n/name.htm">name</a>
property, and type <code>:list-box</code>. Then click in the range field and type <code>nil</code>.
Here is the Inspector after both changes have been made. Notice the single-item-list on
the form is now blank (not illustrated). That is because we have set the range (the things
displayed) to <code>nil</code>. In the application, when a user clicks the button, a
dialog asking for a string will appear and whatever the user enters will become an item in
the single-item-list.</p>

<p><img src="Image85.jpg"></p>

<p>Now we want to change the name and the title of the button. Select the button, and go
to the Inspector, change the name field to :add-button and the title field to <i>Add&#133;</i>.
Here is the Inspector when those changes are made. Also notice the title of the button on
the form is changed to <i>Add&#133;</i> .</p>

<p><img src="Image86.jpg"></p>

<p>We want to specify the behavior when a user clicks on the button. When the user clicks,
the <a href="../../operators/cg/o/on-change.htm">on-change</a> event handler for the
button (if there is one) is called. We need a handler function that asks the user for a
string and makes the result an item on the single-item-list. </p>

<p>To modify the <b>on-change</b> event handler for the button, select the button and look
at the Inspector. Click on the Events button and you will see the event handlers for the
button. Actually, there aren't any &#150; all the values are <code>nil</code> meaning all
events are ignored (the <a href="../../operators/cg/o/on-change-test.htm">on-change-test</a>,
the only item whose value is not <code>nil</code>, is an exception we do not discuss
here).</p>

<p><img src="Image87.jpg"> 

<ul>
  <li>Click on the extended editor button &#150; to the right, with the three dots -- for the <a
    href="../../operators/cg/o/on-change.htm">on-change</a> event. Since the button is on
    form1, your code is added to the source file associated with form1. For this case, you are
    placed in the form1 tab of the Editor Workbook (which we displayed earlier). A skeleton
    function named <b>form1-add-button-on-change</b> is displayed. The name of the event
    handler combines the name of the form, the control, and the event. </li>
</ul>

<p><img src="ew--f1-3-13b.jpg"></p>

<p>The cursor should be in the blank line in the middle of the function definition. Enter
the following line. The modified editor should look like the illustration.</p>

<blockquote>
  <pre>&nbsp;(ask-for-string &quot;Enter string to add to list&quot; &quot;Greetings&quot;)</pre>
</blockquote>

<p><img src="ew--f1-3-13.jpg"></p>

<ul>
  <li>Have the system evaluate the definition by placing the cursor in the definition or after
    the last parenthesis -- i.e. after t) -- and clicking <a
    href="../../ide-menus-and-dialogs/tools-menu.htm#incremental-evaluation">Tools |
    Incremental Evaluation</a>. </li>
</ul>

<ul>
  <li>Now test the form by running the project, which means creating the window designed by
    the form and running it so the controls are active. Click <a
    href="../../ide-menus-and-dialogs/run-menu.htm#run-project">Run | Run Project</a>. You
    will be prompted to save the project files. Do so if you want but saving it is not
    necessary yet. If you do save files, you are asked if you want to add the Untitled buffer
    to the project and what its name should be. Call it <em>excode.cl</em> -- do not worry
    about the file names now; we discuss them below in <a href="#sec-3-2">3.2 Building an
    application</a>. After you have saved the files or not, an active dialog appears. <b>Note</b>:
    if you did not display the form1 buffer in the editor workbook before clicking on the
    on-change extended editor button for :add-button, you may see redefinition warnings at
    this point. They result from the <strong>form1-add-button-on-change</strong> definition
    being stored and evaluated in a hidden buffer and they may be safely ignored. </li>
</ul>

<dir>
  <dir>
    <p>After you have saved the files or not, an active dialog appears. When you click on the
    Add button, a dialog asking for a string, with default Greetings, should appear. We show
    part of the form and the two dialogs.</p>
  </dir>
</dir>

<p><img src="proj-3-14.jpg"></p>

<ul>
  <li>Modify the string or not and click on Okay. You won't see a visual change on the main
    dialog because we haven't done anything with the string just entered. We will now make use
    of it. Do not stop running the project. We are going to change its behavior while it is
    running by redefining the <b>form1-add-button-on-change</b> event handler.</li>
</ul>

<ul>
  <li>Go to the form1 tab on the Editor Workbook. In the definition of the <b>form1-add-button-on-change</b>
    function, select all lines below the line starting <code>(declare</code>, like this:</li>
</ul>

<p><img src="Image22.jpg"></p>

<p>Add the following code, replacing all the current code below the declare line. The
illustration shows the appearance after these lines are typed in. Note that the text is
indented a couple of spaces and is indented after pasting in the editor buffer. It is
important that no left parenthesis except the very first in a Lisp form (the one before <strong>defun</strong>
in our window) be in the first column, or the editor will be confused about where the Lisp
form actually begins.</p>

<pre>  (let ((list-box (find-sibling :list-box widget))
        (string (ask-for-string 
                 &quot;Enter string to add to list&quot;
                 &quot;Greetings&quot;)))
    (when string 
      (setf (range list-box) 
        (adjoin string (range list-box)
                :test 
                #'string-equal))
      ))
   t)</pre>

<p><img src="ew--f1-3-15.jpg">

<dir>
  <dir>
    <p>Note that list-box was found using the function <a
    href="../../operators/cg/f/find-sibling.htm">find-sibling</a> and the name, <code>:list-box</code>.
    There are a number of <b>find-</b> functions. <a
    href="../../operators/cg/f/find-sibling.htm">find-sibling</a> is best in this case because
    only the other controls on the form have to be examined. This function now changes the
    range of list-box to include the entered string (<b>adjoin</b> adds an item to a list if
    it is not already there &#150; if the new string is equal to a string already in the
    range, it is not added).</p>
  </dir>
</dir>

<ul>
  <li>Evaluate this in the system by placing the cursor in the definition or just after the
    final parenthesis and clicking <a
    href="../../ide-menus-and-dialogs/tools-menu.htm#incremental-evaluation">Tools |
    Incremental Evaluation</a>.</li>
  <li>Go back to the running form and click on the Add button. Again you are prompted for a
    string but now, when you enter one and click OK, the string is added to the
    single-item-list. We have added Greetings, Hello, and The quick brown fox. All appear in
    the illustration (The quick brown fox is truncated because we made no provision for lines
    that do not fit).</li>
</ul>

<p><img src="Image24.jpg"></p>

<p>We now have a dialog with the controls communicating with each other. And we were able
to modify the behavior while the form was running. </p>

<h3><a name="sec-3-2"></a>3.2 Building an application</h3>

<p>We can convert this simple example into a standalone application. Early in the example,
we mentioned the Project manager window and used it (if needed) to display the blank form.
Since then we haven't said much about projects.</p>

<p>A project is a collection of modules associated with an application. With the modules
and Allegro CL itself, you can build your application. Modules are parts of the
application and have one or more associated files. Form1 is a module and has associated
files <i>form1.cl</i> and <i>form1.bil</i> (we discuss these types of files in more detail
in <a href="ide_user_guide_4.htm">chapter 4</a>).</p>

<p>We have to be sure that the project contains all the modules necessary, form1 and the
untitled (or <i>excode.cl</i> if you saved it) files. Lots of files are included in an
application so we strongly recommend that you start with an empty folder (like the <i>C:\allegro-projects\project1</i>
subfolder suggested by the system early in this discussion). </p>

<p>If you have saved <em>excode.cl</em> already, you were asked whether you wanted the
file added to the current project. If you answered `yes', the file will be included in the
project. If you answered `no', the file would be saved without adding it to the project.
Suppose that is what you did. You can add that file (or any other) to the project at any
time as follows: 

<ol>
  <li>With just form1 in the project, the general tab of the project manager should look like
    this:<br>
  </li>
  <p><img src="Image25.jpg"></p>
  <li>Add <i>C:\allegro-projects\project1\excode.cl</i> (save the Untitled buffer to that file
    if you haven't already done so -- when you save, you are asked if you want to include the
    file in the current project; if you answer `yes', the rest of this step is not necessary).
    Add the file by clicking on the + button on the Project Manager toolbar and specifying the
    file to the dialog that appears (you first have to identify the file type: <strong>CODE:
    an existing source code file</strong>, in this case). Alternatively, select this buffer in
    the Editor Workbook, right click on the editor pane, and select <b>Add File to Project</b>
    from the shortcut menu that appears. (This avoids having to browse for the file.) After
    the addition, the Project manager looks like this:<br>
  </li>
  <p><img src="ch3-pw-af.jpg"></p>
  <li>Save the files. (A project will not build unless all files are saved.) Click <a
    href="../../ide-menus-and-dialogs/file-menu.htm#save-all">Files | Save All</a>. This will
    save all unsaved files associated with the project. If asked, save form1.cl to <i>C:\allegro-projects\project1\form1.cl</i>
    and <i>project1.lpr</i> (the project file) to <i>C:\allegro-projects\project1\project1.lpr</i>.</li>
  <li>Build the application exe. Click <a
    href="../../ide-menus-and-dialogs/file-menu.htm#build-project-exe">File | Build Project
    exe</a>.</li>
</ol>

<p>A <b>Creating Image</b> window is created (it is not displayed by default but it
appears on the run bar). Information about what is happening while the application is
being built is printed in that window. Note that you cannot do anything while the image is
being created other than waiting. When the build completes (assuming it is successful), a
dialog like this appears:</p>

<p><img src="proj1-build.jpg"></p>

<p>If you click <strong>Run the EXE File</strong>, the application will run. If you click <strong>OK</strong>,
you return to the running Lisp and the IDE.</p>

<p>Look in the <i>C:\allegro-projects\project1</i> folder. You should see <i>project1.exe</i>
and a bunch of other files.</p>

<p>You can start <i>project1.exe</i> by double-clicking on it to run the application. End
the application by clicking on the Close button of the dialog.</p>

<h3><a name="sec-3-3"></a>3.3 The Doodler Tutorial</h3>

<p>The Doodler tutorial is another application whose complete source is included with the
IDE. The tutorial illustrates features of the Allegro CL IDE. We recommend that you run
the tutorial separately. Here we discuss features of the final product rather than taking
you through it step by step.</p>

<p>The code, examples, and so on can be found in the <em>gui-builder-tutorial</em> folder
and its subfolders. We strongly recommend that you use the tutorial to familiarize
yourself with the product. It exercises many of the features of the system, often showing
more than one way to achieve a particular end. It provides many programming examples
(already written). Our hope is that parts of the tutorial will give you examples that will
be useful to you in your own program design. And the result is a program that is at least
visually interesting even if it is not directly relevant to whatever application you want
to write. </p>

<h3><a name="sec-3-3-1"></a>3.3.1 What the doodler application does</h3>

<p>The tutorial application is called the doodler (the name of the project is the
:interface-builder-tutorial project). It has four windows and dialogs: one for choosing a
background color, </p>

<p><img SRC="Image27.jpg"></p>

<p>one for defining a cycloidal curve (by specifying the three relevant coefficients), </p>

<p><img SRC="Image28.jpg"></p>

<p>one for listing and managing the curves defined,</p>

<p><img SRC="Image29.jpg"></p>

<p>and the main window upon which the specified curve or curves are drawn.</p>

<p><img SRC="Image30.jpg"></p>

<p>The files in the final subfolder of the tutorial folder show all the files associated
with the interface-builder-tutorial application after it is completed. Except for the
files <i>util.cl</i>, <i>cycloid.cl</i>, <i>colorx.cl</i>, all of which implement the
application &#150; drawing the curve and choosing a color -- and the several bmp files,
providing the illustrations for the buttons, all the files needed for the application are
generated using the Allegro CL IDE. (Some files, such as the Help file <i>doodler.hlp</i>,
provide assistance in using the tutorial but are not needed by the doodler application.)</p>

<p>Here are the elements of the project listed by the doodler project manager.</p>

<p><img src="../../pictures/pm-doodler.jpg"></p>

<p>We shall return to the doodler application as this chapter progresses. Now we discuss
developing applications in general.</p>

<h3><a name="sec-3-3-2"></a>3.3.2 Developing an application </h3>

<p>Broadly, the steps to developing an application are these: 

<ol>
  <b>
  <li>Decide what the application should do</b>. All applications start with initial data and
    initial input, accept additional input from the user while running, and display results
    based on the initial and runtime data. The results may be output continuously, or from
    time to time, or only at the end. We use `output' in a wide sense, including visual
    display on the screen, sound from speakers, control signals or messages to external
    devices run by the program, and printing of data to some sort of file. You must decide,
    broadly, what data your application will work on and what results will be displayed and
    how these results will be calculated.</li>
  <b>
  <li>Write or procure the application engine</b>. In the last line of step one, we say you
    must determine `how these results will be calculated'. We call the part of the program
    which calculates the results the `engine'. It is possible the engine is already available
    -- your task is to provide the user interface. Or maybe you have to write it yourself. The
    engine in interface-builder-tutorial draws the curve in the doodler window. A compiler is
    an engine, as is a searching program, a drawing program, an editor, and so on. Engines are
    usually rather simple, in that they take inputs and produce outputs. It is the job of the
    user interface to procure these inputs and make the outputs available in a useful form.</li>
  <b>
  <li>Decide on what to do with the results</b>. This step and the next (Decide on how to
    collect the input) can be done in either order, but providing inputs programmatically (for
    testing) is often easier and an application that cannot communicate results is useless. In
    this step, you decide on the format in which the output of the engine will be provided --
    displayed as a picture or text, as sound from a speaker, as a data file or data output
    appropriate as input to another application, or as commands sent directly to a device. We
    will mostly focus on display of results. Writing to a file is usually fairly
    straightforward once you know what to write. The output for the interface-builder-tutorial
    application is the pretty picture, for example. It could also (or in addition) be a copy
    of the picture sent to your printer, a graphics file written to disk, or, if
    interface-builder-tutorial was a component of a larger application, a pixmap object passed
    to the larger application. </li>
  <b>
  <li>Decide on how to collect the input</b>. There are many ways to collect input: from a
    file, from another program, from the user directly. Reading from a file is usually not
    complicated. You just have to find the file and understand its format. Reading from
    another program is often harder (because interprocess communication is often complicated)
    but conceptually, at least, it is straightforward. Interactive input from the user will be
    the main focus of our discussion, both in this chapter and in this manual as a whole. </li>
  <p>Just as there are many ways to say something, there are many ways to collect input from
  a user. The doodler mostly uses buttons, but some numeric input uses an editable text
  control with an associated up-down control:</p>
  <p><img SRC="Image31.jpg"></p>
  <p>It also uses a color choice control that is a standard Windows dialog for choosing
  colors. (Note: that dialog is not associated with one of the forms of the
  interface-builder-tutorial project. It is displayed by <b>ask-user-for-color</b>.) Many
  are designed for and can be used for collecting user input. User input from the mouse is
  still input. </p>
  <b>
  <li>Implement 3 and 4</b>. Much of the work of implementing collection of input (4) and
    display of output (3) can be done using the various tools supplied with the Allegro CL
    IDE, as we describe in this manual.</li>
  <b>
  <li>Fiddle</b>. One of the most powerful features of Allegro CL is that modifications are
    relatively easy and often can be done with a change in only one module while all others
    can be left alone. </li>
</ol>

<h3><a name="sec-3-3-3"></a>3.3.3 The steps in developing the doodler application </h3>

<ol>
  <li>Decide what interface-builder-tutorial should do. Now, of course the real purpose of
    interface-builder-tutorial is to show off the features of the application-building tools
    available in Allegro CL, but that real purpose confuses our purpose. The apparent purpose
    (which we discuss here) is to draw pictures (of cycloid curves) in a window, allowing
    aesthetic enjoyment and obtaining information about how cycloid curves are affected by
    changes in the defining equation. Here are three curves differing only in the value of the
    A coefficient, 100, 200, and 300 for the smallest, middle, and largest curves.<br>
  </li>
  <p><img SRC="Image32.jpg"></p>
  <b>
  <li>Write or procure the application engine</b>. The engine in this application draws the
    specified curves. The file <i>cycloid.cl</i> contains the code which calculates the
    information necessary to draw the curves. (Curves like these are drawn by calculating the
    x and y coordinates of many points of the curve. The curve is drawn by connecting those
    dots.) Fortunately, this engine is provided and does not have to be written at this time.</li>
  <b>
  <li>Decide on what to do with the results</b>. The output is a drawing of one or more
    curves. This drawing could be printed or written to a bitmap file, or drawn on the screen.
    Doodler draws it on the screen. </li>
  <b>
  <li>Decide on how to collect the input</b>. What input might be necessary? Here is all the
    information used to draw the curves:</li>
  <p>The background color of the drawing pane.</p>
  <p>How many curves to draw.</p>
  <p>The A, B, and C coefficients of each curve.</p>
  <p>The line color of each curve.</p>
  <p>Additionally, the user can erase the drawing pane, center the drawing pane, and scroll
  the drawing pane (all information about user desires that must be input somehow). </p>
  <p>It is reasonable to have a window that lists all curves and allows the user to add and
  delete curves from that list. Another window can be used for specifying the details of
  each curve, and another for specifying the background color. Finally, the user must
  somehow give the command to draw the specified curves. This arrangement (a description of
  the actual interface-builder-tutorial windows) is obviously one choice among many. The
  draw command could be placed on the doodler window rather than on the curves window, or
  the erase button could be placed below the Draw All button on the curves window. The
  background color could be implemented by a Background Color button on the doodler window
  (that displayed a color choice dialog immediately) rather than having a background color
  window with a few choices and an option to get more choices. There are no end of possible
  arrangements, some being obviously unsatisfactory (dialogs for each coefficient rather
  than one dialog for all three) but many being equally satisfactory.</p>
  <p>Notice that this step is longer to describe that the others, because there are so many
  possibilities and so few reasons to strongly prefer one choice over another.</p>
  <b>
  <li>Implement 3 and 4</b>. The tutorial goes into great detail about implementing 3 and 4.
    We strongly recommend that you use the tutorial to learn the basics. In this chapter, we
    will discuss some details of implementing 3 and 4 as a way of describing how to do things
    that you will want to do in most all applications. However, we will not describe the
    process of creating the interface-builder-tutorial application step by step.</li>
  <b>
  <li>Fiddle</b>. In 4 above, we mention some choices which are not obviously better than
    other possibilities. Maybe the Draw All button should be on the doodler window itself,
    like the erase button, rather than on the curves window. One reason for this decision is
    the buttons on the doodler window have picture labels and there is no obvious icon for
    draw like there is for erase. (The button on the doodler window that might be draw, the
    one illustrating a drawn curve, actually displays the curve-dialog button.) Maybe there
    should not be a Background Color window at all, just a color button on the doodler window
    that directly displays the common color choice dialog. You can doubtless think of other
    possible changes, some of which would, from your point of view, improve the
    interface-builder-tutorial application. Note that the process of fiddling with an
    application typically adds features, capabilities, and choices, thereby increasing the
    application size and complexity and making it harder to maintain. </li>
</ol>

<h3><a name="sec-3-3-4"></a>3.3.4 The doodler application windows</h3>

<p>There are four windows associated with the doodler application. Each window is designed
by a form during the design process, so there are four forms in the
interface-builder-tutorial project. </p>

<p><img src="Image33.jpg"></p>

<p>These forms are listed on the Options tab of the interface-builder-tutorial Project
Manager. The project started (as all new projects do) with one form. Three others were
added after. Each form was added by clicking on New Form in the File menu. When you click
on <a href="../../ide-menus-and-dialogs/file-menu.htm#new-form">File | New Form</a>, this
dialog appears asking for the Window class of the form:</p>

<p><img src="Image34.jpg"></p>

<p>There are more choices shown in the illustration then will be present in a fresh
Allegro CL. The additional choices, <i>doodler</i>, <i>curve-dialog</i>, <i>coefficient-dialog</i>
and <i>background-palette</i>, were all added as the project was worked on. You are
choosing the type of window corresponding to the form. The default choices (everything but
the four listed as new) provide many capabilities, but creating new classes of devices is
common because you get to add features to the new device class without affecting any
existing example of that class. Consider the doodler choice (the device of the doodler
window). The doodler class is defined as follows (in <i>final\doodler.cl</i>):</p>

<pre>(defclass doodler (bitmap-window)
  &nbsp; ((doodler-curve-dialog
      &nbsp;&nbsp;&nbsp;&nbsp; :accessor doodler-curve-dialog
      &nbsp;&nbsp;&nbsp;&nbsp; :initform nil)
     &nbsp;&nbsp; (doodler-background-palette
         &nbsp;&nbsp;&nbsp;&nbsp; :accessor doodler-background-palette
         &nbsp;&nbsp;&nbsp;&nbsp; :initform nil)))</pre>

<p>That says doodler is a subclass of bitmap-window (a bitmap window is one with an
interior bitmap-pane upon which you can draw). It has two additional slots:
doodler-curve-dialog and doodler-background-palette. They are not initialized. Later, they
are given as values the two dialogs (corresponding to the curve-dialog and
background-palette forms). A <b>show-curve-dialog</b> method is defined as follows:</p>

<pre>(defmethod show-curve-dialog ((window doodler))
  &nbsp;&nbsp; (let* ((dialog (doodler-curve-dialog window))
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (curve-list nil))
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (when (or (not dialog)
                       (not (windowp dialog)))
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setf dialog 
                          (make-curve-dialog :parent window))
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setf (doodler-curve-dialog window) dialog)
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setf curve-list 
                          (find-widget :curve-list dialog))
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setf 
                         (range curve-list)
                         (list 
                          (make-instance 'cycloidal-curve)))
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (move-window dialog
                                     (window-to-screen-units window
                                       (make-position
                                        (- (+ (exterior-width dialog) 10))
                                        40))))
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (select-window dialog)))</pre>

<p>This method is specialized to instances of the doodler class (and thus cannot affect
any other window in the system). Without analyzing the code too closely, if the value of
the doodler-curve-dialog slot is non-nil, it is assumed to be a curve-dialog and
displayed; if it is nil, a curve-dialog is created and displayed. The argument to this
method is the current window (a doodler window). </p>

<p>Why are things done this way? The design is to have a button on the doodler window
which, when clicked, displays the associated curve-dialog. This is implemented by having
the system call show-curve-dialog with the parent (doodler) window as its argument when
the button is clicked. That action displays (creating if necessary) a curve-dialog
associated with the doodler window. The dialog knows which doodler window it is associated
with (because that doodler window is its parent) and the doodler window knows which
curve-dialog it has (because it is the value of the doodler-curve-dialog slot of the
doodler window).</p>

<h3><a name="sec-3-3-5"></a>3.3.5 Popping up a common dialog</h3>

<p>Windows has provided many standard (called common) dialogs for common actions. One is
the file choice dialog (a dialog that lets you pick a file on the system) that everyone is
probably familiar with. Another is the color choice dialog. The background-color dialog
allows a user to choose a background color for the doodler window. Several choices are
provided along with a way to get many more choices and even make a custom color using a
common color-choice dialog (clicking the <b>Other Color</b> button). </p>

<p><img SRC="Image27.jpg"></p>

<p>Let us look at how this is implemented. The code is in <i>background-palette.cl</i>
(the code associated with the background-palette form) and <i>colorx.cl</i>, an auxiliary
source file not specifically associated with a form. In <i>background-palette.cl</i>, we
find the function called when the Add Colors button is clicked:</p>

<pre>(defun background-palette-color-button-on-change 
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (widget new-value old-value)
  &nbsp; (declare (ignore-if-unused widget 
                               new-value old-value))
  &nbsp; (when new-value 
      &nbsp;&nbsp;&nbsp;&nbsp; (add-other-color (parent widget)))
  &nbsp; (not new-value))</pre>

<p><strong>add-other-color</strong>, defined in <i>colorx.cl</i>, is defined as follows:</p>

<pre>(defmethod add-other-color ((dialog color-mixin))
  &nbsp;&nbsp; (let* ((new-color (ask-user-for-color
                        :initial-color (current-color dialog)))
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (color-list (find-widget 
                                   :color-list dialog))
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (color-name nil))
       &nbsp;&nbsp;&nbsp;&nbsp; ;; do nothing if user canceled
       (when new-color
         &nbsp;&nbsp; ;; do not add color if it already is on the list.</pre>

<pre>  #| So far, a color-choose common dialog has been displayed and the user 
     has either specified a new color or canceled. If a new color is chosen, 
     it is added to the list of defined background colors and the multi-picture 
     button is expanded to include the new color.
   |#
         &nbsp; (when (not (setf color-name 
                        (find-color-name dialog new-color)))
             &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setf color-name (new-color-name dialog))
             &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let* ((colors (range color-list)))
                     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setf (range color-list)
                               (append colors
                                       (list (make-instance 'button-info
                                               :name color-name
                                               :image new-color
                                               :string nil
                                               :height nil
                                               :tooltip nil
                                               :help-string nil))))))
         &nbsp;&nbsp; ;; change which color is pressed
         &nbsp;&nbsp; (setf (value color-list) (list color-name)))))</pre>

<p>The call to <a href="../../operators/cg/a/ask-user-for-color.htm">ask-user-for-color</a>
pops up a color choice dialog. The <strong>add-other-color</strong> function does what is
necessary when a new color is chosen. You can mimic the code here when you want to pop up
a common dialog and use the result of user action in your application.</p>

<p>Go to <a href="ide_user_guide_4.htm">chapter 4</a>. Go to <a href="#begin">beginning</a>
of this chapter.</p>

<hr>

<p><small>Copyright (c) 1998-2010, Franz Inc. Berkeley, CA., USA. All rights reserved.</small><br>
<small>Documentation for Allegro CL version 8.2. This is the initial (unrevised) page.</small><br>
<small>Created 2009.12.09.</small></p>

<table border="0" width="100%" cellpadding="1" cellspacing="0">
  <tr>
    <td bgcolor="#00FFFF"><table border="0" cellpadding="5" cellspacing="3">
      <tr>
        <td align="left" bgcolor="#00FFFF"><a href="../../contents.htm"><b>ToC</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../../introduction.htm"><b>DocOverview</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../../cgide.htm"><b>CGDoc</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../../release-notes.htm"><b>RelNotes</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../../index.htm"><b>Index</b></a></td>
        <td align="left" bgcolor="#00FFFF"><a href="../../permuted-index.htm"><b>PermutedIndex</b></a></td>
      </tr>
    </table>
    </td>
    <td align="right"><b>Allegro CL version 8.2</b></td>
  </tr>
</table>
</body>
</html>
